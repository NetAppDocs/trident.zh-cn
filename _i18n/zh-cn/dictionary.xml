<?xml version="1.0" encoding="UTF-8"?>
<blocks>
  <block id="8447c4879970f03c99a2bec36a05c141" category="summary">如果您希望与 Astra Trident 的 REST API 进行交互，则可以直接使用 REST 端点。</block>
  <block id="a0ebcf8495639418ba9d4b85dbb67b8b" category="doc">Astra Trident REST API</block>
  <block id="319c1a7b5479ffa2a028b658ad5b7033" category="inline-link-macro">tridentctl 命令和选项</block>
  <block id="d7c9226cc31c5b12ee3114bc7014c075" category="paragraph">这对于在非 Kubernetes 部署中使用 Astra Trident 作为独立二进制文件的高级安装非常有用。</block>
  <block id="ff307287df4629ad827fba73568b9a58" category="paragraph">为了提高安全性，在 Pod 内部运行时， Astra Trident 的 `reST API` 默认限制为 localhost 。要更改此行为，您需要在其 Pod 配置中设置 Astra Trident 的 ` 地址` 参数。</block>
  <block id="8b3c7aa88e751573c842f17535525f19" category="paragraph">API 的工作原理如下：</block>
  <block id="7528035a93ee69cedb1dbddb2f0bfcc8" category="section-title">获取</block>
  <block id="2fab7aa97b6a2cfae6563e72aac5161e" category="list-text">`get &lt;trident 地址 &gt;/trident /v1/&lt; 对象类型 &gt;` ：列出此类型的所有对象。</block>
  <block id="c34156b367bae1b376f09b89d3be7992" category="list-text">`get &lt;trident 地址 &gt;/trident /v1/&lt; 对象类型 &gt;/&lt; 对象名称 &gt;` ：获取命名对象的详细信息。</block>
  <block id="a02439ec229d8be0e74b0c1602392310" category="section-title">发布</block>
  <block id="6692e2cd6834e6b9b2151799cac2a9f8" category="paragraph">`post &lt;trident 地址 &gt;/trident /v1/&lt; 对象类型 &gt;` ：创建指定类型的对象。</block>
  <block id="ce87eb03803d5633c163541464e9e7f2" category="inline-link-macro">`tridentctl` 命令和选项</block>
  <block id="3d2bacacf0178e742d5abb2abc32d431" category="list-text">需要为要创建的对象配置 JSON 。有关每种对象类型的规范，请参见 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>。</block>
  <block id="5b2f45c3d098b61927afda859c9144f8" category="list-text">如果对象已存在，则行为会有所不同：后端更新现有对象，而所有其他对象类型将使操作失败。</block>
  <block id="32f68a60cef40faedbc6af20298c1a1e" category="section-title">删除</block>
  <block id="ecfc51243c8c28fc234ff87f1f9ddb88" category="paragraph">`delete &lt;trident 地址 &gt;/trident /v1/&lt; 对象类型 &gt;/&lt; 对象名称 &gt;` ：删除指定的资源。</block>
  <block id="80e4e3d3203325fb6aeb139614fd09f3" category="admonition">与后端或存储类关联的卷将继续存在；必须单独删除这些卷。有关详细信息，请参见 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>。</block>
  <block id="ce94b1f7df7a6a05a559b66f96eff1cc" category="paragraph">有关如何调用这些 API 的示例，请传递 debug （` -d` ）标志。有关详细信息，请参见 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>。</block>
  <block id="a1582c89f8e85f372306a05848eafb68" category="summary">NetApp 存储产品组合可与 Kubernetes 集群的许多不同方面相集成，从而提供高级数据管理功能，从而增强 Kubernetes 部署的功能，功能，性能和可用性。</block>
  <block id="9944b094c4079f770fabc4ae629feb0f" category="doc">与 Kubernetes 集成的 NetApp 产品</block>
  <block id="3cce5f3eaf76e098ba8e28f7bbba3f92" category="section-title">Astra</block>
  <block id="293b14f82e58fc3efc27bf18185a38c8" category="paragraph"><block ref="35a6b548833df39b8bbc748563b1938b" category="inline-link-rx"></block> 使企业能够更轻松地管理，保护和移动在公有云内部和内部环境中以及之间的 Kubernetes 上运行的数据丰富的容器化工作负载。Astra 使用 NetApp 在公有云和内部环境中成熟而广泛的存储产品组合中的 Trident 配置和提供永久性容器存储。此外，它还提供了一组丰富的高级应用程序感知型数据管理功能，例如快照，备份和还原，活动日志和主动克隆，用于数据保护，灾难 / 数据恢复，数据审核以及 Kubernetes 工作负载的迁移用例。</block>
  <block id="253b40ae359ba25b56231803430c4873" category="section-title">ONTAP</block>
  <block id="51fd2fc669e51c6870f1148623240f69" category="paragraph">ONTAP 是 NetApp 的多协议统一存储操作系统，可为任何应用程序提供高级数据管理功能。ONTAP 系统采用全闪存，混合或全 HDD 配置，并提供多种不同的部署模式，包括专门设计的硬件（ FAS 和 AFF ），白盒（ ONTAP Select ）和纯云（ Cloud Volumes ONTAP ）。</block>
  <block id="cbb7697b4f6f189240d043ff70ca133c" category="admonition">Trident 支持上述所有 ONTAP 部署模式。</block>
  <block id="117bdbda976fe8b3212bc3b6327a0a1b" category="section-title">Cloud Volumes ONTAP</block>
  <block id="5c04ffbd0c110bf7b37d6b95eb756b75" category="paragraph"><block ref="700b45b9fca207b66f675c8d5dfb073b" category="inline-link-rx"></block> 是一款纯软件存储设备，可在云中运行 ONTAP 数据管理软件。您可以将 Cloud Volumes ONTAP 用于生产工作负载、灾难恢复、 DevOps 、文件共享和数据库管理。它通过提供存储效率，高可用性，数据复制，数据分层和应用程序一致性，将企业级存储扩展到云。</block>
  <block id="4d82a1ec1af02725042c8c785564ee7a" category="section-title">适用于 NetApp ONTAP 的 Amazon FSX</block>
  <block id="04452ff4732608f62e53d20e4b8f4c92" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block> 是一种完全托管的 AWS 服务，可使客户启动和运行由 NetApp ONTAP 存储操作系统提供支持的文件系统。借助适用于 ONTAP 的 FSX ，客户可以利用他们熟悉的 NetApp 功能，性能和管理功能，同时利用在 AWS 上存储数据的简便性，灵活性，安全性和可扩展性。FSX for ONTAP 支持 ONTAP 的许多文件系统功能和管理 API 。</block>
  <block id="27bb76bfb1e4f9966c31f5042348cd1e" category="section-title">Element 软件</block>
  <block id="231afe47f3f37d3808096b36c28b4ded" category="inline-link">Element</block>
  <block id="1fdf61a8f946268990d8e15dd9069a6d" category="paragraph"><block ref="eca39b018af81e7b5c8e71b5b4aa3790" category="inline-link-rx"></block> 通过保证性能并简化存储占用空间，使存储管理员能够整合工作负载。Element 与 API 相结合，可实现存储管理各个方面的自动化，可帮助存储管理员事半功倍。</block>
  <block id="08edd2123939d5309dced149763a50ee" category="section-title">NetApp HCI</block>
  <block id="25f221cc63a7e1fa55b05c29420a72a2" category="paragraph"><block ref="2841e7defe3939e68d83d007d1ad666b" category="inline-link-rx"></block> 通过自动化执行日常任务并使基础架构管理员能够专注于更重要的功能，简化数据中心的管理和扩展。</block>
  <block id="be17f8b9c728a6cb61cad5a2609b3888" category="paragraph">Trident 完全支持 NetApp HCI 。Trident 可以直接在底层 NetApp HCI 存储平台上为容器化应用程序配置和管理存储设备。</block>
  <block id="b146010b35b21e2354c084cf6d1d2a5d" category="section-title">SANtricity</block>
  <block id="6161e6c043d51e8eea03494bff7fc57b" category="paragraph">NetApp 的 E 系列和 EF 系列存储平台使用<block ref="01c1197ee4ca6d1b24476d1f7b6bc83e" category="inline-link-rx"></block> 操作系统，可提供功能强大的存储，该存储具有高可用性，高性能，能够为任何规模的应用程序提供存储服务。</block>
  <block id="9589e472cb7c5e0d01ca15ecca72de0d" category="paragraph">Trident 可以在整个产品组合中创建和管理 SANtricity 卷。</block>
  <block id="7450cfde7058dc5e1f7909d0280fd7ae" category="section-title">Azure NetApp Files</block>
  <block id="29e7ab00082418141d470583a19c28d3" category="paragraph"><block ref="2384314bcd106c8062815b2ed789c4ad" category="inline-link-rx"></block> 是一种企业级 Azure 文件共享服务，由 NetApp 提供支持。您可以在 Azure 中以本机方式运行要求最苛刻的基于文件的工作负载，同时享受 NetApp 应有的性能和丰富的数据管理功能。</block>
  <block id="06021ba1ee96f1a3a57b50001fc7244c" category="section-title">适用于 AWS 的 Cloud Volumes Service</block>
  <block id="962483cc436ac01febcdca57fff4735f" category="inline-link">适用于 AWS 的 NetApp Cloud Volumes Service</block>
  <block id="9cd398e3307ca354d12d0f47aca4f913" category="paragraph"><block ref="a105e3d261515148b2a94b7605496120" category="inline-link-rx"></block> 是一种云原生文件服务，可通过 NFS 和 SMB 提供具有全闪存性能的 NAS 卷。此服务支持在 AWS 云中运行任何工作负载，包括原有应用程序。它提供了一种完全托管的服务，可提供稳定一致的高性能，即时克隆，数据保护以及对弹性容器服务（ Elastic Container Service ， ECS ）实例的安全访问。</block>
  <block id="b0cee72642f5457a71ddd0b49efb6d93" category="section-title">适用于 Google Cloud 的 Cloud Volumes Service</block>
  <block id="a3b5183ae6f5c3f1d6644448f795b5cb" category="inline-link">适用于 Google Cloud 的 NetApp Cloud Volumes Service</block>
  <block id="a1515efe69d0ac9d979af2bdfc068934" category="paragraph"><block ref="68704f3321dd8ca7029c03c29da7736a" category="inline-link-rx"></block> 是一种云原生文件服务，可通过 NFS 和 SMB 提供具有全闪存性能的 NAS 卷。此服务支持在 GCP 云中运行任何工作负载，包括原有应用程序。它提供了一种完全托管的服务，可提供稳定一致的高性能，即时克隆，数据保护以及对 Google Compute Engine （ GCE ）实例的安全访问。</block>
  <block id="5ee08ab883e000ce6b739dbb0b6ff376" category="summary">详细了解 Kubernetes 系统的各个部分。</block>
  <block id="607ae6360b32f1bd6e559e915d414fab" category="doc">Kubernetes 概念</block>
  <block id="d60f0fff1c23a02458849862f593357e" category="inline-link">Kubernetes 系统</block>
  <block id="a7018a5fd7b610274c7786aa5402e64d" category="paragraph">详细了解的各个部分<block ref="f01a74527fa0343e793eb393c9d4809a" category="inline-link-rx"></block>。</block>
  <block id="7a90ecd4cb81a2963b963ac8c0bba0a2" category="summary">Astra Trident 会显示多个命令行选项并通过某些端口进行通信。</block>
  <block id="7d4fab76513c90b603a722620cde60fe" category="doc">命令行选项</block>
  <block id="576f889bab2702f907ac880da895cddb" category="paragraph">Astra Trident 会显示多个命令行选项。您可以在部署中修改它们。</block>
  <block id="8db7df66ab1d7ab5f1dc947acdb5fae4" category="section-title">日志记录</block>
  <block id="7e2a14542a2613424ad88206fd2dd9aa" category="list-text">` -debug` ：启用调试输出。</block>
  <block id="55e727716c7f623987be58e50732c01e" category="list-text">` -loglevel &lt;level&gt;` ：设置日志记录级别（调试，信息，警告，错误，致命）。默认为 INFO 。</block>
  <block id="30136395f01879792198317c11831ea4" category="section-title">Kubernetes</block>
  <block id="5700f5ae190580b01f6ed6c031668336" category="list-text">` -K8s_pod` ：使用此选项或 ` -K8s_api_server` 启用 Kubernetes 支持。如果设置此值，则 Trident 将使用其所属 POD 的 Kubernetes 服务帐户凭据来联系 API 服务器。只有当 Trident 在启用了服务帐户的 Kubernetes 集群中作为 POD 运行时，此功能才有效。</block>
  <block id="24095e7ef85031e99914e2c5298a7ded" category="list-text">` -K8s_api_server &lt; 不安全地址：不安全端口 &gt;` ：使用此选项或 ` -K8s_pod` 启用 Kubernetes 支持。指定后， Trident 将使用提供的不安全地址和端口连接到 Kubernetes API 服务器。这样可以在 Pod 之外部署 Trident ；但是，它仅支持与 API 服务器的不安全连接。要安全连接，请使用 ` -K8s_pod` 选项将 Trident 部署在 Pod 中。</block>
  <block id="9d77217a2dfe50f2575ced46f5e661d8" category="list-text">` -K8s_config_path &lt;file&gt;` ：必需；必须指定 KubeConfig 文件的路径。</block>
  <block id="c5fd214cdd0d2b3b4272e73b022ba5c2" category="section-title">Docker</block>
  <block id="1e071a3d810132af1c9f8f6a03ca5609" category="list-text">` -volume_driver &lt; 名称 &gt;` ：注册 Docker 插件时使用的驱动程序名称。默认为 `NetApp` 。</block>
  <block id="dfbbfd6bbf6bc798d1cbe8895d1cff22" category="list-text">` -driver_port &lt;port-number&gt;` ：侦听此端口，而不是 UNIX 域套接字。</block>
  <block id="3874d7b8c9196001f8bfe4c49f43b323" category="list-text">` 配置 &lt; 文件 &gt;` ：必需；您必须指定后端配置文件的路径。</block>
  <block id="50780f47f6839d47d60bc4555ee00c3f" category="section-title">REST</block>
  <block id="bfffd3cb0560af555e57dd6bad52a9be" category="list-text">` 地址 &lt;ip-or-host&gt;` ：指定 Trident 的 REST 服务器应侦听的地址。默认为 localhost 。在本地主机上侦听并在 Kubernetes Pod 中运行时，无法从 Pod 外部直接访问 REST 接口。使用 ` 地址 ""` 可从 Pod IP 地址访问 REST 接口。</block>
  <block id="049ad2e7bef322af60013bbdd35ebbe7" category="list-text">` -port &lt;port-number&gt;` ：指定 Trident 的 REST 服务器应侦听的端口。默认为 8000 。</block>
  <block id="188cb756fe8659cb2caf27ca6d1446b4" category="list-text">` -REST` ：启用 REST 接口。默认为 true 。</block>
  <block id="afe272beb780ad53d441c342bf1c8c77" category="summary">了解有关 tridentctl 的更多信息， tridentctl 是一个命令行实用程序，可用于轻松访问 Trident 。</block>
  <block id="7358b1fd077fa65f88fff87888fd2547" category="inline-link">Trident 安装程序包</block>
  <block id="4e49f66de2e2dc43c25555fe50639334" category="paragraph">。<block ref="5a856e83aada9750fe5389f8da94335b" category="inline-link-rx"></block> 包括一个命令行实用程序 `tridentctl` ，可用于轻松访问 Astra Trident 。具有足够权限的 Kubernetes 用户可以使用它来安装 Astra Trident ，并直接与其交互以管理包含 Astra Trident Pod 的命名空间。</block>
  <block id="8ca34267f11cb69ea424bc0320f0e295" category="paragraph">有关使用情况信息，请运行 `tridentctl -help` 。</block>
  <block id="2dd878ee55d738aa02e6b0b162d45708" category="paragraph">可用命令：</block>
  <block id="4386bd8da14af923cbb7ac011ffc048e" category="list-text">`create` ：将资源添加到 Astra Trident 。</block>
  <block id="f40f9a4cf242d0355aaf8d9e06617436" category="list-text">`d删除` ：从 Astra Trident 中删除一个或多个资源。</block>
  <block id="94b75e236d78fe800d1d32acc3882789" category="list-text">`获取` ：从 Astra Trident 获取一个或多个资源。</block>
  <block id="bc9ef80dceea04796c6218fe96e05b30" category="list-text">`帮助` ：有关任何命令的帮助。</block>
  <block id="f5421bf790b945f508fa1b9f223318e5" category="list-text">`images` ：打印一个包含 Astra Trident 所需容器映像的表。</block>
  <block id="40e65170f778aaa7f4ab7f645b3bb3df" category="list-text">`import` ：将现有资源导入到 Astra Trident 。</block>
  <block id="a824e587817131e2052a450803b2d97c" category="list-text">`安装` ：安装 Astra Trident 。</block>
  <block id="c90c365a06ede3139cad79d4e55673ee" category="list-text">`logs` ：从 Astra Trident 打印日志。</block>
  <block id="e5c5ad2be68f58e910aa42a9fcc98141" category="list-text">`sEnd` ：从 Astra Trident 发送资源。</block>
  <block id="3166458a066b2d14394e408f1f8fed84" category="list-text">`卸载` ：卸载 Astra Trident 。</block>
  <block id="8c8fcf9d4df8bd54d26dc748cc4bac55" category="list-text">`update` ：修改 Astra Trident 中的资源。</block>
  <block id="042aeda3cc45bf1f53a0e74660dbd924" category="list-text">`升级` ：升级 Astra Trident 中的资源。</block>
  <block id="d014c15bf0496b645d02caf1704932f7" category="list-text">`version` ：打印 Astra Trident 的版本。</block>
  <block id="1c90ba5cf3791b6148c7887a696911ec" category="paragraph">flags</block>
  <block id="568cd496b6bde641a886745edfa59ae7" category="list-text">`` -d ， -debug` ：调试输出。</block>
  <block id="fe27ec35afa597521f9616f18c32e556" category="list-text">`` -h ， -help` ：帮助 `tridentctl` 。</block>
  <block id="874377d6c0baee9e8e842c8abf13d28c" category="list-text">`` -n ， -namespace string` ： Astra Trident 部署的命名空间。</block>
  <block id="463b413ea9e7764a789f3e987cb06fc8" category="list-text">`` -o ， -output string` ：输出格式。json_yaml_name_wide|ps 之一（默认）。</block>
  <block id="85c5338e138fc6d122a579f7a07040bf" category="list-text">`` -s ， -server string` ： Astra Trident REST 接口的地址 / 端口。</block>
  <block id="76ea0bebb3c22822b4f0dd9c9fd021c5" category="section-title">创建</block>
  <block id="b8d486e9285b25b72d6efad05e41de4d" category="paragraph">您可以使用 run the `create` 命令向 Astra Trident 添加资源。</block>
  <block id="6d5c7e6905e460d1fba1f2dd1c0d2a8a" category="paragraph">可用选项： `backend` ：将后端添加到 Astra Trident 。</block>
  <block id="099af53f601532dbd31e0ea99ffdeb64" category="section-title">删除</block>
  <block id="0d847e459450017616b8ab50b372ad2e" category="paragraph">您可以运行 `delete` 命令从 Astra Trident 中删除一个或多个资源。</block>
  <block id="16713f316b7cce82385c040efc32ac83" category="paragraph">可用选项：</block>
  <block id="417f8bf14ed5852917d189612c7d163c" category="list-text">`后端` ：从 Astra Trident 中删除一个或多个存储后端。</block>
  <block id="cafc31fff08c0637f779500b7840fe1e" category="list-text">`node` ：从 Astra Trident 中删除一个或多个 CSI 节点。</block>
  <block id="4896fd245b78ab9b7d044375c1fce85e" category="list-text">`snapshot` ：从 Astra Trident 中删除一个或多个卷快照。</block>
  <block id="cef6b6bb7932e7450e35eafc3d986f18" category="list-text">`storageclass` ：从 Astra Trident 中删除一个或多个存储类。</block>
  <block id="14eeaf8d1da512153855b759185ee129" category="list-text">`volume` ：从 Astra Trident 中删除一个或多个存储卷。</block>
  <block id="b5eda0a74558a342cf659187f06f746f" category="section-title">获取</block>
  <block id="c7a7a677647f05a4032891d4aef5bed5" category="paragraph">您可以运行 `get` 命令从 Astra Trident 获取一个或多个资源。</block>
  <block id="2dd609bd837a41363817262fd314b0be" category="list-text">`后端` ：从 Astra Trident 获取一个或多个存储后端。</block>
  <block id="ad4ba4a1b0612fa67f4386330ac00e9d" category="list-text">`snapshot` ：从 Astra Trident 获取一个或多个快照。</block>
  <block id="5385ccfb9fd8a07e53dc1a6ac58a101d" category="list-text">`storageclass` ：从 Astra Trident 获取一个或多个存储类。</block>
  <block id="060da5b15e6fb7129c04e18b3d96c702" category="list-text">`volume` ：从 Astra Trident 获取一个或多个卷。</block>
  <block id="59b514174bffe4ae402b3d63aad79fe0" category="section-title">映像</block>
  <block id="16ca0a361439e1f936eaa5c919443b10" category="paragraph">您可以运行 `images` 标志来打印包含 Astra Trident 所需容器映像的表。</block>
  <block id="1008ac4609cab9210ae758ff8fee8127" category="paragraph">标志： * `` -h ， -help` ：图像帮助。* `` -v ， -k8s-version 字符串` ： Kubernetes 集群的语义版本。</block>
  <block id="f6c534966bc7687e0c87134d025f8837" category="section-title">导入卷</block>
  <block id="df5ec83145dcd824f8daf85d89e5dd8a" category="paragraph">您可以运行 `import volume` 命令将现有卷导入到 Astra Trident 。</block>
  <block id="ccf1bb29ef5562c033962d35014005e9" category="paragraph">别名： `volume ， v`</block>
  <block id="48c7ae9a5466415a6b9666ad86746640" category="list-text">`` -f ， -filename string` ： YAML 或 JSON PVC 文件的路径。</block>
  <block id="1bb2af29a08ab6ea9414a8656234b8c6" category="list-text">`` -h ， -help` ：卷帮助。</block>
  <block id="0ad393d5c23749c23f3855220b55375a" category="list-text">`` -no-manage` ：仅创建 PV/PVC 。不要假定卷生命周期管理。</block>
  <block id="19ad89bc3e3c9d7ef68b89523eff1987" category="section-title">安装</block>
  <block id="42ddf993417d9568ca6a057fe55f9c63" category="paragraph">您可以运行 `install` 标志来安装 Astra Trident 。</block>
  <block id="d14ef114d140fec912921e8447a4dd25" category="list-text">`` -autosupport-image string` ： AutoSupport 遥测的容器映像（默认为 "netapp/trident autosupport ： 20.07.0" ）。</block>
  <block id="fbd7cc4267716ab9206612c6dcaa206e" category="list-text">`` -autosupport-proxy string` ：用于发送 AutoSupport 遥测的代理的地址 / 端口。</block>
  <block id="8bb3d6751910d39b8c964e90434b79db" category="list-text">`` -CSI` ：安装 CSI Trident （仅对 Kubernetes 1.13 进行覆盖，需要功能安全门）。</block>
  <block id="778cbd0cbbd73953bc965ad29269803c" category="list-text">`` -enable-node-prep` ：尝试在节点上安装所需的软件包。</block>
  <block id="23945a1dd08f0fb29fc1b73a02a2f48d" category="list-text">`` -generate-custom-yaml` ：在不安装任何内容的情况下生成 YAML 文件。</block>
  <block id="351ac43ddb05bc31fb7aa4d76c9098ed" category="list-text">`` -h ， -help` ：安装帮助。</block>
  <block id="3b825e283b9b4452c1ef223373ad950d" category="list-text">`` -image-regRegistry string` ：内部映像注册表的地址 / 端口。</block>
  <block id="ba7224837b2ded4b5b295c1012fcc2c0" category="list-text">`` -K8s-timeout duration` ：所有 Kubernetes 操作的超时（默认值为 3 毫秒）。</block>
  <block id="6018142252ad7b87dc139b3235ff4fd3" category="list-text">`` -kubelet-dir string` ： kubelet 内部状态的主机位置（默认为 "/var/lib/kubelet" ）。</block>
  <block id="e36f8ff54239eb329caf981624e29cb9" category="list-text">`` -log-format string` ： Astra Trident 日志记录格式（文本， json ）（默认为 "text" ）。</block>
  <block id="75f452bd493d8727bcf31563cc9106b4" category="list-text">`` -pv 字符串` ： Astra Trident 使用的原有 PV 名称，用于确保此名称不存在（默认为 "trident " ）。</block>
  <block id="ba2a8d0773dc83972c406043a789e4dd" category="list-text">`` -PVC 字符串` ： Astra Trident 使用的原有 PVC 的名称，用于确保此名称不存在（默认为 "trident " ）。</block>
  <block id="6c99958eae5167b3baa561e4f7ee33f1" category="list-text">`` -silning-autosupport` ：不要自动向 NetApp 发送 AutoSupport 捆绑包（默认为 true ）。</block>
  <block id="77c96d54825d934e8abaadbc0049935d" category="list-text">`` —静默` ：在安装期间禁用大多数输出。</block>
  <block id="daeedc3203fdc6c1fb8dfe70e2381ed3" category="list-text">`` -trident 映像字符串` ：要安装的 Astra Trident 映像。</block>
  <block id="9a7a8500c6fa970d6879b522c3e33437" category="list-text">`` -use-custom-yaml` ：使用设置目录中现有的任何 YAML 文件。</block>
  <block id="bbf23448d408765a1240d287ed41ceff" category="list-text">`` -use-ipv6` ：使用 IPv6 进行 Astra Trident 的通信。</block>
  <block id="2165e4fa5bddb65a31f6a0c495c2fa37" category="section-title">日志</block>
  <block id="501416d02a886c81e8849b2f400e28a3" category="paragraph">您可以运行 `logs` 标志从 Astra Trident 打印日志。</block>
  <block id="be8607b2dc354b7010b1464ac140fc1b" category="list-text">`` A ， -archive` ：使用所有日志创建支持归档，除非另有说明。</block>
  <block id="d8d07479f4d5c7f0ef2b0f51407f070c" category="list-text">`` -h ， -help` ：日志帮助。</block>
  <block id="f925a9593a051a85d10acec74988d84f" category="list-text">`` -l ， -log 字符串` ：要显示的 Astra Trident 日志。Trident 中的一个 "auto"|trident 操作符 "All" （默认为 "auto" ）。</block>
  <block id="d8a224d86fa21c6c564987d0848bf681" category="list-text">`` -node string` ：用于收集节点 Pod 日志的 Kubernetes 节点名称。</block>
  <block id="a335d03b82ae4916c848dd419432f477" category="list-text">`` -p ， -previous` ：获取先前容器实例（如果存在）的日志。</block>
  <block id="d7d7c214e32f71943c71783fa9d5fb55" category="list-text">`` -sidecar` ：获取 sidecar 容器的日志。</block>
  <block id="2541d938b0a58946090d7abdde0d3890" category="section-title">发送</block>
  <block id="3121026e841bd19d147c54ac43e423c0" category="paragraph">您可以运行 `send` 命令从 Astra Trident 发送资源。</block>
  <block id="9ce1e94be8ccb1612967a7e2cbe69a6f" category="paragraph">可用选项： `AutoSupport` ：将 AutoSupport 归档发送到 NetApp 。</block>
  <block id="fe98497efedbe156ecc4b953aea77e07" category="section-title">卸载</block>
  <block id="e980a564a92aa568234d9757a591756b" category="paragraph">您可以运行 `uninstall` 标志来卸载 Astra Trident 。</block>
  <block id="dcb0c76edbe301ede057149da76bf89b" category="paragraph">标志： * ` -h ， -help` ：卸载帮助。* ` —静默` ：在卸载期间禁用大多数输出。</block>
  <block id="3ac340832f29c11538fbe2d6f75e8bcc" category="section-title">更新</block>
  <block id="328865de703bbe034177e6eb51dc3d28" category="paragraph">您可以运行 `update` 命令来修改 Astra Trident 中的资源。</block>
  <block id="8680f448b33371bcb4778563a93f4702" category="paragraph">可用选项： `backend` ：在 Astra Trident 中更新后端。</block>
  <block id="ae26b3d8e556703291282149e3ae894f" category="section-title">升级</block>
  <block id="87911de7a0bc3ff821f75ab303a0edc0" category="paragraph">您可以运行 `upgrade` 命令来升级 Astra Trident 中的资源。</block>
  <block id="70cc5172db10ac60dd0b32e57285e85c" category="paragraph">可用选项： `volume` ：将一个或多个永久性卷从 NFS/iSCSI 升级到 CSI 。</block>
  <block id="2af72f100c356273d46284f6fd1dfc08" category="section-title">version</block>
  <block id="9867997bba4e250bad7411d19fce3905" category="paragraph">您可以运行 `version` 标志来打印 `tridentctl` 的版本以及正在运行的 Trident 服务。</block>
  <block id="800f73959f4b721c78f4651c6b4b2052" category="paragraph">标志： * ` -client` ：仅限客户端版本（不需要服务器）。* ` -h ， -help` ：版本帮助。</block>
  <block id="04333ff788951193122a833ecd614950" category="summary">Kubernetes 与 Trident ， Trident 与存储以及 Kubernetes 与存储之间的关系由多个资源对象决定。其中一些对象通过 Kubernetes 进行管理，而另一些对象则通过 Trident 进行管理。</block>
  <block id="da1e63dd673a1932cebb48b6a81bbbb1" category="doc">Kubernetes 和 Trident 对象</block>
  <block id="d107eefb0ce66911b186b03b9e9c337e" category="paragraph">您可以通过读取和写入资源对象来使用 REST API 与 Kubernetes 和 Trident 进行交互。Kubernetes 与 Trident ， Trident 与存储以及 Kubernetes 与存储之间的关系由多个资源对象决定。其中一些对象通过 Kubernetes 进行管理，而另一些对象则通过 Trident 进行管理。</block>
  <block id="62499e0de79c4d07c7915a36f9faa0d8" category="section-title">对象如何相互交互？</block>
  <block id="b9ea565816618011ca591fc191fe5e63" category="paragraph">了解对象，对象的用途以及对象交互方式的最简单方法可能是，遵循 Kubernetes 用户的单个存储请求：</block>
  <block id="ec7d6500a82a56ee8f5fff02eafa7af7" category="list-text">用户创建一个 `PersistentVolumeClaim` ，请求管理员先前配置的 Kubernetes `StorageClass` 中具有特定大小的新 `PersistentVolume` 。</block>
  <block id="6b25cc026b6f29464d3fce0f6ec67805" category="list-text">Kubernetes `StorageClass` 将 Trident 标识为其配置程序，并包含一些参数，用于指示 Trident 如何为请求的类配置卷。</block>
  <block id="5b078d6b19593ee6c55f428e2c85faa7" category="list-text">Trident 会查看自己的 `StorageClass` 并使用相同的名称来标识匹配的 `Backend` 和 `StoragePools` ，它可以使用这些卷为该类配置卷。</block>
  <block id="ff099186f912c7abb21bcf68690c98d7" category="list-text">Trident 会在匹配的后端配置存储并创建两个对象： Kubernetes 中的 A `PersistentVolume` 用于告知 Kubernetes 如何查找，挂载和处理卷； Trident 中的一个卷用于保留 `PersistentVolume` 与实际存储之间的关系。</block>
  <block id="6d2ae40bc02e88464563ae42ae22d54c" category="list-text">Kubernetes 会将 `PersistentVolumeClaim` 绑定到新的 `PersistentVolume` 。包含 `PersistentVolumeClaim` 的 Pod 会将此 PersistentVolume 挂载到其运行所在的任何主机上。</block>
  <block id="490c1b0e3a604c81abb3db1b778ec07b" category="list-text">用户使用指向 Trident 的 `VolumeSnapshotClass` 创建现有 PVC 的 `VolumeSnapshot` 。</block>
  <block id="9f4e11d34d158ebd365226367c8b15d9" category="list-text">Trident 标识与 PVC 关联的卷，并在其后端创建卷的快照。此外，它还会创建一个 `VolumeSnapshotContent` ，指示 Kubernetes 如何识别快照。</block>
  <block id="c6a606bdd6882cd42de13f2ba3614285" category="list-text">用户可以使用 `VolumeSnapshot` 作为源创建 `PersistentVolumeClaim` 。</block>
  <block id="8ecb92f33c033b00fcf3c18e59c4b177" category="list-text">Trident 可识别所需的快照，并执行与创建 `PersistentVolume` 和 `Volume` 相同的一组步骤。</block>
  <block id="428895404a5e57e01a138a5df672d0fc" category="inline-link">永久性卷</block>
  <block id="173423532ed9a565a05f32db2c8f8172" category="admonition">要进一步了解 Kubernetes 对象，强烈建议您阅读<block ref="92dc8ed82beb7484ab6097a3e91b0deb" category="inline-link-rx"></block> Kubernetes 文档的一节。</block>
  <block id="e21ffd3da11b6c6deee412bfb8695e30" category="section-title">Kubernetes PersistentVolumeClaim 对象</block>
  <block id="794a32773794ee6c545794c065d1a88b" category="paragraph">Kubernetes `PersistentVolumeClaim` 对象是 Kubernetes 集群用户发出的存储请求。</block>
  <block id="43cf8e1465c61efc8b1b9bf71aa9931c" category="paragraph">除了标准规范之外，如果用户要覆盖在后端配置中设置的默认值， Trident 还允许用户指定以下特定于卷的标注：</block>
  <block id="55f6611cb342565cf0f5002400f53a95" category="cell">标注</block>
  <block id="1527fede1d561a899313c8cb3eb1e7bf" category="cell">卷选项</block>
  <block id="db8a0bbeae97b94338c1b7a61e2a1ec3" category="cell">支持的驱动程序</block>
  <block id="f3780100617165ed98557e3a6d2be72d" category="cell">trident.netapp.io/fileSystem</block>
  <block id="44d4d4eb1f08d8eb29766160086f61dd" category="cell">文件系统</block>
  <block id="59c54cb66816513690f886c6cbd45d7e" category="cell">ontap-san ， solidfire-san ， E 系列 -iscsi ， ontap-san-economy.</block>
  <block id="979f70bf9da982ee97ac075df4f048c3" category="cell">trident.netapp.io/cloneFromPVC</block>
  <block id="b4ead50a5ca4f307f7d61da7763ad204" category="cell">cloneSourceVolume</block>
  <block id="a056535de687a7e3ba370fa531941d0e" category="cell">ontap-nas ， ontap-san ， solidfire-san ， AWS-CVS ， azure-netapp-files ， GCP-CVS ， ontap-san-economy.</block>
  <block id="46ec89aa5290ead7b514dd5182caa0a7" category="cell">trident.netapp.io/splitOnClone</block>
  <block id="58c1c86186ef8de4f6e12d8f3aed8b64" category="cell">splitOnClone</block>
  <block id="80f05e749a4f524e8c8a05fa19d5df0e" category="cell">ontap-NAS ， ontap-san</block>
  <block id="d6f010e4b4bf9748dcaa34feb70188ce" category="cell">trident.netapp.io/protocol</block>
  <block id="81788ba0d7d02d81c063dbca621ba11b" category="cell">协议</block>
  <block id="100b8cad7cf2a56f6df78f171f97a1ec" category="cell">任意</block>
  <block id="e9898504ff0569325d48acaee7e9ced9" category="cell">trident.netapp.io/exportPolicy</block>
  <block id="647ce4e5394e2e595e46b4fc50a628e9" category="cell">导出策略</block>
  <block id="61396290e72fa7d707996351c8815bd6" category="cell">ontap-nas ， ontap-nas-economy-、 ontap-nas-flexgroup</block>
  <block id="2902d12b1fe6d9ef5bd1a3474f2356e9" category="cell">trident.netapp.io/snapshotPolicy</block>
  <block id="0a236e7685e50a59df980d0a30929d6c" category="cell">snapshotPolicy</block>
  <block id="7f3bf2672240703dc69740ce11443cf2" category="cell">ontap-nas ， ontap-nas-economy. ontap-nas-flexgroup ， ontap-san</block>
  <block id="6224177007fc13e9e0d3789985ed165a" category="cell">trident.netapp.io/snapshotReserve</block>
  <block id="bb0d75280f9b683f2f1f0767fd0aff9b" category="cell">SnapshotReserve</block>
  <block id="3419db347ff8e06397e8a611be353848" category="cell">ontap-nas ， ontap-nas-flexgroup ， ontap-san ， AWS-CVS ， GCP-CVS</block>
  <block id="1cb43054bed661d8c8457ddbb43e1b1b" category="cell">trident.netapp.io/snapshotDirectory</block>
  <block id="1ae33c448502ac3d326593aee304c21f" category="cell">snapshotDirectory</block>
  <block id="ec1739ebad429a70f25efc292c347f8e" category="cell">trident.netapp.io/unixPermissions</block>
  <block id="c005e78d4bd808038335c32dd84cf7da" category="cell">unixPermissions</block>
  <block id="69d900d222446aab8591b45a7363c9e7" category="cell">trident.netapp.io/blockSize</block>
  <block id="480d1b61a0432d1319f7504a3d7318dd" category="cell">块大小</block>
  <block id="c0d2a793e71b152662b3e8cd2da00620" category="cell">solidfire-san</block>
  <block id="fc5f8320f80474f09bdd1e3c3849123e" category="paragraph">如果创建的 PV 具有 `Delete` reclaime 策略，则在释放 PV 时（即用户删除 PVC 时）， Trident 会同时删除 PV 和后备卷。如果删除操作失败， Trident 会将 PV 标记为相应的 PV ，并定期重试此操作，直到操作成功或 PV 手动删除为止。如果 PV 使用 ` +retain+` 策略， Trident 会忽略该策略，并假定管理员将从 Kubernetes 和后端清理该策略，以便在删除卷之前对其进行备份或检查。请注意，删除 PV 不会通过发生原因 Trident 删除后备卷。您应使用 REST API （`tridentctl` ）将其删除。</block>
  <block id="5dad99bb31feaed11fecbe29cf682e51" category="paragraph">Trident 支持使用 CSI 规范创建卷快照：您可以创建卷快照并将其用作数据源来克隆现有 PVC 。这样， PV 的时间点副本就可以以快照的形式公开给 Kubernetes 。然后，可以使用快照创建新的 PV 。请查看 ` + 按需卷快照 +` 了解其工作原理。</block>
  <block id="2553df6c9f03b727070656d38019ad3e" category="paragraph">Trident 还提供了用于创建克隆的 `cloneFromPVC` 和 `splitOnClone` 标注。您可以使用这些标注克隆 PVC ，而无需使用 CSI 实施（在 Kubernetes 1.13 及更早版本上），或者您的 Kubernetes 版本不支持测试版卷快照（ Kubernetes 1.16 及更早版本）。请注意， Trident 19.10 支持从 PVC 克隆的 CSI 工作流。</block>
  <block id="91adc865e5be78d779fd6aa38481ca58" category="admonition">您可以将 `cloneFromPVC` 和 `splitOnClone` 标注与 CSI Trident 以及传统的非 CSI 前端结合使用。</block>
  <block id="96e0288ecc3c91f97de46420e70a4f8f" category="paragraph">例如：如果用户已经有一个名为 `mysql` 的 PVC ，则用户可以使用标注创建一个名为 `mysqlclone` 的新 PVC ，例如 `trident.netapp.io/cloneFromPVC: mysql` 。设置了此标注后， Trident 将克隆与 mysql PVC 对应的卷，而不是从头开始配置卷。</block>
  <block id="ff0fa770e22db25a156c5e2d7f017283" category="paragraph">请考虑以下几点：</block>
  <block id="5faae6e509c8aecf9f8815a4ceef02b3" category="list-text">建议克隆空闲卷。</block>
  <block id="f89d76e06e88814705882a1faad838fb" category="list-text">一个 PVC 及其克隆应位于同一个 Kubernetes 命名空间中，并具有相同的存储类。</block>
  <block id="f769a6b54b1d1476b6628ebd1c4b98c4" category="list-text">使用 `ontap-nas` 和 `ontap-san` 驱动程序时，可能需要将 PVC 标注 `trident.netapp.io/splitOnClone` 与 `trident.netapp.io/cloneFromPVC` 结合使用。当 `trident.netapp.io/splitOnClone` 设置为 `true` 时， Trident 会将克隆的卷与父卷拆分，从而将克隆的卷与其父卷的生命周期完全分离，从而降低存储效率。如果不设置 `trident.netapp.io/splitOnClone` 或将其设置为 `false` ，则会减少后端的空间占用，而会在父卷和克隆卷之间创建依赖关系，因此除非先删除克隆，否则无法删除父卷。拆分克隆是有意义的一种情形，即克隆空数据库卷时，该卷及其克隆会发生很大的差异，无法从 ONTAP 提供的存储效率中受益。</block>
  <block id="83a9930ebb180c904bf2e71e27928287" category="paragraph">`sample-input` 目录包含用于 Trident 的 PVC 定义示例。有关与 Trident 卷关联的参数和设置的完整问题描述，请参见 Trident 卷对象。</block>
  <block id="a02475a5207a446cd0b3607b0b24c079" category="section-title">Kubernetes PersistentVolume 对象</block>
  <block id="6cb5412cc2fe8210c4d14d6d6b08ab79" category="paragraph">Kubernetes `PersistentVolume` 对象表示可供 Kubernetes 集群使用的一段存储。它的生命周期与使用它的 POD 无关。</block>
  <block id="292289b7334983e53d9fb9bd00d30820" category="admonition">Trident 会创建 `PersistentVolume` 对象，并根据其配置的卷自动将其注册到 Kubernetes 集群中。您不应自行管理它们。</block>
  <block id="443f09ca4d0d1cc13b5baa064b90c0b7" category="paragraph">创建引用基于 Trident 的 `S存储类` 的 PVC 时， Trident 会使用相应的存储类配置新卷并为该卷注册新的 PV 。在配置已配置的卷和相应的 PV 时， Trident 会遵循以下规则：</block>
  <block id="b27c91fe87605abbb0d5240430518a1c" category="list-text">Trident 会为 Kubernetes 生成 PV 名称及其用于配置存储的内部名称。在这两种情况下，它都可以确保名称在其范围内是唯一的。</block>
  <block id="9c2f88a5c4297bd88ead0cd6314fe886" category="list-text">卷的大小与 PVC 中请求的大小尽可能匹配，但可能会根据平台将其取整为最接近的可分配数量。</block>
  <block id="dcbd1c3ef9cd1dce444a22a9db5994d6" category="section-title">Kubernetes StorageClass 对象</block>
  <block id="0d35625a483152791f4e2d0b751a09cc" category="paragraph">Kubernetes `StorageClass` 对象在 `PersistentVolumeClass` 中按名称指定，用于使用一组属性配置存储。存储类本身可标识要使用的配置程序，并按配置程序所了解的术语定义该属性集。</block>
  <block id="f7738d717849274e5992d460fd2c0a75" category="paragraph">它是需要由管理员创建和管理的两个基本对象之一。另一个是 Trident 后端对象。</block>
  <block id="e51377a773f4713e536b061eaa2d4b04" category="paragraph">使用 Trident 的 Kubernetes `StorageClass` 对象如下所示：</block>
  <block id="39edc8618b50008d4cb2050414d6921f" category="paragraph">这些参数是 Trident 专用的，可告诉 Trident 如何为类配置卷。</block>
  <block id="b16da8ed7f6c8cce3011dc2b6c7bd1a4" category="paragraph">存储类参数包括：</block>
  <block id="f2bbdf9f72c085adc4d0404e370f0f4c" category="cell">属性</block>
  <block id="a1fa27779242b4902f7ae3bdd5c6d508" category="cell">Type</block>
  <block id="b651efdb98a5d6bd2b3935d0c3f4a5e2" category="cell">Required</block>
  <block id="b5a7adde1af5c87d7fd797b6245c2a39" category="cell">Description</block>
  <block id="736b91750e516139acc13c5eb6564f92" category="cell">属性</block>
  <block id="59a1e7292a0114529fb1b3401b37bc28" category="cell">map[string]string</block>
  <block id="7fa3b767c460b54a2be4d49030b349c7" category="cell">否</block>
  <block id="1b40216e6fe613bd013bf8710182e650" category="cell">请参见下面的属性部分</block>
  <block id="c614017642b6cfd9e6a25c7df122d917" category="cell">存储池</block>
  <block id="b8f32852327d2ffce86ae3ead4fdfb52" category="cell">map[string]StringList</block>
  <block id="bdd0ddb870ed9de6f6e7d3a75200e9f7" category="cell">后端名称映射到中的存储池列表</block>
  <block id="145d1b89a9f9ed8bdc16d1f7a814cace" category="cell">附加 StoragePools</block>
  <block id="6907a73ad9068ddf5f99d022102220bb" category="cell">后端名称映射到中的存储池列表</block>
  <block id="7df974d787ead594df017a11672f2f0e" category="cell">排除 StoragePools</block>
  <block id="99ba77776c83983f5ecbd2b51f2b43ef" category="cell">后端名称映射到中的存储池列表</block>
  <block id="f74d4b2b456fb453c0980710290f66eb" category="paragraph">存储属性及其可能值可以分类为存储池选择属性和 Kubernetes 属性。</block>
  <block id="2fdf10f3f64b631cd3a137740de02f8b" category="section-title">存储池选择属性</block>
  <block id="1f5912cd581dba393d5eecc43059adf4" category="paragraph">这些参数决定了应使用哪些 Trident 管理的存储池来配置给定类型的卷。</block>
  <block id="c82a6100dace2b41087ba6cf99a5976a" category="cell">值</block>
  <block id="6bb24468956384c482a8b5a901fb6383" category="cell">优惠</block>
  <block id="15c2d85f1fae22a3c3a0594510a1f611" category="cell">请求</block>
  <block id="7aa57840938d59b415c1e10dcd1f7173" category="cell">支持</block>
  <block id="0e72be2e13bf8a2ff8078d3435e5aa7c" category="cell">介质^1^</block>
  <block id="b45cffe084dd3d20d928bee85e7b0f21" category="cell">string</block>
  <block id="9ccd7f94313a98beb95801927907a0ab" category="cell">HDD ，混合， SSD</block>
  <block id="9bf3032f6854fb376cd8e3e92e11b077" category="cell">Pool 包含此类型的介质；混合表示两者</block>
  <block id="5c79c761bae4c27e96c04e54d1da1e91" category="cell">指定的介质类型</block>
  <block id="c9cb5e737e2746339fd0b462332c8740" category="cell">ontap-nas ， ontap-nas-economy. ontap-nas-flexgroup ， ontap-san ， solidfire-san</block>
  <block id="b713baf75bcf13859037b5274d27d4b8" category="cell">配置类型</block>
  <block id="6026fbd9abd05590949de220154e3262" category="cell">精简，厚</block>
  <block id="3064025fe3541bec9942e14fcaedfab7" category="cell">Pool 支持此配置方法</block>
  <block id="cf65591e3da90317fc132ea7464105d8" category="cell">指定的配置方法</block>
  <block id="ef2577df8468ab39e993a1938ba7f38d" category="cell">厚：全 ONTAP 和 E 系列 iSCSI ；精简：全 ONTAP 和 solidfire-san</block>
  <block id="55b56fb238360663afa6230ad82e74a0" category="cell">后端类型</block>
  <block id="d41d8cd98f00b204e9800998ecf8427e" category="doc"></block>
  <block id="9d7b1f44c2f9de09e74ed8f6104c3f16" category="paragraph">ontap-nas ， ontap-nas-economy. ontap-nas-flexgroup ， ontap-san ， solidfire-san ， E 系列 iSCSI ， AWS-CVS ， GCP-CVS ， azure-netapp-files ， ontap-san-economy.</block>
  <block id="0e1201d4d96df2d9d03c9c66b90874a1" category="cell">池属于此类型的后端</block>
  <block id="c4efe19137f43450149d48fddbab6c28" category="cell">指定后端</block>
  <block id="a04622349b3ede0d4176ca2c2e161763" category="cell">所有驱动程序</block>
  <block id="695633290d050f31cec0c9d4bd4a57fe" category="cell">snapshots</block>
  <block id="c506ff134babdd6e68ab3e6350e95305" category="cell">池</block>
  <block id="ac1ffb15effdc77a86029972670d022f" category="cell">true false</block>
  <block id="4ac43bef181074fbd4a1f3620b46f77f" category="cell">Pool 支持具有快照的卷</block>
  <block id="13410bff9f7871113a6af273e2a1b97f" category="cell">启用了快照的卷</block>
  <block id="b43a2204ed324763abdbca5be0c35b02" category="cell">ontap-NAS ， ontap-san ， solidfire-san ， AWS-CVS ， GCP-CVS</block>
  <block id="bc3832c405ec6cb9c831849328240f3b" category="cell">克隆</block>
  <block id="609d32aa243917905f282544b543752a" category="cell">Pool 支持克隆卷</block>
  <block id="bcb81802de31cf9c717de3c1d6c2f610" category="cell">启用了克隆的卷</block>
  <block id="5bdf74912a51c34815f11e9a3d20b609" category="cell">加密</block>
  <block id="5f2f2cc138a8bc7067c7f61ab4db0f4d" category="cell">池支持加密卷</block>
  <block id="0bda31a93b84fd2b45a90df39c4c8049" category="cell">已启用加密的卷</block>
  <block id="dcc09b4a72e31323b652676ce4677771" category="cell">ontap-nas ， ontap-nas-economy-、 ontap-nas-flexgroups ， ontap-san</block>
  <block id="79073619fba8242703524f16870ff858" category="cell">IOPS</block>
  <block id="fa7153f7ed1cb6c0fcf2ffb2fac21748" category="cell">内部</block>
  <block id="86e5d65893929e5d38b4bdcb9fb48ecd" category="cell">正整数</block>
  <block id="bf57d1db8292b2855fa998a86562cfa7" category="cell">Pool 能够保证此范围内的 IOPS</block>
  <block id="342a7ce5bb7debc6ba84dc2a3bced587" category="cell">卷保证这些 IOPS</block>
  <block id="895f3d78c77292d9761bdabdc3cf0c99" category="paragraph">^1^ ： ONTAP Select 系统不支持</block>
  <block id="5b3c68bde0b3658758a8ebf47ec6abf1" category="paragraph">在大多数情况下，请求的值直接影响配置；例如，请求厚配置会导致卷配置较厚。但是， Element 存储池会使用其提供的 IOPS 最小值和最大值来设置 QoS 值，而不是请求的值。在这种情况下，请求的值仅用于选择存储池。</block>
  <block id="311fa7e17587a62a6fdcb110253feed7" category="paragraph">理想情况下，您可以单独使用 `attributes` 来为满足特定类需求所需的存储质量建模。Trident 会自动发现并选择与您指定的 `属性` 的 _all_ 匹配的存储池。</block>
  <block id="d0c865b74e0c4b4b387506e9e95d22b2" category="paragraph">如果您发现自己无法使用 `attributes` 自动为某个类选择合适的池，则可以使用 `storagePools` 和 `addtionalStoragePools` 参数进一步细化池，甚至可以选择一组特定的池。</block>
  <block id="06a87a25fa98442cf561762851213f7e" category="paragraph">您可以使用 `storagePools` 参数进一步限制与任何指定的 `attributes` 匹配的池集。换言之， Trident 会使用 `attributes` 和 `storagePools` 参数标识的池的交叉点进行配置。您可以单独使用参数，也可以同时使用这两者。</block>
  <block id="0c66a737e57eb6ac0885d2ba6d87cc12" category="paragraph">您可以使用 `addtionalStoragePools` 参数扩展 Trident 用于配置的池集，而不管 `attributes` 和 `storagePools` 参数选择的任何池如何。</block>
  <block id="2ed95c63c6e58641d710e098e7e23154" category="paragraph">您可以使用 `excludeStoragePools` 参数筛选 Trident 用于配置的池集。使用此参数将删除任何匹配的池。</block>
  <block id="9f8bfd75f7eb5b95503bb0abedf83b40" category="paragraph">在 `storagePools` 和 `addtionalStoragePools` 参数中，每个条目的格式为 ` &lt;backend&gt;： &lt;storagePoolList&gt;` ，其中 ` &lt;storagePoolList&gt;` 是指定后端的存储池列表，以逗号分隔。例如， `addtionalStoragePools` 的值可能类似于 `ontapnas_192.168.1.100 ： aggr1 ， aggr2 ； solidfire_192.168.1.101 ： bronze` 。这些列表接受后端值和列表值的正则表达式值。您可以使用 `tridentctl get backend` 来获取后端及其池的列表。</block>
  <block id="c087dddd46fcf0fbbf390abeff2216c3" category="section-title">Kubernetes 属性</block>
  <block id="d05956159ee82aafaaacfe08d33d3be6" category="paragraph">这些属性不会影响 Trident 在动态配置期间选择的存储池 / 后端。相反，这些属性仅提供 Kubernetes 永久性卷支持的参数。工作节点负责文件系统创建操作，并且可能需要文件系统实用程序，例如 xfsprogs 。</block>
  <block id="0e6ac0d7fca9c59e6545312a071555b6" category="cell">相关驱动程序</block>
  <block id="ae6b2a160dd2fafdee385c348edee0c1" category="cell">Kubernetes 版本</block>
  <block id="7cfbb6f07899c8071ff38e69dca190e2" category="cell">FSType</block>
  <block id="64b6d80cc167d5c657b60054dbe396ee" category="cell">ext4 ， ext3 ， xfs 等</block>
  <block id="7928a56d4874d982a06a59e3f30f6935" category="cell">块卷的文件系统类型</block>
  <block id="b74b022e90a67722f5de8016a0e5578c" category="cell">solidfire-san ， ontap-san ， ontap-san-economy.</block>
  <block id="b1c94ca2fbc3e78fc30069c8d0f01680" category="cell">全部</block>
  <block id="2435c5eb0d842c13f635d4b1d6667a52" category="paragraph">Trident 安装程序包提供了几个示例存储类定义，可用于 ``sample-input/storage-class-* 。 yaml`` 中的 Trident 。删除 Kubernetes 存储类也会删除相应的 Trident 存储类。</block>
  <block id="6b218cef3794c1b32702bd37753ce9ef" category="section-title">Kubernetes VolumeSnapshotClass 对象</block>
  <block id="65d18b5db5d5f35e4ddc5c696687d1bd" category="paragraph">Kubernetes `VolumeSnapshotClass` 对象类似于 `StorageClasses` 。它们有助于定义多个存储类，并由卷快照引用以将快照与所需的快照类关联。每个卷快照都与一个卷快照类相关联。</block>
  <block id="031e09713b698739db52cb150ef97605" category="paragraph">要创建快照，管理员应定义 `VolumeSnapshotClass` 。此时将使用以下定义创建卷快照类：</block>
  <block id="879cd061c6bf448cd6fc39dd56947611" category="paragraph">`driver` 指定给 Kubernetes ，由 Trident 处理对 `csI-snapclass` 类的卷快照请求。`deeltionPolicy` 指定必须删除快照时要执行的操作。如果将 `deletionPolicy` 设置为 `Delete` ，则在删除快照时，卷快照对象以及存储集群上的底层快照将被删除。或者，如果将其设置为 `Retain` ，则表示保留 `VolumeSnapshotContent` 和物理快照。</block>
  <block id="4fa3f62cc9d9b7064a0d4b93d16a3636" category="section-title">Kubernetes VolumeSnapshot 对象</block>
  <block id="7ba558df52a052235cf288011e5d667c" category="paragraph">Kubernetes `VolumeSnapshot` 对象是创建卷快照的请求。就像 PVC 代表用户对卷发出的请求一样，卷快照也是用户为现有 PVC 创建快照的请求。</block>
  <block id="f67af493d1fd83b472d5f27307b2f3d9" category="paragraph">收到卷快照请求后， Trident 会自动管理在后端为卷创建快照的操作，并通过创建唯一的 `VolumeSnapshotContent` 对象公开快照。您可以从现有 PVC 创建快照，并在创建新 PVC 时将这些快照用作 DataSource 。</block>
  <block id="53847015682974d066a919b1b45a44a5" category="admonition">VolumeSnapshot 的生命周期与源 PVC 无关：即使删除了源 PVC ，快照也会持续存在。删除具有关联快照的 PVC 时， Trident 会将此 PVC 的后备卷标记为 " 正在删除 " 状态，但不会将其完全删除。删除所有关联快照后，卷将被删除。</block>
  <block id="c1c597a8c6353c0a951a61e538d2f143" category="section-title">Kubernetes VolumeSnapshotContent 对象</block>
  <block id="e562bdcf97dce6973a736651f45eb054" category="paragraph">Kubernetes `VolumeSnapshotContent` 对象表示从已配置的卷创建的快照。它类似于 `PersistentVolume` ，表示存储集群上配置的快照。与 `PersistentVolumeClaim` 和 `PersistentVolume` 对象类似，创建快照时， `VolumeSnapshotContent` 对象会与请求创建快照的 `VolumeSnapshot` 对象保持一对一映射。</block>
  <block id="ca8035550d447392debfcaeb62855bd3" category="admonition">Trident 会创建 `VolumeSnapshotContent` 对象，并根据其配置的卷自动将其注册到 Kubernetes 集群中。您不应自行管理它们。</block>
  <block id="af741aec1c66e51c00d35a38f92471de" category="paragraph">`VolumeSnapshotContent` 对象包含用于唯一标识快照的详细信息，例如 `snapshotHandle` 。此 `snapshotHandle` 是 PV 名称和 `VolumeSnapshotContent` 对象名称的唯一组合。</block>
  <block id="b22c73e808eef321ee9941ec2e58b64f" category="paragraph">收到快照请求后， Trident 会在后端创建快照。创建快照后， Trident 会配置一个 `VolumeSnapshotContent` 对象，从而将快照公开到 Kubernetes API 。</block>
  <block id="ca106d43cc3f2b8c6ae43c99a3c529d7" category="section-title">Kubernetes CustomResourceDefinition 对象</block>
  <block id="7c43d52062b795d2d8e7f33b9dbbf671" category="paragraph">Kubernetes 自定义资源是 Kubernetes API 中的端点，由管理员定义并用于对类似对象进行分组。Kubernetes 支持创建自定义资源以存储对象集合。您可以通过运行 `kubectl get crds` 来获取这些资源定义。</block>
  <block id="09d4c17e4e0e002375326eee41d0f77f" category="paragraph">自定义资源定义（ CRD ）及其关联的对象元数据由 Kubernetes 存储在其元数据存储中。这样就无需为 Trident 创建单独的存储。</block>
  <block id="798d49964270b9d2f638171af7258d00" category="paragraph">从 19.07 版开始， Trident 会使用许多 `CustomResourceDefinition` 对象来保留 Trident 对象的身份，例如 Trident 后端， Trident 存储类和 Trident 卷。这些对象由 Trident 管理。此外， CSI 卷快照框架还引入了一些定义卷快照所需的 CRD 。</block>
  <block id="9f59afd5e4687b9960361128f049dae4" category="paragraph">CRD 是一种 Kubernetes 构造。上述资源的对象由 Trident 创建。例如，使用 `tridentctl` 创建后端时，会创建一个对应的 `tridentbackend` CRD 对象，供 Kubernetes 使用。</block>
  <block id="7cdfd680fe492e028cde251c38475469" category="paragraph">有关 Trident 的 CRD ，请注意以下几点：</block>
  <block id="adecfe476427253e9c680a7c5150a9cc" category="list-text">安装 Trident 时，系统会创建一组 CRD ，并可像使用任何其他资源类型一样使用。</block>
  <block id="b54c0b51e5e24cea2035a3e3624c5719" category="list-text">从先前版本的 Trident （使用 `etcd` 保持状态的版本）升级时， Trident 安装程序会从 `etcd` key-value 数据存储库迁移数据并创建相应的 CRD 对象。</block>
  <block id="c4b35352cbf7a52a9444a610687067f8" category="inline-link-macro">卸载 Trident</block>
  <block id="14beb70da78e5a36efe980226d286a53" category="list-text">使用 `tridentctl uninstall` 命令卸载 Trident 时， Trident Pod 会被删除，但不会清理创建的 CRD 。请参见 <block ref="91f30c1df5df3b507b6d93916b3fade3" category="inline-link-macro-rx"></block> 了解如何从头开始完全删除和重新配置 Trident 。</block>
  <block id="514e780152cf1b5087027f7c70643070" category="section-title">Trident StorageClass 对象</block>
  <block id="193c267230acf55be171a6a179560847" category="paragraph">Trident 会为 Kubernetes `StorageClass` 在其配置程序字段中指定 `csi.trident.netapp.io`/`netapp.io/trident` 的对象创建匹配的存储类。存储类名称与 Kubernetes `StorageClass` 其所代表的对象的名称匹配。</block>
  <block id="64cf33bfeab6c6bd8aa626b86fda9cbd" category="admonition">使用 Kubernetes 时，如果注册了使用 Trident 作为配置程序的 Kubernetes `StorageClass` ，则会自动创建这些对象。</block>
  <block id="51fa0a833f47d8f00ee2677c6fa7b075" category="paragraph">存储类包含一组卷要求。Trident 会将这些要求与每个存储池中的属性进行匹配；如果匹配，则该存储池是使用该存储类配置卷的有效目标。</block>
  <block id="04d84bba5a5e103ae9c192c03a7ad2f3" category="paragraph">您可以使用 REST API 创建存储类配置以直接定义存储类。但是，对于 Kubernetes 部署，我们希望在注册新的 Kubernetes `StorageClass` 对象时创建这些部署。</block>
  <block id="21283df20640a21f468122a427ef1bfc" category="section-title">Trident 后端对象</block>
  <block id="3c244b984a2188556c1115a5a27dbe1b" category="paragraph">后端表示存储提供程序，其中 Trident 配置卷；单个 Trident 实例可以管理任意数量的后端。</block>
  <block id="d71c5fad4769c19422c07158e24510ba" category="admonition">这是您自己创建和管理的两种对象类型之一。另一个是 Kubernetes `StorageClass` 对象。</block>
  <block id="6e8c08b737e50e4dc89c4bd33b8ea726" category="paragraph">有关如何构建这些对象的详细信息，请参见后端配置。</block>
  <block id="af5e532a14b6a8c1f094b8532420e8d1" category="section-title">Trident StoragePool 对象</block>
  <block id="54fd1dc39c3eecd913b4c9140522996c" category="paragraph">存储池表示可在每个后端配置的不同位置。对于 ONTAP ，这些聚合对应于 SVM 中的聚合。对于 NetApp HCI/SolidFire ，这些 QoS 分段对应于管理员指定的 QoS 分段。对于 Cloud Volumes Service ，这些区域对应于云提供商区域。每个存储池都有一组不同的存储属性，用于定义其性能特征和数据保护特征。</block>
  <block id="4ab1440e71a70a97c4966bcc0095f02b" category="paragraph">与此处的其他对象不同，存储池候选对象始终会自动发现和管理。</block>
  <block id="d2a63f6dfdfef268198f3e6e304ab9ba" category="section-title">Trident Volume 对象</block>
  <block id="894765102686902c6acc3024e5bdb9bd" category="paragraph">卷是基本配置单元，由后端端点组成，例如 NFS 共享和 iSCSI LUN 。在 Kubernetes 中，这些卷直接对应于 `PersistentVolumes` 。创建卷时，请确保其具有存储类，此类可确定可配置该卷的位置以及大小。</block>
  <block id="2e53db54827c8c05b7bfe9cb31f299d9" category="admonition">在 Kubernetes 中，这些对象会自动进行管理。您可以查看它们以查看 Trident 配置的内容。</block>
  <block id="22fcc98910d0241e9835f502b7cb2398" category="admonition">删除具有关联快照的 PV 时，相应的 Trident 卷将更新为 * 正在删除 * 状态。要删除 Trident 卷，您应删除该卷的快照。</block>
  <block id="05353bc86910df31b2da9c8d3d26aad1" category="paragraph">卷配置定义了配置的卷应具有的属性。</block>
  <block id="ce9af1e3f0493eb7d5ffdf584ed763ba" category="cell">Trident API 版本（ "1" ）</block>
  <block id="b068931cc450442b63f5b3d276ea4297" category="cell">name</block>
  <block id="a6105c0a611b41b08f1209506350279e" category="cell">是的。</block>
  <block id="017dbd2b0a2195c3e8052cdff67bad39" category="cell">要创建的卷的名称</block>
  <block id="78ec9b60245b46a4f05158076962ace9" category="cell">存储类</block>
  <block id="fa00f346deccdbebef2b3cc0702d41de" category="cell">配置卷时要使用的存储类</block>
  <block id="f7bd60b75b29d79b660a2859395c1a24" category="cell">size</block>
  <block id="264c52ca068dfed30f5826bb054839f4" category="cell">要配置的卷大小（以字节为单位）</block>
  <block id="4f18882934f0472b4bfa32928bf92f14" category="cell">要使用的协议类型； "file" 或 "block"</block>
  <block id="252c6d364cc1a0437939a4f01b0717ae" category="cell">内部名称</block>
  <block id="2857a43e58983276d059c0e6e2fcb0e9" category="cell">存储系统上的对象名称；由 Trident 生成</block>
  <block id="ff4630d4b2307b42398211e68c0c3996" category="cell">ONTAP （ NAS ， SAN ） &amp; SolidFire AWS-* 和 AWS-CVS* ：要从中克隆的卷的名称</block>
  <block id="e94d46d7c89bcb7e6ac2e2df4d21bafb" category="cell">ONTAP （ NAS ， SAN ）：将克隆从其父级拆分</block>
  <block id="819549a86d14e849e1d0042c9156d781" category="cell">Snapshot-* ：要使用的 ONTAP 策略</block>
  <block id="e38882545bfedafc7e8ec5973b2e6dd8" category="cell">Snapshot-* ：为快照预留的卷百分比 ONTAP</block>
  <block id="fc86db1233bfa77d5143dcaae9842cb1" category="cell">ontap-nas* ：要使用的导出策略</block>
  <block id="48e1d8180a61943f438c259b2b6715f8" category="cell">ontap-nas* ：是否显示快照目录</block>
  <block id="3f7c94eec4bbf43962e1667f5a334469" category="cell">ontap-nas* ：初始 UNIX 权限</block>
  <block id="4b2d5d83aef608a3fb59ec6eda8bea26" category="cell">SolidFire — * ：块 / 扇区大小</block>
  <block id="62fe71ae4f6a04a6937feb48ba5dc4f4" category="cell">文件系统类型</block>
  <block id="44be9d1a43b6ec865a2264e42c53de2d" category="paragraph">创建卷时， Trident 会生成 `internalName` 。这包括两个步骤。首先，它会将存储前缀（默认值 `trident` 或后端配置中的前缀）预先添加到卷名称中，从而使名称格式为 ` &lt;prefix&gt;-&lt;volume-name&gt;` 。然后，它将继续清理名称，替换后端不允许使用的字符。对于 ONTAP 后端，它会将连字符替换为下划线（因此，内部名称将变为 ` &lt;prefix&gt;_&lt;volume-name&gt;` ）。对于 Element 后端，它会将下划线替换为连字符。对于对所有对象名称施加 30 个字符限制的 E 系列， Trident 会为每个卷的内部名称生成随机字符串。对于对唯一卷创建令牌实施 16 到 36 个字符限制的 CVS （ AWS ）， Trident 会为每个卷的内部名称生成一个随机字符串。</block>
  <block id="49539689cebb34166a417b3b666818e5" category="paragraph">您可以使用卷配置使用 REST API 直接配置卷，但在 Kubernetes 部署中，我们希望大多数用户使用标准的 Kubernetes `PersistentVolumeClaim` 方法。Trident 会在配置过程中自动创建此卷对象。</block>
  <block id="cbd341b63adaa47fcb248e55d33f6eae" category="section-title">Trident Snapshot 对象</block>
  <block id="a1b3787bbd275b7ed5812d022dd36932" category="paragraph">快照是卷的时间点副本，可用于配置新卷或还原状态。在 Kubernetes 中，这些对象直接对应于 `VolumeSnapshotContent` 对象。每个快照都与一个卷相关联，该卷是快照的数据源。</block>
  <block id="cdf5c8d3dd31e49b82a5b3e2c4a65280" category="paragraph">每个 `Snapshot` 对象包括以下属性：</block>
  <block id="27118326006d3829667a400ad23d5d98" category="cell">string</block>
  <block id="93cba07454f06a4a960172bbd6e2a435" category="paragraph">是的。</block>
  <block id="de73fbae2864dd61c921cf0648a9717a" category="cell">Trident Snapshot 对象的名称</block>
  <block id="8e744456fb3d02d69442038d3e771460" category="cell">存储系统上 Trident Snapshot 对象的名称</block>
  <block id="617a43eb0446f84414df73cce2997fa1" category="cell">volumeName</block>
  <block id="b58c8ff1e837af6dafa971bf3d320646" category="cell">为其创建快照的永久性卷的名称</block>
  <block id="2c2aed4b417a0f9c189d7ad6414ae28c" category="cell">volumeInternalName</block>
  <block id="db1a117103c348ebaec41f9e249554c3" category="cell">存储系统上关联的 Trident 卷对象的名称</block>
  <block id="73f3d5934fdd36989f24cbae94ab423b" category="paragraph">创建 Kubernetes `VolumeSnapshot` 对象请求时， Trident 会在备用存储系统上创建 Snapshot 对象。此快照对象的 `internalName` 是通过将前缀 `snapshot-` 与 `VolumeSnapshot` 对象的 `UID` （例如， `snapshot-e8d8a0ca-9826-11e9-9807-525400f3f660` ）组合而生成的。`VolumeName` 和 `volumeInternalName` 可通过获取后备卷的详细信息来填充。</block>
  <block id="e977c869b42c54e3c7d8fb9c071aab2b" category="summary">详细了解 Astra Trident 所通过的端口。</block>
  <block id="b229055f6bd047c28dfc84c9bee4c252" category="doc">Astra Trident 端口</block>
  <block id="219abf04d1bb79760c15ca6966b68fb3" category="paragraph">Astra Trident 通过以下端口进行通信：</block>
  <block id="60aaf44d4b562252c04db7f98497e9aa" category="cell">Port</block>
  <block id="261addf78c7b2c961032b3dd08ba0b1f" category="cell">目的</block>
  <block id="7e6b20d014d1c659e4eaf20dc2dcd7eb" category="cell">8443</block>
  <block id="69bbf3571db03f0487c04a8254d15c75" category="cell">后通道 HTTPS</block>
  <block id="bc3c4a6331a8a9950945a1aa8c95ab8a" category="cell">8001</block>
  <block id="e5a4c481cc6f5935efb2c9d381f2e342" category="cell">Prometheus 指标端点</block>
  <block id="67ff32d40fb51f1a2fd2c4f1b1019785" category="cell">8000</block>
  <block id="10f5b805a46ea829cc3b9d8560a224ae" category="cell">Trident REST 服务器</block>
  <block id="35cf0f704286108deb76366a16415140" category="cell">17546</block>
  <block id="fb1396f82d0096741ea1b06f8cee2340" category="cell">Trident demonset Pod 使用的活动性 / 就绪性探测端口</block>
  <block id="b9c469bd571fac8818d4000055d327df" category="admonition">可以在安装期间使用 ` -probe-port` 标志更改活跃度 / 就绪性探测端口。请务必确保此端口未被工作节点上的其他进程使用。</block>
  <block id="d59b86d1714966230da7a00672e40912" category="summary">使用此处列出的建议确保您的 Astra Trident 安装安全。</block>
  <block id="2fae32629d4ef4fc6341f1751b405e45" category="doc">安全性</block>
  <block id="44a736677691eaca5e5d3d6b5c770b22" category="section-title">在自己的命名空间中运行 Astra Trident</block>
  <block id="347d4c35796a862cf20cdcdebfe59e57" category="paragraph">请务必防止应用程序，应用程序管理员，用户和管理应用程序访问 Astra Trident 对象定义或 Pod ，以确保存储可靠并阻止潜在的恶意活动。</block>
  <block id="47d7f9fac441e60d9523d256d02aa8ba" category="paragraph">要将其他应用程序和用户与 Astra Trident 分开，请始终在自己的 Kubernetes 命名空间（`trident` ）中安装 Astra Trident 。将 Astra Trident 置于自己的命名空间中可确保只有 Kubernetes 管理人员才能访问 Astra Trident Pod 以及存储在命名空间 CRD 对象中的项目（如适用，还包括后端和 CHAP 密码）。您应确保仅允许管理员访问 Astra Trident 命名空间，从而访问 `tridentctl` 应用程序。</block>
  <block id="f40aef657c875e42158050f63dcfbb6f" category="section-title">对 ONTAP SAN 后端使用 CHAP 身份验证</block>
  <block id="2738c60dc60977d9eb6af2bf2a98c193" category="paragraph">Astra Trident 支持对 ONTAP SAN 工作负载进行基于 CHAP 的身份验证（使用 `ontap-san` 和 `ontap-san-economy.` 驱动程序）。NetApp 建议将双向 CHAP 与 Astra Trident 结合使用，以便在主机和存储后端之间进行身份验证。</block>
  <block id="6c92285fa6d3e827b198d120ea3ac674" category="inline-link-macro">此处</block>
  <block id="c34904efabe33827baaa88ebf031ffab" category="paragraph">对于使用 SAN 存储驱动程序的 ONTAP 后端， Astra Trident 可以通过 `tridentctl` 设置双向 CHAP 并管理 CHAP 用户名和密码。请参见 <block ref="eda040c33c51e3cee067cf2f06789687" category="inline-link-macro-rx"></block> 了解 Astra Trident 如何在 ONTAP 后端配置 CHAP 。</block>
  <block id="97f83fd51c89f4f9d3fc271b9f7291ab" category="admonition">Trident 20.04 及更高版本支持 ONTAP 后端的 CHAP 。</block>
  <block id="d4e0ad8fd8e11d87eb431051692db344" category="section-title">对 NetApp HCI 和 SolidFire 后端使用 CHAP 身份验证</block>
  <block id="b6a8ac29724d88dfaec657edda424d98" category="paragraph">NetApp 建议部署双向 CHAP ，以确保主机与 NetApp HCI 和 SolidFire 后端之间的身份验证。Astra Trident 使用一个机密对象，每个租户包含两个 CHAP 密码。当 Trident 作为 CSI 配置程序安装时，它会管理 CHAP 密码并将其存储在相应 PV 的 `tridentvolume` CR 对象中。创建 PV 时， CSI Astra Trident 会使用 CHAP 密码启动 iSCSI 会话并通过 CHAP 与 NetApp HCI 和 SolidFire 系统进行通信。</block>
  <block id="19cde2e69238c98382d677e2583cbc46" category="admonition">CSI Trident 创建的卷不与任何卷访问组关联。</block>
  <block id="3179d8563cd49690a141c34c045dfab8" category="paragraph">在非 CSI 前端中，作为辅助节点上的设备连接卷的操作由 Kubernetes 处理。创建卷后，如果该租户的密钥尚不存在，则 Astra Trident 会对 NetApp HCI/SolidFire 系统进行 API 调用，以检索这些密钥。然后， Astra Trident 将这些机密传递给 Kubernetes 。位于每个节点上的 kubelet 通过 Kubernetes API 访问这些机密，并使用它们在访问卷的每个节点与卷所在的 NetApp HCI/SolidFire 系统之间运行 / 启用 CHAP 。</block>
  <block id="75f3d382f074f14c775efb5cf2f23c30" category="summary">在部署 Astra Trident 时，请使用此处列出的建议。</block>
  <block id="ea355214fd4bc7c57f471bd92918879b" category="doc">部署</block>
  <block id="d89d3b3161292ef0c65342cbe80e883f" category="section-title">部署到专用命名空间</block>
  <block id="13d28e8dfc702e3456e0767dff9a128a" category="inline-link">命名空间</block>
  <block id="79a77cdda2a2513aee654190c73f15ab" category="paragraph"><block ref="c41296e544cd0faaa4fe4e8b22535287" category="inline-link-rx"></block> 在不同应用程序之间实现管理隔离，是资源共享的障碍。例如，一个命名空间中的 PVC 不能从另一个命名空间中使用。Astra Trident 为 Kubernetes 集群中的所有命名空间提供 PV 资源，从而利用具有提升权限的服务帐户。</block>
  <block id="853cf568613b7eec1486421468e18b9b" category="paragraph">此外，访问 Trident POD 可能会使用户能够访问存储系统凭据和其他敏感信息。请务必确保应用程序用户和管理应用程序无法访问 Trident 对象定义或 Pod 本身。</block>
  <block id="2c8e89de5c6bf68b180cff5fea545167" category="section-title">使用配额和范围限制来控制存储消耗</block>
  <block id="74444eaf90c31d151645e59dcab0468d" category="inline-link">存储配额机制</block>
  <block id="1d81c150d54eae0c49d9cfeb8d493b0f" category="inline-link">范围限制</block>
  <block id="94104e476fe547cf6237480cacae5ed5" category="paragraph">Kubernetes 具有两项功能，这些功能结合使用后，可提供一种功能强大的机制来限制应用程序的资源消耗。。<block ref="bff513af91e6751aca3d34ef714e3b91" category="inline-link-rx"></block> 使管理员能够在每个命名空间基础上实施全局容量和对象计数消耗限制以及特定于存储类的限制。此外，使用<block ref="dbe9770513b0f7245f1fe016d20ebb70" category="inline-link-rx"></block> 确保在将 PVC 请求转发给配置程序之前，该请求同时处于最小值和最大值范围内。</block>
  <block id="4f9253eda0573e387f86d7777aafff03" category="inline-link">如何利用配额</block>
  <block id="923169151e05d28a3474b2a033666297" category="paragraph">这些值是按命名空间定义的，这意味着每个命名空间都应定义符合其资源要求的值。有关信息，请参见此处<block ref="5b289b2ffde01314d8b0d038aabd709b" category="inline-link-rx"></block>。</block>
  <block id="698aa9df4c2c5470599821c3d10620dd" category="summary">Kubernetes 集群通常由两种类型的节点组成，每种节点负责不同的功能方面。</block>
  <block id="6e8775bd755a8835ce86806d669677ea" category="doc">存储配置</block>
  <block id="4d59d193e356ef0157daf2c1fc0a6dd6" category="paragraph">NetApp 产品组合中的每个存储平台都具有独特的功能，无论应用程序是容器化还是非容器化，都能从中受益。Trident 可与每个主要平台配合使用： ONTAP ， Element 和 E 系列。没有一个平台比另一个平台更适合所有应用程序和场景，但是，在选择平台时，应考虑应用程序和设备管理团队的需求。</block>
  <block id="ac5112696fd64ee051846c666ebebebe" category="paragraph">您应遵循使用所使用协议的主机操作系统的基线最佳实践。或者，您也可以考虑将应用程序最佳实践（如果有）与后端，存储类和 PVC 设置结合使用，以便为特定应用程序优化存储。</block>
  <block id="efc9d085ca2f3a152c786357e9359c03" category="section-title">ONTAP 和 Cloud Volumes ONTAP 最佳实践</block>
  <block id="a3f99d5d44515cf922e6b525de736173" category="paragraph">了解为 Trident 配置 ONTAP 和 Cloud Volumes ONTAP 的最佳实践。</block>
  <block id="76d50c7d0f100e6264e0d57727d099f1" category="paragraph">以下建议是为容器化工作负载配置 ONTAP 的准则，容器化工作负载会占用 Trident 动态配置的卷。应考虑并评估每个问题在您的环境中的适用性。</block>
  <block id="3fb21976d2729216782dd61ffed84a54" category="section-title">使用专用于 Trident 的 SVM</block>
  <block id="fa4e21d3612a3f737c7a4ac7ebf24950" category="paragraph">Storage Virtual Machine （ SVM ）可在 ONTAP 系统上的租户之间实现隔离和管理隔离。通过将 SVM 专用于应用程序，可以委派特权并应用最佳实践来限制资源消耗。</block>
  <block id="3dc5510a67688b81f0d6d0db440da909" category="paragraph">可通过多种方法管理 SVM ：</block>
  <block id="fe425a9419fa4d05d42131c26306e4f1" category="list-text">在后端配置中提供集群管理接口以及相应的凭据，并指定 SVM 名称。</block>
  <block id="e2160df70bcda0ee43cb3c66dc22c719" category="list-text">使用 ONTAP 系统管理器或命令行界面为 SVM 创建专用管理接口。</block>
  <block id="2bf2fa2c1c3a6e10095db72759cc9983" category="list-text">与 NFS 数据接口共享管理角色。</block>
  <block id="5cf4c2e89b362842d77f4e4209c4ef99" category="paragraph">在每种情况下，接口都应位于 DNS 中，配置 Trident 时应使用 DNS 名称。这有助于在不使用网络身份保留的情况下实施某些灾难恢复方案，例如 SVM-DR 。</block>
  <block id="6a392b5e005fffe32231c94dc96a1605" category="inline-link">SVM-DR</block>
  <block id="2b4a6ee2db063653d6076884295a3854" category="paragraph">在为 SVM 配置专用管理 LIF 或共享管理 LIF 之间没有任何偏好，但是，您应确保网络安全策略与您选择的方法一致。无论如何，管理 LIF 应可通过 DNS 访问，以实现最大的灵活性<block ref="f5e9502989ce78934689806ebb69606a" category="inline-link-rx"></block> 与 Trident 结合使用。</block>
  <block id="4a0ee008d3379206a925ade3a9e707dd" category="section-title">限制最大卷数</block>
  <block id="e5e09031843479ef9ef8cbbd4c2f404c" category="inline-link">NetApp Hardware Universe</block>
  <block id="400a5d259a812effb5b7df506bf020ef" category="paragraph">ONTAP 存储系统具有最大卷数，具体取决于软件版本和硬件平台。请参见<block ref="bb9c67b5a4c15a85b5e6aa6c9afd0285" category="inline-link-rx"></block> 以 ONTAP 确定确切限制。当卷计数用尽时，配置操作不仅会对 Trident 失败，而且会对所有存储请求失败。</block>
  <block id="39da19b7dd55941b6cdabf34befc0b4c" category="paragraph">Trident 的 `ontap-nas` 和 `ontap-san` 驱动程序为创建的每个 Kubernetes 永久性卷（ PV ）配置一个 FlexVolume 。`ontap-nas-economy` 驱动程序会为每 200 个 PV 创建大约一个 FlexVolume （可在 50 到 300 之间配置）。`ontap-san-economy-经济` 驱动程序会为每 100 个 PV 创建大约一个 FlexVolume （可配置为 50 到 200 ）。要防止 Trident 占用存储系统上的所有可用卷，您应对 SVM 设置限制。您可以从命令行执行此操作：</block>
  <block id="f36680e3d3cb96c74d2f1a54c3c4a0fa" category="paragraph">`max-volumes` 的值因环境的特定条件而异：</block>
  <block id="5f6d1abb6889904ee0375b2fc6c8f078" category="list-text">ONTAP 集群中现有卷的数量</block>
  <block id="029383c13d9ad2c5ba18a16f8fbe2002" category="list-text">希望在 Trident 之外为其他应用程序配置的卷数</block>
  <block id="02f4ac473b944a63551d51d727b5bb49" category="list-text">Kubernetes 应用程序预期占用的永久性卷数</block>
  <block id="1d3555f20ac0a2897a1596631b5fb27a" category="paragraph">`max-volumes` 值是在 ONTAP 集群中的所有节点上配置的总卷数，而不是在单个 ONTAP 节点上配置的总卷数。因此，在某些情况下， ONTAP 集群节点所配置的 Trident 卷可能远远多于或少于其他节点。</block>
  <block id="46710fe77f663864a23e02a880a9ae53" category="inline-link">聚合</block>
  <block id="8eb27359ed8f69eb07c318fcd224ba66" category="paragraph">例如，一个双节点 ONTAP 集群最多可以托管 2000 个 FlexVolume 。将最大卷数设置为 1250 似乎非常合理。但是，如果只是<block ref="acf6cbef6ee0ef07ee3fe13269233be8" category="inline-link-rx"></block> 从一个节点分配给 SVM ，或者从一个节点分配的聚合无法配置（例如，由于容量），则另一个节点将成为所有 Trident 配置卷的目标。这意味着，在达到 `max-volumes` 值之前，可能会达到该节点的卷限制，从而影响使用该节点的 Trident 和其他卷操作。* 您可以通过确保将集群中每个节点的聚合分配给 Trident 使用的 SVM 来避免这种情况。 *</block>
  <block id="7ef3217c984ef7f973d389e434be312c" category="section-title">限制 Trident 创建的卷的最大大小</block>
  <block id="031b203330c3abb94f6fa406ff721de4" category="paragraph">要为 Trident 可以创建的卷配置最大大小，请在 `backend.json` 定义中使用 `limitVolumeSize` 参数。</block>
  <block id="1c19414de17c9992b25b0a1b02a52715" category="paragraph">除了控制存储阵列上的卷大小之外，您还应利用 Kubernetes 功能。</block>
  <block id="85c0f9773e01224a56713ea4e6d83b86" category="section-title">配置 Trident 以使用双向 CHAP</block>
  <block id="8b7c80a4394c7e64aa891100d57a755f" category="paragraph">您可以在后端定义中指定 CHAP 启动程序以及目标用户名和密码，并在 SVM 上启用 Trident CHAP 。在后端配置中使用 `useCHAP` 参数， Trident 使用 CHAP 对 ONTAP 后端的 iSCSI 连接进行身份验证。Trident 20.04 及更高版本支持双向 CHAP 。</block>
  <block id="2596e59ce5cd0d1b0066656f191365d0" category="section-title">创建并使用 SVM QoS 策略</block>
  <block id="560417d4f795b7e1176a40db8e4ccca8" category="inline-link">防止抢占资源</block>
  <block id="4870168b0713fe3089cf587858fc3b40" category="paragraph">利用应用于 SVM 的 ONTAP QoS 策略，限制 Trident 配置的卷可使用的 IOPS 数量。这有助于实现<block ref="1b59d76842e8b78d6111d3e73e9cd404" category="inline-link-rx"></block> 或控制不足的容器，以使其不会影响 Trident SVM 以外的工作负载。</block>
  <block id="d6ab867679686745d96bea839929a6de" category="paragraph">您可以通过几个步骤为 SVM 创建 QoS 策略。有关最准确的信息，请参见适用于您的 ONTAP 版本的文档。以下示例将创建一个 QoS 策略，将 SVM 可用的总 IOPS 限制为 5000 。</block>
  <block id="c790de304b7ca0097f2133cf9da4e657" category="paragraph">此外，如果您的 ONTAP 版本支持此功能，则可以考虑使用最低 QoS 来保证容器化工作负载的吞吐量。自适应 QoS 与 SVM 级别策略不兼容。</block>
  <block id="38c0b69f6b2ee691e1ba568134513414" category="paragraph">专用于容器化工作负载的 IOPS 数量取决于许多方面。其中包括：</block>
  <block id="ddbd18591c9b7378c6187dbd9179e1f0" category="list-text">使用存储阵列的其他工作负载。如果存在与 Kubernetes 部署无关的其他工作负载，则应注意利用存储资源，以确保这些工作负载不会意外受到不利影响。</block>
  <block id="5da5727b396cee5b024364d989fe253b" category="list-text">容器中运行的预期工作负载。如果 IOPS 要求较高的工作负载将在容器中运行，则 QoS 策略较低会导致出现不良体验。</block>
  <block id="e6f229b5d5d2421c4306920759828212" category="paragraph">请务必记住，在 SVM 级别分配的 QoS 策略会导致配置到 SVM 的所有卷共享同一个 IOPS 池。如果一个或少量容器化应用程序的 IOPS 要求较高，则可能会成为其他容器化工作负载的抢占资源的应用程序。如果是这种情况，您可能需要考虑使用外部自动化来分配每个卷的 QoS 策略。</block>
  <block id="ac2167b1e02d575eb6ddfe4e58f5cdcf" category="admonition">如果 ONTAP 版本早于 9.8 ，则应将此 QoS 策略组分配给 SVM * 仅 * 。</block>
  <block id="9992cae6c17055c750a849c5f6135eb2" category="section-title">为 Trident 创建 QoS 策略组</block>
  <block id="76a3e54f72b3a7224429f111e58f836c" category="inline-link">通过 QoS 保证吞吐量</block>
  <block id="edb2313b52b4c42008f0531bd6a05e49" category="paragraph">服务质量（ QoS ）可确保关键工作负载的性能不会因争用工作负载而降级。ONTAP QoS 策略组为卷提供 QoS 选项，并使用户能够为一个或多个工作负载定义吞吐量上限。有关 QoS 的详细信息，请参见<block ref="721a1778a2025ec5868484b3888c0186" category="inline-link-rx"></block>。您可以在后端或存储池中指定 QoS 策略组，这些策略组将应用于该池或后端创建的每个卷。</block>
  <block id="0394fb1288eac4cd3d40bcd991e079e9" category="paragraph">ONTAP 有两种类型的 QoS 策略组：传统和自适应。传统策略组以 IOPS 为单位提供固定的最大（或最小）吞吐量。自适应 QoS 会根据工作负载大小自动扩展吞吐量，并在工作负载大小发生变化时保持 IOPS 与 TBSGB 的比率。如果您要在大型部署中管理数百或数千个工作负载，则这将带来显著优势。</block>
  <block id="f5acc65a21daed9bb8e91cb5cdd0ae52" category="paragraph">创建 QoS 策略组时，请考虑以下事项：</block>
  <block id="6d5fcf300cd9e9239c26ce37b0919fca" category="list-text">您应在后端配置的 `defaults` 块中设置 `qosPolicy` 密钥。请参见以下后端配置示例：</block>
  <block id="32160c2368452bf7d86bcffae7f142be" category="list-text">您应该对每个卷应用策略组，以便每个卷都获得策略组指定的整个吞吐量。不支持共享策略组。</block>
  <block id="b2365e059850d5e32885189655bf469c" category="inline-link">ONTAP 9.8 QoS 命令</block>
  <block id="23225608cf33a6c6a4aec9126514b0e1" category="paragraph">有关 QoS 策略组的详细信息，请参见<block ref="40468e984a92fba9003857701268163a" category="inline-link-rx"></block>。</block>
  <block id="d5d2a5bc92eea85a4dd11a642ed8a170" category="section-title">将存储资源访问限制为 Kubernetes 集群成员</block>
  <block id="0f2b74d1b972675eb3d4efe7d8c3ed16" category="paragraph">限制对 Trident 创建的 NFS 卷和 iSCSI LUN 的访问是 Kubernetes 部署安全状况的重要组成部分。这样可以防止不属于 Kubernetes 集群的主机访问卷并可能意外修改数据。</block>
  <block id="9602ec8691c1a564016f9fd8086139f1" category="paragraph">请务必了解命名空间是 Kubernetes 中资源的逻辑边界。假设同一命名空间中的资源可以共享，但重要的是，没有跨命名空间功能。这意味着，即使 PV 是全局对象，但在绑定到 PVC 时，它们只能由同一命名空间中的 Pod 访问。* 请务必确保使用命名空间在适当时提供分隔。 *</block>
  <block id="1162be0546226cff2cbd973cd2140d33" category="paragraph">大多数组织在 Kubernetes 环境中的数据安全方面的主要顾虑是，容器中的进程可以访问挂载到主机但不适用于容器的存储。 <block ref="962cfea7b49ca7b2d398d891b4313cb5" category="inline-link-rx"></block> 旨在防止这种类型的损害。但是，存在一个例外：特权容器。</block>
  <block id="7b10e929cc2e0061dfb50042a0203c79" category="inline-link">POD 安全策略</block>
  <block id="76db1afb772160283f7f86cdd67c35f8" category="paragraph">有权限的容器是指运行时拥有比正常情况更多主机级别权限的容器。默认情况下，这些选项不会被拒绝，因此请确保使用禁用此功能<block ref="e5ab4ede40a4a6a5f5684247585b5fb0" category="inline-link-rx"></block>。</block>
  <block id="5fabba1d91abcfb09b6049897727e91c" category="paragraph">对于需要从 Kubernetes 和外部主机访问的卷，应采用传统方式管理存储，并由管理员引入 PV ，而不是由 Trident 管理。这样可以确保只有在 Kubernetes 和外部主机断开连接且不再使用此卷时，才会销毁此存储卷。此外，还可以应用自定义导出策略，以便从 Kubernetes 集群节点和 Kubernetes 集群以外的目标服务器进行访问。</block>
  <block id="4b4f0cfc14f082f2397c1c96efa18fc1" category="paragraph">对于具有专用基础架构节点（例如 OpenShift ）或其他不能为用户应用程序计划的节点的部署，应使用单独的导出策略进一步限制对存储资源的访问。其中包括为部署到这些基础架构节点的服务（例如 OpenShift 指标和日志记录服务）以及部署到非基础架构节点的标准应用程序创建导出策略。</block>
  <block id="e38f5be5ff6a8a362870a032acdf5d2f" category="section-title">使用专用导出策略</block>
  <block id="2f05855ad489343ae535c8f17eaa6f34" category="paragraph">您应确保每个后端都有一个导出策略，该策略仅允许访问 Kubernetes 集群中的节点。从 20.04 版开始， Trident 可以自动创建和管理导出策略。通过这种方式， Trident 会限制对其配置给 Kubernetes 集群中节点的卷的访问，并简化节点的添加 / 删除。</block>
  <block id="28af9e32119f59018dd5d887ad93ccd4" category="paragraph">或者，您也可以手动创建导出策略，并使用一个或多个导出规则来填充此策略，这些导出规则用于处理每个节点访问请求：</block>
  <block id="4ae1e64986504dce6897746ebc9d2786" category="list-text">使用 `vserver export-policy create` ONTAP 命令行界面命令创建导出策略。</block>
  <block id="cd0a9fca1fb3ba0fcdd98d0e87cb78a9" category="list-text">使用 `vserver export-policy rule create` ONTAP 命令行界面命令向导出策略添加规则。</block>
  <block id="bc3a2f6421da1e870583cfb0b9cf4a91" category="paragraph">通过运行这些命令，您可以限制哪些 Kubernetes 节点可以访问数据。</block>
  <block id="bd82c82b218c96acc3c66f92a723ce74" category="section-title">为应用程序 SVM 禁用 showmount</block>
  <block id="613655fb3db9bdbe0f795ee9424fc1fe" category="paragraph">通过 `showmount` 功能， NFS 客户端可以向 SVM 查询可用 NFS 导出列表。部署到 Kubernetes 集群的 Pod 可以对数据 LIF 执行问题描述 `showmount -e` 命令，并接收可用挂载列表，包括其无权访问的挂载。虽然这本身并不会影响安全，但它确实会提供不必要的信息，可能有助于未经授权的用户连接到 NFS 导出。</block>
  <block id="08f1d9a2f49f56965b640bc15796cd61" category="paragraph">您应使用 SVM 级别的 ONTAP 命令行界面命令禁用 `showmount` ：</block>
  <block id="648e0e1a6a98e76bdfe9780c42dacb6b" category="section-title">SolidFire 最佳实践</block>
  <block id="89f93e411a40f5c6365a4703e004f15b" category="paragraph">了解为 Trident 配置 SolidFire 存储的最佳实践。</block>
  <block id="52f311b56fcd9d4fb074918af9b7c7f9" category="section-title">创建 SolidFire 帐户</block>
  <block id="b0dd2707e9f12b5e1fda314748ffa386" category="paragraph">每个 SolidFire 帐户都代表一个唯一的卷所有者，并接收自己的一组质询握手身份验证协议（ Challenge-Handshake Authentication Protocol ， CHAP ）凭据。您可以使用帐户名称和相对 CHAP 凭据或通过卷访问组访问分配给帐户的卷。一个帐户最多可以分配 2 ， 000 个卷，但一个卷只能属于一个帐户。</block>
  <block id="eaf4b71058f7db58997dfe694c62a96a" category="section-title">创建 QoS 策略</block>
  <block id="fd640dfd679c3a7e40aa99c3e08c8294" category="paragraph">如果要创建并保存可应用于多个卷的标准化服务质量设置，请使用 SolidFire 服务质量（ QoS ）策略。</block>
  <block id="41be5238fc563c2aac0a0e6ee4cf6e96" category="paragraph">您可以按卷设置 QoS 参数。通过设置三个可配置的参数来定义 QoS ，可以确保每个卷的性能：最小 IOPS ，最大 IOPS 和突发 IOPS 。</block>
  <block id="48e4bd34fd7a9e1233ea82bc818a3161" category="paragraph">以下是 4 KB 块大小的可能最小，最大和突发 IOPS 值。</block>
  <block id="8e4988a1e5f387efce6f20e4f25a8e40" category="cell">IOPS 参数</block>
  <block id="0b890b1926b90387673882e6ccae7fdc" category="cell">定义</block>
  <block id="96a22bf638896c990d26e043087fb6b0" category="cell">最小value</block>
  <block id="31ce3cdcd67850870b616f75b555bbc5" category="cell">默认值</block>
  <block id="c9fb55be94277b8390352c215f32d44c" category="cell">最大值（ 4 KB ）</block>
  <block id="b05f9ccd772b396ac1f5a05345a9d4f8" category="paragraph">最小 IOPS</block>
  <block id="2b30c179facf62f8a2bdbd1b09b37b96" category="paragraph">卷的性能保障级别。</block>
  <block id="c0c7c76d30bd3dcaefc96f40275bdc0a" category="cell">50</block>
  <block id="3f74a886c7f841699690962c497d4f30" category="paragraph">15000</block>
  <block id="4f5a6f8b41826526724ba294b8e056bd" category="paragraph">最大 IOPS</block>
  <block id="4e41c5ccaf1affa697729ea4d1e88554" category="paragraph">性能不会超过此限制。</block>
  <block id="e05695d29cb4a9339534e5a9c273fa14" category="paragraph">200,000</block>
  <block id="affd4aba1c5f696e972368c9eb698c65" category="paragraph">突发 IOPS</block>
  <block id="2734923c054f38d8ca66133414af4469" category="paragraph">在短时突发情形下允许的最大 IOPS 。</block>
  <block id="e2eb05f1ef7720127ac371ceddc6f433" category="admonition">虽然最大 IOPS 和突发 IOPS 可设置为高达 200 ， 000 ，但卷的实际最大性能受集群使用情况和每节点性能的限制。</block>
  <block id="fa9b1a3006e0ba9ad904c059c0b9add6" category="inline-link">SolidFire 服务质量</block>
  <block id="7363485d4653963c22d3ed43afd0003a" category="paragraph">块大小和带宽会直接影响 IOPS 数量。随着块大小的增加，系统会将带宽增加到处理较大块大小所需的级别。随着带宽的增加，系统能够达到的 IOPS 数量也会减少。请参见<block ref="c8976c50ed9f016849fdce232777cd31" category="inline-link-rx"></block> 有关 QoS 和性能的详细信息。</block>
  <block id="b4657825f74ed622384dddf3a1d7d3b7" category="section-title">SolidFire 身份验证</block>
  <block id="9d3b5ff1cde828a63203f0465a34a967" category="paragraph">Element 支持两种身份验证方法： CHAP 和卷访问组（ VAG ）。CHAP 使用 CHAP 协议向后端对主机进行身份验证。卷访问组控制对其配置的卷的访问。NetApp 建议使用 CHAP 进行身份验证，因为它更简单，并且没有扩展限制。</block>
  <block id="fc9e812321a3f9b0eab1b702a08bab4e" category="admonition">具有增强型 CSI 配置程序的 Trident 支持使用 CHAP 身份验证。VAG 只能在传统的非 CSI 操作模式下使用。</block>
  <block id="d23eaa75b7bd1405526da0e18b7290ac" category="paragraph">只有基于帐户的访问控制才支持 CHAP 身份验证（验证启动程序是否为目标卷用户）。如果使用 CHAP 进行身份验证，则可以使用两个选项：单向 CHAP 和双向 CHAP 。单向 CHAP 使用 SolidFire 帐户名称和启动程序密钥对卷访问进行身份验证。双向 CHAP 选项可提供最安全的卷身份验证方法，因为卷会通过帐户名称和启动程序密钥对主机进行身份验证，然后主机通过帐户名称和目标密钥对卷进行身份验证。</block>
  <block id="42d135bea104c1079cebd1543c89e970" category="paragraph">但是，如果无法启用 CHAP 且需要使用 VAG ，请创建访问组并将主机启动程序和卷添加到此访问组。添加到访问组的每个 IQN 都可以使用或不使用 CHAP 身份验证访问组中的每个卷。如果将 iSCSI 启动程序配置为使用 CHAP 身份验证，则会使用基于帐户的访问控制。如果 iSCSI 启动程序未配置为使用 CHAP 身份验证，则会使用卷访问组访问控制。</block>
  <block id="f9245b5c4618640379c5b7aca1642196" category="section-title">E 系列最佳实践</block>
  <block id="2bd6c307c08ebf17bbd89f92953812b5" category="paragraph">了解为 Trident 配置 E 系列存储的最佳实践。</block>
  <block id="c502c3645d40ca0e119a2434fc569207" category="section-title">E 系列磁盘池和卷组</block>
  <block id="91e654e42725ff5233a96730cbb8353a" category="paragraph">根据需要创建磁盘池和卷组，并确定应如何将总存储容量组织为卷并在主机之间共享。磁盘池和卷组都包含一组驱动器，这些驱动器经过逻辑分组，可为应用程序主机提供一个或多个卷。磁盘池或卷组中的所有驱动器都应具有相同的介质类型。</block>
  <block id="3ff82339aba03372510cbf649c88660b" category="section-title">E 系列主机组</block>
  <block id="1d159fb9310d2d64f0e89556f5e5e92a" category="paragraph">Trident 使用主机组访问其配置的卷（ LUN ）。默认情况下， Trident 会使用名为 `trident` 的主机组，除非您在配置中指定了其他主机组名称。Trident 本身不会创建或管理主机组。在 Trident 上设置 E 系列存储后端之前，必须先创建主机组。确保主机组中的所有 Kubernetes 工作节点 iSCSI IQN 名称均已更新。</block>
  <block id="345b5f2b58b43a215fba679b4aff7483" category="section-title">E 系列快照计划</block>
  <block id="7e496222beafc240f7c54f2e86d37419" category="paragraph">创建快照计划并将 Trident 创建的卷分配给快照计划，以便可以按所需的间隔进行卷备份。根据根据根据快照策略创建的快照，可以通过将快照映像还原到基础卷来对卷执行回滚操作。您应使用 SANtricity 系统管理器创建快照计划。</block>
  <block id="b5dd97bf7f44d6c721a9534c1b6d4390" category="section-title">Snapshot 一致性组</block>
  <block id="9279a0fc4d40b361df8598208a14b586" category="paragraph">设置快照一致性组也非常适合跨越多个卷的应用程序。一致性组的目的是为多个卷同时创建快照映像，从而确保在特定时间点为一组卷创建一致的副本。您应使用 SANtricity 系统管理器创建一致性组。</block>
  <block id="1ea481e04f09f7ec7132c7773f132743" category="section-title">适用于 AWS 的 Cloud Volumes Service 最佳实践</block>
  <block id="17bc2586ce2fe71048cad42dbfd6049f" category="paragraph">了解在适用于 Trident 的 AWS 上配置 Cloud Volumes Service 的最佳实践。</block>
  <block id="bb53c6c29f127a298da7dd86bf00bb89" category="section-title">创建导出策略</block>
  <block id="8e8d04641d33b2f0af7ad761af53aeb3" category="paragraph">要确保只有经过授权的一组节点才能访问通过 Cloud Volumes Service 配置的卷，请在创建 Cloud Volumes Service 时为此导出策略设置适当的规则。通过 Trident 在云卷服务上配置卷时，请确保在后端文件中使用 `exportRule` 参数来授予对所需 Kubernetes 节点的访问权限。</block>
  <block id="e807ebdf213353b8a415f991a2cade81" category="section-title">创建快照策略</block>
  <block id="07aa362ac01b2df1044db626df0e7c9b" category="paragraph">为通过 Cloud Volume Service 配置的卷创建快照策略，以确保按要求的间隔创建快照。这样可以保证定期备份数据，并在数据丢失或数据损坏时恢复数据。您可以通过在卷详细信息页面上选择适当的计划来为 Cloud Volume Service 托管的卷设置快照策略。</block>
  <block id="283a4f872d02fc8073ac706850ed948b" category="section-title">选择适当的服务级别，存储容量和存储带宽</block>
  <block id="3251e3b8c107f351e2d3fd9e462aba19" category="paragraph">适用于 AWS 的 Cloud Volume Services 提供不同的服务级别，例如标准，高级和极高。这些服务级别可满足不同的存储容量和存储带宽要求。确保您根据业务需求选择适当的服务级别。</block>
  <block id="c34374a04df0b3e2c47131fdbb5ef741" category="paragraph">您应根据应用程序的特定需求在创建卷期间选择所需的已分配存储大小。在确定分配的存储时，需要考虑两个因素：</block>
  <block id="e2ae4659e808edd54a095d9432707c2f" category="list-text">特定应用程序的存储要求</block>
  <block id="76ba23394d92b7a06d3ecb8582769eff" category="list-text">峰值或边缘所需的带宽</block>
  <block id="e1e4f36a86f0d5a56aa4115fed351ff5" category="paragraph">存储带宽取决于所选服务级别和已分配容量的组合。因此，请选择正确的服务级别和分配的容量，同时考虑所需的带宽。</block>
  <block id="8015d968013817a20de84963d8c695b4" category="paragraph">通过在后端配置文件中使用 `limitVolumeSize` 参数，我可以限制 Trident 在 Cloud Volume Services for AWS 上创建的卷的最大大小。设置此参数可确保在请求的卷大小高于设置值时配置失败。</block>
  <block id="b4931a42b69dbf4e721e7b97873b1ebb" category="section-title">如何查找更多信息</block>
  <block id="2c3a4d5c923121574c10ea22c0474a01" category="inline-link">NetApp 库</block>
  <block id="65840df7365892d2abe1280cb6cdb1d2" category="paragraph">下面列出了一些最佳实践文档。搜索<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 对于最新版本。</block>
  <block id="d911b17f4f4cdcca62a04ad77aa9403d" category="paragraph">* ONTAP *</block>
  <block id="f9dd52d280693dc59e53b6e1fb7bd801" category="inline-link">NFS 最佳实践和实施指南</block>
  <block id="40bb23d54df7f59219c18f15a346d9e5" category="list-text"><block ref="40bb23d54df7f59219c18f15a346d9e5" category="inline-link-rx"></block></block>
  <block id="a76193f5d9397d9c49ca283a20ccf649" category="inline-link">《 SAN 管理指南》</block>
  <block id="5bc9b097037d45aff954bf9bd632d4a4" category="list-text"><block ref="c745f55eb0c9991966e63f0608541bb1" category="inline-link-rx"></block> （对于 iSCSI ）</block>
  <block id="5ca34d6ffc2a555b689542e3fbeeb7af" category="inline-link">适用于 RHEL 的 iSCSI 快速配置</block>
  <block id="36588ac65dcdb9b93916fb0ab708edb3" category="list-text"><block ref="36588ac65dcdb9b93916fb0ab708edb3" category="inline-link-rx"></block></block>
  <block id="ca7ab5ec4cba84fbef55956bb38759ce" category="paragraph">* Element 软件 *</block>
  <block id="e809d9f88c2933195c4d2ab379c1b5dc" category="inline-link">配置适用于 Linux 的 SolidFire</block>
  <block id="ce0470e08aa854a8f93fa119434e8422" category="list-text"><block ref="ce0470e08aa854a8f93fa119434e8422" category="inline-link-rx"></block></block>
  <block id="d64280eb12d42bb67976ffba6d268e7b" category="paragraph">* NetApp HCI *</block>
  <block id="3bc72bedcc42d144356d4f933c48485d" category="inline-link">NetApp HCI 部署前提条件</block>
  <block id="85bfffc1a1f7aaabd6cf58841640c308" category="list-text"><block ref="85bfffc1a1f7aaabd6cf58841640c308" category="inline-link-rx"></block></block>
  <block id="b52e411998b7d3a95ad5bd8a320bf271" category="inline-link">访问 NetApp 部署引擎</block>
  <block id="9d0da73b02655dd7861121905db229e2" category="list-text"><block ref="9d0da73b02655dd7861121905db229e2" category="inline-link-rx"></block></block>
  <block id="985f6a763990196218b4750275e1f3b6" category="paragraph">* E 系列 *</block>
  <block id="db06f9adb1b570484daf34ad3bf4e257" category="inline-link">安装和配置 Linux</block>
  <block id="a66f5507c8942de388ae63c7a177f7ab" category="list-text"><block ref="a66f5507c8942de388ae63c7a177f7ab" category="inline-link-rx"></block></block>
  <block id="9aaca8cfd79770bc4944ccc477e37141" category="paragraph">* 应用程序最佳实践信息 *</block>
  <block id="27a5e02bc2fadee43ace94805739a0c8" category="inline-link">基于 ONTAP 的 MySQL 最佳实践</block>
  <block id="40d2eaf9adabe99a601c57eabf49e4d3" category="list-text"><block ref="40d2eaf9adabe99a601c57eabf49e4d3" category="inline-link-rx"></block></block>
  <block id="17efdd7d210511985714be299d595292" category="inline-link">基于 SolidFire 的 MySQL 最佳实践</block>
  <block id="d03b53d8ec563c37e16ee8c900a75b96" category="list-text"><block ref="d03b53d8ec563c37e16ee8c900a75b96" category="inline-link-rx"></block></block>
  <block id="3aefe1a041af945f1fe8673bf775057b" category="inline-link">NetApp SolidFire 和 Cassandra</block>
  <block id="7e2b19f6f6bd1332efe1f7a698984670" category="list-text"><block ref="7e2b19f6f6bd1332efe1f7a698984670" category="inline-link-rx"></block></block>
  <block id="6e580111d3a8c12cdcd9522a4d3484c6" category="inline-link">SolidFire 上的 Oracle 最佳实践</block>
  <block id="6db96715cefe9c4950ef722865494128" category="list-text"><block ref="6db96715cefe9c4950ef722865494128" category="inline-link-rx"></block></block>
  <block id="6448cf37496207be126495e5b05851de" category="inline-link">SolidFire 上的 PostgreSQL 最佳实践</block>
  <block id="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="list-text"><block ref="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="inline-link-rx"></block></block>
  <block id="b062996d6ca590abe798d3db75561f79" category="paragraph">并非所有应用程序都有特定的准则，与您的 NetApp 团队合作并使用非常重要<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 以查找最新文档。</block>
  <block id="748c130a6179b02d614cf9a027294302" category="doc">集成 Astra Trident</block>
  <block id="463c6e3deb27d776ba0302b5b90f6607" category="paragraph">要集成 Astra Trident ，需要集成以下设计和架构要素：驱动程序选择和部署，存储类设计，虚拟存储池设计，永久性卷声明（ PVC ）对存储配置的影响，卷操作以及使用 Astra Trident 部署 OpenShift 服务。</block>
  <block id="1fdc23c8579638d050b7b219da011f2b" category="section-title">驱动程序选择和部署</block>
  <block id="150d96898b109ac670a955fd616679fe" category="section-title">为 ONTAP 选择后端驱动程序</block>
  <block id="3b81f3dbce48d5a5e5f6f338de47bb44" category="paragraph">ONTAP 系统可使用四种不同的后端驱动程序。这些驱动程序根据所使用的协议以及在存储系统上配置卷的方式进行了区分。因此，请仔细考虑要部署的驱动程序。</block>
  <block id="815a377da65ae5b66c84438c43416d82" category="paragraph">更高级别的是，如果您的应用程序中的组件需要共享存储（多个 Pod 访问同一个 PVC ），则基于 NAS 的驱动程序将成为默认选项，而基于块的 iSCSI 驱动程序则可满足非共享存储的需求。根据应用程序要求以及存储和基础架构团队的舒适程度选择协议。一般来说，对于大多数应用程序来说，它们之间没有什么区别，因此通常是根据是否需要共享存储（多个 POD 需要同时访问）来决定的。</block>
  <block id="3e5fda6b2fdf8b78a529ee58e0289c8d" category="paragraph">下面列出了 ONTAP 后端的五个驱动程序：</block>
  <block id="c2c889ded63fbe94cf7f1d5fe4747b2d" category="list-text">`ontap-NAS` ：配置的每个 PV 都是一个完整的 ONTAP FlexVolume 。</block>
  <block id="9418583a1b7e700d24bcc735aa4682b5" category="list-text">`ontap-nas-economy.` ：配置的每个 PV 都是一个 qtree ，每个 FlexVolume 的 qtree 数量是可配置的（默认值为 200 ）。</block>
  <block id="bc8f11db54909209ba09d55ee0b46990" category="list-text">`ontap-nas-flexgroup` ：使用配置为完整 ONTAP FlexGroup 的每个 PV ，以及分配给 SVM 的所有聚合。</block>
  <block id="5e587346b7a212ee6429303276a1578b" category="list-text">`ontap-san` ：配置的每个 PV 都是其自身 FlexVolume 中的一个 LUN 。</block>
  <block id="85f6f5093b037b5bde3201d8136ee585" category="list-text">`ontap-san-economi` ：配置的每个 PV 都是一个 LUN ，每个 FlexVolume 具有可配置的 LUN 数量（默认值为 100 ）。</block>
  <block id="f1d8371af632688748db007c98766ded" category="paragraph">在三个 NAS 驱动程序之间进行选择会对应用程序可用的功能产生一些影响。</block>
  <block id="8a1187760a2c55e422a454a64e160291" category="paragraph">请注意，在下表中，并非所有功能都通过 Astra Trident 公开。如果需要某些功能，存储管理员必须在配置后应用这些功能。上标脚注区分了每个功能和驱动程序的功能。</block>
  <block id="6252699c8e049f40eaf187092727a531" category="cell">ONTAP NAS 驱动程序</block>
  <block id="9147e5e61a7b9260dec09f3a6eb3e5be" category="cell">快照</block>
  <block id="999cc42b236c7aee1157ff02d6f1bcd5" category="cell">克隆</block>
  <block id="13bc190bfed9f972b3e33e3656737cdd" category="cell">动态导出策略</block>
  <block id="ab0c646b4c5e36d9bcf8239d97fd1843" category="cell">多连接</block>
  <block id="8f2db90dd4a6fbd95ba8f0bc54fd6b27" category="cell">QoS</block>
  <block id="9d723d04c40bfd81835c0766a698cf63" category="cell">调整大小</block>
  <block id="8c340dc334134096f68b880b42a8692c" category="cell">Replication</block>
  <block id="00055dac2ba112b87a95a368075b9561" category="cell">`ontap-NAS`</block>
  <block id="6bfc395e3d384b30d9f43ca45b1eeff7" category="cell">是脚注： 5[]</block>
  <block id="7c078cb746c3dd22969c07747fd7f3fc" category="cell">是脚注： 1[]</block>
  <block id="cecdaed309330a9e7dea16b2076957ee" category="cell">`ontap-nas-economy.`</block>
  <block id="e4e9da2a7bd5e2b5b29c51299a1b787f" category="cell">是脚注： 3[]</block>
  <block id="2b8ac774302bd45e0ad531e434d8cd6d" category="cell">`ontap-nas-flexgroup`</block>
  <block id="bafd7322c6e97d25b6299b5d6fe8920b" category="cell">否</block>
  <block id="15861eb7768c6587d321b6010008930e" category="paragraph">Astra Trident 为 ONTAP 提供了 2 个 SAN 驱动程序，其功能如下所示。</block>
  <block id="f916141465c67326e5d7d980bff2880b" category="cell">ONTAP SAN 驱动程序</block>
  <block id="4f546cdc5f90f7d264cde89d14c6e015" category="cell">双向 CHAP</block>
  <block id="cd17e7ed84c40a0ff5ecb8b625b1f186" category="cell">`ontap-san`</block>
  <block id="e78e01b4457814be0584f80618e4659a" category="cell">是脚注： 4[]</block>
  <block id="73b781a615cea2647a87ff2035e296b1" category="cell">`ontap-san-economy.`</block>
  <block id="708ee6a923f9b4b3f2213d57632eaadc" category="verse-content-simple">上述表的脚注：是脚注： 1[] ：不受 Astra Trident 管理是脚注： 2[] ：由 Astra Trident 管理，但不是 PV 粒度 Yesfootnote ： 3[] ：不受 Astra Trident 管理，也不是 PV 粒度 Yesnote ： 4[] ：支持原始块卷是脚注： 5[] ： CSI Trident 支持</block>
  <block id="74b4b41be17ac9897921032dfd4e94a8" category="paragraph">非 PV 粒度功能将应用于整个 FlexVolume ，而所有 PV （即共享 FlexVol 中的 qtree 或 LUN ）将共享一个通用计划。</block>
  <block id="b483d59c54aea739f0806cf2f30c057e" category="paragraph">如上表所示， `ontap-nas` 与 `ontap-nas-economy` 之间的大部分功能是相同的。但是，由于 `ontap-nas-economy` 驱动程序限制了按 PV 粒度控制计划的能力，因此这可能会特别影响灾难恢复和备份规划。对于希望在 ONTAP 存储上利用 PVC 克隆功能的开发团队，只有在使用 `ontap-NAS` ， `ontap-san` 或 `ontap-san-economy-经济` 驱动程序时，才可能实现这一点。</block>
  <block id="45f7f2e55c0930a28d1a9e481e602a09" category="admonition">`solidfire-san` 驱动程序还能够克隆 PVC 。</block>
  <block id="5ea8a1263c170a1b26153c03919a84f2" category="section-title">为 Cloud Volumes ONTAP 选择后端驱动程序</block>
  <block id="20743b3fe5b4d69360557b02168b12ea" category="paragraph">Cloud Volumes ONTAP 可为各种使用情形提供数据控制以及企业级存储功能，包括文件共享和为 NAS 和 SAN 协议（ NFS ， SMB/CIFS 和 iSCSI ）提供服务的块级存储。Cloud Volume ONTAP 的兼容驱动程序包括 `ontap-nas` ， `ontap-nas-economy.` `ontap-san` 和 `ontap-san-economy.`这些功能适用于 Cloud Volume ONTAP for AWS ， Cloud Volume ONTAP for Azure ， Cloud Volume ONTAP for GCP 。</block>
  <block id="6b1a08ddb7e74488a9039997d4961ff8" category="section-title">为适用于 ONTAP 的 Amazon FSX 选择后端驱动程序</block>
  <block id="168b96624733268bb4b4ebfbebea0449" category="paragraph">借助适用于 ONTAP 的 Amazon FSX ，客户可以利用他们熟悉的 NetApp 功能，性能和管理功能，同时利用在 AWS 上存储数据的简便性，灵活性，安全性和可扩展性。FSX for ONTAP 支持 ONTAP 的许多文件系统功能和管理 API 。Cloud Volume ONTAP 的兼容驱动程序包括 `ontap-nas` ， `ontap-nas-economy.` `ontap-nas-flexgroup` ， `ontap-san` 和 `ontap-san-economy.`</block>
  <block id="d0030e26d7e1baf13ad36649449f3689" category="section-title">为 NetApp HCI/SolidFire 选择后端驱动程序</block>
  <block id="e040ac9827d856d3ad8ae9ac0da92295" category="paragraph">与 NetApp HCI/SolidFire 平台结合使用的 `solidfire-san` 驱动程序可帮助管理员根据 QoS 限制为 Trident 配置 Element 后端。如果您希望设计后端，以便为 Trident 配置的卷设置特定的 QoS 限制，请在后端文件中使用 `type` 参数。管理员还可以使用 `limitVolumeSize` 参数限制可在存储上创建的卷大小。目前， `solidfire-san` 驱动程序不支持卷大小调整和卷复制等 Element 存储功能。这些操作应通过 Element Software Web UI 手动完成。</block>
  <block id="77e9d6f249e4626d5b5c3aec863459d3" category="cell">SolidFire 驱动程序</block>
  <block id="9ef2bbb12ff72558472202561a25058d" category="cell">CHAP</block>
  <block id="57ee8ed0b2796ea5f35b10f9ae5d68cd" category="cell">`solidfire-san`</block>
  <block id="0929973a1c9993903f6193add75b3fcf" category="cell">是脚注： 2[]</block>
  <block id="bccbad684880808562152ac1d82d7b73" category="verse-content-simple">脚注：是脚注： 1[] ：不由 Astra Trident 管理是脚注： 2[] ：支持原始块卷</block>
  <block id="bb1da85f123c0dbedeb19d1f5c676112" category="section-title">为 Azure NetApp Files 选择后端驱动程序</block>
  <block id="657e0fa57d574227dd7520919f55ff92" category="paragraph">Astra Trident 使用 `azure-netapp-files` 驱动程序来管理 <block ref="d617d79fbb5ee3bc8bd280353eeb1349" category="inline-link-macro-rx"></block> 服务</block>
  <block id="1f65578a7accdff5ca6ff9f8dc42d9c6" category="inline-link-macro">适用于 Azure NetApp Files 的 Astra Trident 后端配置</block>
  <block id="e4eb3683baaad2a9ce9e264a37fb519e" category="paragraph">有关此驱动程序及其配置方法的详细信息，请参见 <block ref="452e5754c64fc2b52b13e03114bfeff6" category="inline-link-macro-rx"></block>。</block>
  <block id="4da613089cbda3d7c19cb4b3f67c1f5d" category="cell">Azure NetApp Files 驱动程序</block>
  <block id="8098b34f582537833b36b58273c3545b" category="cell">展开</block>
  <block id="e228843381960c06d1035c4219901307" category="cell">`azure-netapp-files`</block>
  <block id="2fdc8a66565228c15d355a7849997337" category="verse-content-simple">脚注：是脚注： 1[] ：不由 Astra Trident 管理</block>
  <block id="08a2e51877cfee5806cf83c6d30fbefe" category="section-title">选择适用于采用 AWS 的 Cloud Volumes Service 的后端驱动程序</block>
  <block id="01d0b26a2d16d5fb475e224d7705b56d" category="paragraph">Astra Trident 使用 `AWS-CVS` 驱动程序与 AWS 后端的 Cloud Volumes Service 链接。要在 Trident 上配置 AWS 后端，您需要在后端文件中指定 `apiRegion` ， `apiURL` ， `apiKey` 和 `secreKey` 。这些值可在 CVS Web 门户中的 Account settings/API access 中找到。支持的服务级别与 CVS 一致，包括 `standard` ， `Premium` 和 `Extreme` 。目前，要配置的最小卷大小为 100G 。未来版本的 CVS 可能会删除此限制。</block>
  <block id="f5619cf78c5af29a1223fb34ef1361ce" category="cell">CVS for AWS 驱动程序</block>
  <block id="b69ca6e3662048fc46e2e4f8adc185a1" category="cell">`AWS-CVS`</block>
  <block id="c7fdaa4c02d33ea744bd0e39a9e89956" category="paragraph">`AWS-CVS` 驱动程序使用虚拟存储池。虚拟存储池会对后端进行抽象化，从而使 Trident 决定卷的放置。管理员在 backend.json 文件中定义虚拟存储池。存储类使用标签标识虚拟存储池。</block>
  <block id="88d040295b5885489339e969bf92517c" category="section-title">为采用 GCP 的 Cloud Volumes Service 选择后端驱动程序</block>
  <block id="1d326a2a7f267c800fe3eafb89e5c7cd" category="inline-link-macro">服务类型</block>
  <block id="f888f12905dbaabc09dd3e50073d862f" category="paragraph">Astra Trident 使用 `GCP-CVS` 驱动程序与 GCP 后端的 Cloud Volumes Service 链接。要在 Trident 上配置 GCP 后端，您需要在后端文件中指定 `projectNumber` ， `apiRegion` 和 `apiKey` 。项目编号可在 GCP Web 门户中找到，而 API 密钥必须从您在 GCP 上为 Cloud Volumes 设置 API 访问时创建的服务帐户专用密钥文件中获取。Astra Trident 可以在两个卷中创建 CVS 卷之一 <block ref="a3cd55e5a9ff014b76f6953040234c24" category="inline-link-macro-rx"></block>：</block>
  <block id="3481817b04a40b0420a940c0c9c1f82d" category="list-text">* CVS* ：基本 CVS 服务类型，可提供较高的区域可用性，但性能级别有限 / 中等。</block>
  <block id="19de6287eaf342572d94a5e0b99c2823" category="list-text">* CVS-Performance* ：经过性能优化的服务类型最适合重视性能的生产工作负载。从三个独特的服务级别中进行选择 `standard` ， `Premium` 和 `Extreme` 。目前， 100 GiB 是要配置的最小 CVS-Performance 卷大小，而 CVS 卷必须至少为 300 GiB 。未来版本的 CVS 可能会删除此限制。</block>
  <block id="4525f6e1d5124cd80f38341d78e8a67d" category="inline-link-macro">此表单</block>
  <block id="51e6e54f894aa900f8a1822598ef3c5a" category="admonition">使用默认 CVS 服务类型 `storageClass=software` 部署后端时，用户 * 必须获得 * 对 GCP 上相关项目编号和项目 ID 的子 1TiB 卷功能的访问权限。这对于 Trident 配置低于 1TiB 的卷是必需的。否则，对于小于 600 GiB 的 PVC ，卷创建 * 将失败 * 。使用 ... <block ref="0c921b807a9a638a24dd843d24ed0800" category="inline-link-macro-rx"></block> 以访问低于 1 TiB 的卷。</block>
  <block id="6219f23a135db2efc679d38117420cf0" category="cell">适用于 GCP 的 CVS 驱动程序</block>
  <block id="949a374fc5a78d436e3067ee2de19cbe" category="cell">`GCP-CVS`</block>
  <block id="439d990c21037b37b51c4373a7aa9811" category="paragraph">`GCP-CVS` 驱动程序使用虚拟存储池。虚拟存储池会对后端进行抽象化，从而使 Astra Trident 决定卷的放置。管理员在 backend.json 文件中定义虚拟存储池。存储类使用标签标识虚拟存储池。</block>
  <block id="3af6198d49c40c18f13c73c5ce15cf34" category="section-title">存储类设计</block>
  <block id="388bdf78cbb5b6bf4248ddf5613f7cc3" category="paragraph">要创建 Kubernetes 存储类对象，需要配置并应用各个存储类。本节讨论如何为您的应用程序设计存储类。</block>
  <block id="964c7dcda39ec7b9c8717c3369e2fc25" category="section-title">针对特定后端利用率的存储类设计</block>
  <block id="a09acd5f665bdf96b6dce47f8d4265e3" category="paragraph">可以在特定存储类对象中使用筛选功能来确定要将哪个存储池或一组池与该特定存储类结合使用。可以在存储类中设置三组筛选器： `storagePools` ， `addtionalStoragePools` 和 / 或 `excludeStoragePools` 。</block>
  <block id="fc01760e8c283c2f128543ae8b8a67cc" category="paragraph">`storagePools` 参数有助于将存储限制为与任何指定属性匹配的一组池。`addtionalStoragePools` 参数用于扩展 Astra Trident 用于配置的池集以及由属性和 `storagePools` 参数选择的池集。您可以单独使用参数，也可以同时使用这两个参数，以确保选择适当的存储池集。</block>
  <block id="74476e892d2681775eb41ec00a11e8da" category="paragraph">`excludeStoragePools` 参数用于明确排除列出的一组与属性匹配的池。</block>
  <block id="072c88043b516dbbbadd8bb0182445c7" category="section-title">用于模拟 QoS 策略的存储类设计</block>
  <block id="ab807e6bd2f9cb9872eed98161bdd4e1" category="paragraph">如果要设计存储类以模拟服务质量策略，请创建一个存储类，其中 `mmedia` attribute 为 `HDD` 或 `sSD` 。根据存储类中提及的 `mmedia` 属性， Trident 将选择提供 `HDD` 或 `sSD` 聚合的相应后端，以便与介质属性匹配，然后将卷配置定向到特定聚合。因此，我们可以创建一个存储类高级版，该高级版会将 `mmedia` attribute 设置为 `sSD` ，该高级版可归类为高级 QoS 策略。我们可以创建另一个存储类标准，该标准会将介质属性设置为 `HDD' ，并可归类为标准 QoS 策略。我们还可以使用存储类中的 ``IOPS' 属性将配置重定向到可定义为 QoS 策略的 Element 设备。</block>
  <block id="eb47104f276a8955680299ff2f4bd39d" category="section-title">存储类设计，可根据特定功能利用后端</block>
  <block id="0bc0e72aefbf8f8ec0b28cc0486f98a2" category="paragraph">存储类可设计为在启用了精简和厚配置，快照，克隆和加密等功能的特定后端直接配置卷。要指定要使用的存储，请创建存储类，以指定启用了所需功能的相应后端。</block>
  <block id="f45e814b7c305f5341f031df78bf2f07" category="section-title">虚拟存储池的存储类设计</block>
  <block id="bd755d43092fcea772b8e9ab21e9951e" category="paragraph">所有 Astra Trident 后端均可使用虚拟存储池。您可以使用 Astra Trident 提供的任何驱动程序为任何后端定义虚拟存储池。</block>
  <block id="365b4529a5f01ced729944db23d237a5" category="paragraph">通过虚拟存储池，管理员可以在后端创建一个抽象级别，并可通过存储类进行引用，从而提高卷在后端的灵活性和效率。可以使用相同的服务类定义不同的后端。此外，可以在同一后端创建多个存储池，但其特征不同。如果为存储类配置了具有特定标签的选择器，则 Astra Trident 会选择与所有选择器标签匹配的后端来放置卷。如果存储类选择器标签与多个存储池匹配，则 Astra Trident 将选择其中一个存储池来配置卷。</block>
  <block id="830a7882918fba200333b9c6ea7db363" category="section-title">虚拟存储池设计</block>
  <block id="65f970319bb8b6ede33a2d975be3693d" category="paragraph">创建后端时，通常可以指定一组参数。管理员无法使用相同的存储凭据和一组不同的参数创建另一个后端。随着虚拟存储池的推出，此问题描述得以缓解。虚拟存储池是在后端和 Kubernetes 存储类之间引入的级别抽象，因此管理员可以定义参数以及标签，这些参数和标签可以通过 Kubernetes 存储类作为选择器进行引用，并且与后端无关。可以使用 Astra Trident 为所有受支持的 NetApp 后端定义虚拟存储池。该列表包括 SolidFire/NetApp HCI ， ONTAP ， AWS 和 GCP 上的 Cloud Volumes Service 以及 Azure NetApp Files 。</block>
  <block id="3c4f3a478663d0f7aab5180da0b1356a" category="admonition">定义虚拟存储池时，建议不要尝试在后端定义中重新排列现有虚拟池的顺序。此外，建议不要编辑 / 修改现有虚拟池的属性，而是定义新的虚拟池。</block>
  <block id="d96c9f641b35ec82dabdc46092afe1d0" category="section-title">设计虚拟存储池以模拟不同的服务级别 /QoS</block>
  <block id="9e44f014bb0976e50892e95fed1ed5b5" category="paragraph">可以设计虚拟存储池来模拟服务类。使用 Cloud Volume Service for AWS 的虚拟池实施，让我们来了解一下如何设置不同的服务类。使用多个标签配置 AWS-CVS 后端，以表示不同的性能级别。将 `servicelevel` Aspect 设置为适当的性能级别，并在每个标签下添加其他所需的内容。现在，创建可映射到不同虚拟存储池的不同 Kubernetes 存储类。使用 `parameters.selector` 字段，每个 StorageClass 都会调用可用于托管卷的虚拟池。</block>
  <block id="85d73d477f633146bd32af7aaedd54da" category="section-title">设计用于分配特定方面的虚拟池</block>
  <block id="c011d5d6ca18de1df954b81c6bb49d4a" category="paragraph">可以从一个存储后端设计具有一组特定方面的多个虚拟存储池。为此，请为后端配置多个标签，并在每个标签下设置所需的方面。现在，使用 `parameters.selector` 字段创建不同的 Kubernetes 存储类，该字段将映射到不同的虚拟存储池。在后端配置的卷将在选定的虚拟存储池中定义相关方面。</block>
  <block id="421f7dd5bb37a6401aa6326ad33dae20" category="section-title">影响存储配置的 PVC 特征</block>
  <block id="3800921d8c248cc0de59c64d110e570a" category="paragraph">创建 PVC 时，请求的存储类以外的某些参数可能会影响 Astra Trident 的配置决策过程。</block>
  <block id="5ab83f35784f154d55ea7ab58c8e503b" category="section-title">访问模式</block>
  <block id="f3882c83b41b76a9fac2c57407f3ac2b" category="paragraph">通过 PVC 请求存储时，访问模式为必填字段之一。所需的模式可能会影响所选的托管存储请求的后端。</block>
  <block id="b72ab56468fdf0df298a89c3339b82c0" category="paragraph">Astra Trident 将尝试与根据下表指定的访问方法所使用的存储协议匹配。这独立于底层存储平台。</block>
  <block id="cac415feda213697b27d3b6fce10d33a" category="cell">ReadWriteOnce</block>
  <block id="c24ad3d99a666c95edd149419c958ee0" category="cell">ReadOnlyMany</block>
  <block id="caa8dc1f4bb28d2d11226494cd05a123" category="cell">读取写入任何</block>
  <block id="e4e1c13bb0b14f6cb7608cbecea948ef" category="cell">iSCSI</block>
  <block id="cefb8ccdebef1940174b22e9d0ab530b" category="cell">是（原始块）</block>
  <block id="1d1a594959ec615f56516f5d0f5e8ddb" category="cell">NFS</block>
  <block id="823f2153adc2211a0777560eafdcbad6" category="paragraph">如果在未配置 NFS 后端的情况下向 Trident 部署提交了 ReadWriteMany PVC 请求，则不会配置任何卷。因此，请求者应使用适合其应用程序的访问模式。</block>
  <block id="5a51acb2538e54805c54d37ebb49c75d" category="section-title">卷操作</block>
  <block id="26fad327e23b6b08dcc94300bfe1ed04" category="section-title">修改永久性卷</block>
  <block id="3b69d471bb98837ae6e267593bb38882" category="paragraph">除了两个例外，永久性卷是 Kubernetes 中不可变的对象。创建后，可以修改回收策略和大小。但是，这并不会阻止在 Kubernetes 外部修改卷的某些方面。为了针对特定应用程序自定义卷，确保容量不会意外占用，或者出于任何原因将卷移动到其他存储控制器，这一点可能是理想的。</block>
  <block id="f82b5505d8def4abda0bec52275bd411" category="admonition">目前， Kubernetes 树中配置程序不支持对 NFS 或 iSCSI PV 执行卷大小调整操作。Astra Trident 支持扩展 NFS 和 iSCSI 卷。</block>
  <block id="b1d1874782626fe3f391628ea493e6ef" category="paragraph">创建 PV 后，无法修改其连接详细信息。</block>
  <block id="e68591655c8031177206e1e75728853f" category="section-title">创建按需卷快照</block>
  <block id="f557ce2b38683c13c1c1a070ce58a33d" category="paragraph">Astra Trident 支持按需创建卷快照，并使用 CSI 框架从快照创建 PVC 。快照提供了一种维护数据时间点副本的便捷方法，并且生命周期独立于 Kubernetes 中的源 PV 。这些快照可用于克隆 PVC 。</block>
  <block id="f007c56a8eb121e8a696105e69aefa68" category="section-title">从快照创建卷</block>
  <block id="e005d448313cdc2848d923f4c754e467" category="paragraph">Astra Trident 还支持从卷快照创建 PersistentVolumes 。为此，只需创建 PersistentVolumeClaim 并注明 `datasource` 作为创建卷所需的快照即可。Astra Trident 将通过创建包含快照上的数据的卷来处理此 PVC 。通过此功能，可以跨区域复制数据，创建测试环境，整体更换损坏或损坏的生产卷，或者检索特定文件和目录并将其传输到另一个连接的卷。</block>
  <block id="55a3309b0b6646e0ea6b47195bd3d4bd" category="section-title">移动集群中的卷</block>
  <block id="925b814524908630c07d45fc5a80028a" category="paragraph">存储管理员可以在 ONTAP 集群中的聚合和控制器之间无中断地将卷移动到存储使用者。此操作不会影响 Astra Trident 或 Kubernetes 集群，只要目标聚合是 Astra Trident 所使用的 SVM 有权访问的聚合即可。重要的是，如果已将聚合新添加到 SVM ，则需要通过将后端重新添加到 Astra Trident 来刷新后端。这将触发 Astra Trident 对 SVM 重新进行清单配置，以便识别新聚合。</block>
  <block id="033dcaefcc578c987d32d4bdb6f6b1e2" category="paragraph">但是， Astra Trident 不支持在后端之间自动移动卷。这包括在同一集群中的 SVM 之间，集群之间或不同存储平台上（即使该存储系统是连接到 Astra Trident 的存储系统也是如此）。</block>
  <block id="302be77289f337115411c01846d9a489" category="paragraph">如果将卷复制到其他位置，则可以使用卷导入功能将当前卷导入到 Astra Trident 中。</block>
  <block id="2243e252be826d6ec5e767668d9f961d" category="section-title">展开卷</block>
  <block id="a059bca2035a0befa11f641fdabde223" category="paragraph">Astra Trident 支持调整 NFS 和 iSCSI PV 的大小。这样，用户就可以直接通过 Kubernetes 层调整其卷的大小。所有主要 NetApp 存储平台均可进行卷扩展，包括 ONTAP ， SolidFire/NetApp HCI 和 Cloud Volumes Service 后端。要稍后允许扩展，请在与卷关联的 StorageClass 中将 `allowVolumeExpansion` 设置为 `true` 。每当需要调整永久性卷的大小时，请在永久性卷声明中编辑 `sPec.resources.requests.storage` 标注以指定所需的卷大小。Trident 会自动调整存储集群上卷的大小。</block>
  <block id="40a28a40c11a193f8911cf4143a6ae6a" category="section-title">将现有卷导入到 Kubernetes 中</block>
  <block id="911dcebca8f00bd038d697c0c5b9f99d" category="paragraph">通过卷导入，可以将现有存储卷导入到 Kubernetes 环境中。目前， `ontap-nas` ， `ontap-nas-flexgroup` ， `solidfire-san` ， `azure-netapp-files` ， `AWS-CVS` ， 和 `GCP-CVS` 驱动程序。在将现有应用程序移植到 Kubernetes 或在灾难恢复场景中，此功能非常有用。</block>
  <block id="5d9f64103cac7a58da69304bc3320e98" category="paragraph">使用 ONTAP 和 `solidfire-san` 驱动程序时，请使用命令 `tridentctl import volume &lt;backend-name&gt; &lt;volume-name&gt; -f /path/PVC.YAML` 将现有卷导入到要由 Astra Trident 管理的 Kubernetes 中。导入卷命令中使用的 PVC YAML 或 JSON 文件指向将 Astra Trident 标识为配置程序的存储类。使用 NetApp HCI/SolidFire 后端时，请确保卷名称是唯一的。如果卷名称重复，请将卷克隆为唯一名称，以便卷导入功能可以区分它们。</block>
  <block id="5c7a693958891a764b947da44bbeb122" category="paragraph">如果使用了 `AWS-CVS` ， `azure-netapp-files` 或 `GCP-CVS` 驱动程序，请使用命令 `tridentctl import volume &lt;backend-name&gt; &lt;volume path&gt; -f /path/PVC.YAML` 将卷导入到要由 Astra Trident 管理的 Kubernetes 中。这样可以确保卷引用是唯一的。</block>
  <block id="cb619cd0109686b5f82562b63e44a107" category="paragraph">执行上述命令后， Astra Trident 将在后端找到卷并读取其大小。它将自动添加（并在必要时覆盖）已配置的 PVC 卷大小。然后， Astra Trident 会创建新的 PV ， Kubernetes 会将 PVC 绑定到 PV 。</block>
  <block id="3a8b25f50e2dcc298175abc8f6a71f82" category="paragraph">如果部署的容器需要特定的导入 PVC ，则容器将保持待定状态，直到通过卷导入过程绑定 PVC/PV 对为止。在绑定 PVC/PV 对后，如果没有其他问题，应启动容器。</block>
  <block id="41603705958b86c3ec4ff21cfce13a5b" category="section-title">部署 OpenShift 服务</block>
  <block id="7e3c623b48b608f4c6380c2994ae5aa9" category="paragraph">OpenShift 增值集群服务为集群管理员和要托管的应用程序提供了重要功能。这些服务使用的存储可以使用节点本地资源进行配置，但这通常会限制服务的容量，性能，可恢复性和可持续性。利用企业级存储阵列为这些服务提供容量可以显著改善服务，但是，与所有应用程序一样， OpenShift 和存储管理员应密切合作，为每个服务确定最佳选项。应大量利用 Red Hat 文档来确定要求并确保满足规模估算和性能需求。</block>
  <block id="6dd8f6c286b8e1a8c96c6309099f0003" category="section-title">注册表服务</block>
  <block id="68ee1c4c0da20bfd1e946df20351d4b9" category="inline-link-macro">netapp.io</block>
  <block id="126ac9f6149081eb0e97c2e939eaad52" category="inline-link-macro">博客</block>
  <block id="34d357a7f8cc47e860d5fb0a317cf22d" category="paragraph">有关为注册表部署和管理存储的文档，请参见 <block ref="d5e1883ebd095c0eda96c44469e8197d" category="inline-link-macro-rx"></block> 在中 <block ref="ceb73d0582d40281d79011a1e5343e89" category="inline-link-macro-rx"></block>。</block>
  <block id="62ac236856a5a6aefd15133e967514c6" category="section-title">日志记录服务</block>
  <block id="2f3052b6a2858bec8355ec56150f6a38" category="paragraph">与其他 OpenShift 服务一样，日志记录服务也是使用清单文件（也称为）提供的配置参数 Ansible 部署的主机，提供给攻略手册。其中包括两种安装方法：在初始 OpenShift 安装期间部署日志记录以及在安装 OpenShift 之后部署日志记录。</block>
  <block id="541c717d8d2998609c0970b5e43c7401" category="admonition">自 Red Hat OpenShift 3.9 版开始，官方文档出于对数据损坏的担忧，建议不要对日志记录服务使用 NFS 。这是基于 Red Hat 对其产品的测试得出的。ONTAP 的 NFS 服务器不存在这些问题，可以轻松地备份日志记录部署。最终，您可以选择日志记录服务的协议，只需了解这两种协议在使用 NetApp 平台时都能很好地发挥作用，如果您愿意，也没有理由避免使用 NFS 。</block>
  <block id="57cad4852c9c2e439f61728e0391fe7b" category="paragraph">如果您选择将 NFS 与日志记录服务结合使用，则需要将 Ansible 变量 `OpenShift_enable_unsupported _configurations` 设置为 `true` ，以防止安装程序失败。</block>
  <block id="be11c74c1dd7f307bb80183a90dc2067" category="section-title">入门</block>
  <block id="16e90b2336fdfec64b19194247422194" category="paragraph">可以选择为这两个应用程序以及 OpenShift 集群本身的核心操作部署日志记录服务。如果选择部署操作日志记录，则通过将变量 `OpenShift_logging_use_ops` 指定为 `true` ，将创建两个服务实例。控制操作日志记录实例的变量包含 "ops" ，而应用程序实例则不包含 "ops" 。</block>
  <block id="a9ccaa810b97a00e75bb1ea4100d0a9f" category="paragraph">要确保底层服务使用正确的存储，必须根据部署方法配置 Ansible 变量。让我们来了解一下每种部署方法的选项。</block>
  <block id="c5c09113a6a6ae4b75868a9e96ea3cc3" category="inline-link-macro">RedHat OpenShift 日志记录文档</block>
  <block id="bc468c28ba57dbcb58de37265cd02436" category="admonition">下表仅包含与存储配置相关的变量，因为这些变量与日志记录服务相关。您可以在中找到其他选项 <block ref="e81826ec3b15492352776daada114990" category="inline-link-macro-rx"></block> 应根据您的部署情况查看，配置和使用。</block>
  <block id="02098b11f876fe10c40b6106bd9864da" category="paragraph">下表中的变量将导致 Ansible 攻略手册使用提供的详细信息为日志记录服务创建 PV 和 PVC 。与在 OpenShift 安装后使用组件安装攻略手册相比，此方法的灵活性明显降低，但是，如果您有可用的现有卷，则可以选择此方法。</block>
  <block id="47c14840d8e15331fa420b9b2f757cd9" category="cell">变量</block>
  <block id="3ec365dd533ddb7ef3d1c111186ce872" category="cell">详细信息</block>
  <block id="9aa2fd43742cd5ed36b406b3f4b0fd8c" category="cell">`OpenShift_logging_storage_kind`</block>
  <block id="3260b06ea72e4931f5fb5106001fcc28" category="cell">设置为 `NFS` ，以使安装程序为日志记录服务创建 NFS PV 。</block>
  <block id="e95f43173c69a9ca544d4aaef28a4d90" category="cell">`OpenShift_logging_storage_host`</block>
  <block id="3a262c1d9bdec02b241c16b2c5f6dbbe" category="cell">NFS 主机的主机名或 IP 地址。此值应设置为虚拟机的数据 LIF 。</block>
  <block id="41aae586bb7044d7741fe9412aa81e03" category="cell">`OpenShift_logging_storage_nfs_directory`</block>
  <block id="bf2d137d8c669b07aae26040c7e5c0e0" category="cell">NFS 导出的挂载路径。例如，如果卷接合为 ` /OpenShift_logging` ，则应使用该路径作为此变量。</block>
  <block id="88a9f7d18fabb82d63ac43c64ae6e735" category="cell">`OpenShift_logging_storage_volume_name`</block>
  <block id="6f8782c23f3cb958d0de4fad76dabaed" category="cell">要创建的 PV 的名称，例如 `PV_ose_logs` 。</block>
  <block id="789e0dc4bfc00f5c885a698d6ab34dff" category="cell">`OpenShift_logging_storage_volume_size`</block>
  <block id="b68f05ea52c8c80c07e6a4c0671c75bf" category="cell">NFS 导出的大小，例如 `100Gi` 。</block>
  <block id="2ab80b6965298dc6a178995bbedebe88" category="paragraph">如果 OpenShift 集群已在运行，因此已部署和配置 Trident ，则安装程序可以使用动态配置来创建卷。需要配置以下变量。</block>
  <block id="c2aecf833d743cbc47969cd85c67101e" category="cell">`OpenShift_logging_es_vc_dynamic`</block>
  <block id="540ad9a52084720ddb7f364fa8b304c6" category="cell">设置为 true 可使用动态配置的卷。</block>
  <block id="45a481a75749c5331e7e9fd7d89e473d" category="cell">`OpenShift_logging_es_vc_storage_class_name`</block>
  <block id="837ffa1e281409660ed25582c5b1963f" category="cell">要在 PVC 中使用的存储类的名称。</block>
  <block id="cd3daa927272b5624e96d283365d5500" category="cell">`OpenShift_logging_es_vc_size`</block>
  <block id="8f80d278a79cbc84b80a091713006022" category="cell">在 PVC 中请求的卷大小。</block>
  <block id="1bb0c7eeef4bbbefae080a294fd554b0" category="cell">`OpenShift_logging_es_vc_prefix`</block>
  <block id="f870ec92e294a018a17afe7a614fb5bb" category="cell">日志记录服务使用的 PVC 的前缀。</block>
  <block id="e8c62e1f0f0773ae5ba6a7acad696b2d" category="cell">`OpenShift_logging_es_ops_vc_dynamic`</block>
  <block id="46e65a11ac398c02b8fce45a7cd5cf36" category="cell">设置为 `true` 可对操作日志记录实例使用动态配置的卷。</block>
  <block id="8792c7234e14325cb68c493d20ab5154" category="cell">`OpenShift_logging_es_ops_vc_storage_class_name`</block>
  <block id="d016f79f0ee104f3805d61e6a379fb9b" category="cell">操作日志记录实例的存储类的名称。</block>
  <block id="048e768365962d7d520567f92aea8355" category="cell">`OpenShift_logging_es_ops_vc_size`</block>
  <block id="bc367f89ac597585e52d0eb58a5929ae" category="cell">操作实例的卷请求大小。</block>
  <block id="155871626071d69cb283985a9f36bad2" category="cell">`OpenShift_logging_es_ops_vc_prefix`</block>
  <block id="2a8f254749a466654f556c6466051133" category="cell">操作实例 PVC 的前缀。</block>
  <block id="e1b2d0d3228c29c069bcd139de306709" category="section-title">部署日志记录堆栈</block>
  <block id="0409a0cfdfa4f3b3033503b8309442ff" category="paragraph">如果要在初始 OpenShift 安装过程中部署日志记录，则只需遵循标准部署过程即可。Ansible 将配置和部署所需的服务和 OpenShift 对象，以便在 Ansible 完成后立即提供此服务。</block>
  <block id="210ecadaccb6088b0dfbd2e6a0b5d0a0" category="inline-link-macro">RedHat OpenShift Container Platform 3.11 文档</block>
  <block id="67f3e99678cc7c568f4ed29074cdc41c" category="paragraph">但是，如果在初始安装后进行部署，则 Ansible 需要使用组件攻略手册。此过程可能会因 OpenShift 的不同版本而略有变化，因此请务必阅读并遵循 <block ref="a2226808e95b8487c66dd3b8cbea118e" category="inline-link-macro-rx"></block> 适用于您的版本。</block>
  <block id="3dbf527ac3caf41ab150ec99a1737217" category="section-title">指标服务</block>
  <block id="12a5438ab4c44c9ad4dec6edc191eb7a" category="paragraph">指标服务可为管理员提供有关 OpenShift 集群的状态，资源利用率和可用性的宝贵信息。此外， POD 自动调整功能也需要使用此功能，许多组织会将来自指标服务的数据用于其成本分摊和 / 或成本分摊应用程序。</block>
  <block id="d0ed828e153e9bad2da040ddf6ad8f45" category="paragraph">与日志记录服务和 OpenShift 作为一个整体一样， Ansible 用于部署指标服务。此外，与日志记录服务一样，可以在集群初始设置期间或使用组件安装方法运行之后部署指标服务。下表包含在为指标服务配置永久性存储时非常重要的变量。</block>
  <block id="69aa4440020e49c654aeb910f38c6bb9" category="admonition">下表仅包含与存储配置相关的变量，因为这些变量与指标服务相关。文档中还有许多其他选项，应根据您的部署情况进行查看，配置和使用。</block>
  <block id="4f692d78f978a73b157571022c1d1ba7" category="cell">`OpenShift_metrics_storage_kind`</block>
  <block id="30da7e263c0cffc34933d24a07fb097a" category="cell">`OpenShift_metrics_storage_host`</block>
  <block id="adba8dd7dd2b027405b815c03a05dbf1" category="cell">NFS 主机的主机名或 IP 地址。此值应设置为 SVM 的数据 LIF 。</block>
  <block id="3bafc264ad2a901d3be052a7f1cf2e44" category="cell">`OpenShift_metrics_storage_nfs_directory`</block>
  <block id="459859e54ba90bc4145c54d1f1deecff" category="cell">NFS 导出的挂载路径。例如，如果卷接合为 ` /OpenShift_metrics` ，则您将使用该路径作为此变量。</block>
  <block id="ca0f0d82f9c7cbc36df652cddd4b2f35" category="cell">`OpenShift_metrics_storage_volume_name`</block>
  <block id="eb10d02b22b02d7f543f867b8d31e7b0" category="cell">要创建的 PV 的名称，例如 `PV_ose_metrics` 。</block>
  <block id="a3eeeafe923ac73e75b3bf33cdadb603" category="cell">`OpenShift_metrics_storage_volume_size`</block>
  <block id="a56c731cfe96d228c7c0bcc57bc80d3d" category="cell">`OpenShift_metrics_Cassandra_vc_prefix`</block>
  <block id="0da919d4045e4f38d294aaec73f5d57f" category="cell">用于衡量指标 PVC 的前缀。</block>
  <block id="15bb3eef0b42a93e324977c289f2fd85" category="cell">`OpenShift_metrics_Cassandra_vc_size`</block>
  <block id="75929c9d67f1407282b5618fca4589e7" category="cell">要请求的卷的大小。</block>
  <block id="8ebb493e0ffdf7c1e850c67bc22f15c7" category="cell">`OpenShift_metrics_Cassandra_storage_type`</block>
  <block id="aab0ec84a4da1dfd2b63896453f1e05d" category="cell">要用于度量指标的存储类型，必须将此类型设置为动态， Ansible 才能创建具有相应存储类的 PVC 。</block>
  <block id="460aaf3805271ec2e5dc35755fe317b1" category="cell">`OpenShift_metrics_cassanda_vc_storage_class_name`</block>
  <block id="0c55ca33e89539cd67eb0be3796547c5" category="cell">要使用的存储类的名称。</block>
  <block id="6c13e62eb53f29e7794d3807369299d2" category="section-title">部署指标服务</block>
  <block id="3e75d51468f5a99fdb50b75dafea32e8" category="paragraph">使用在主机 / 清单文件中定义的适当 Ansible 变量，使用 Ansible 部署服务。如果您在 OpenShift 安装时进行部署，则系统将自动创建和使用 PV 。如果您使用组件攻略手册进行部署，则在 OpenShift 安装之后， Ansible 将创建所需的任何 PVC ，并在 Astra Trident 为其配置存储后部署该服务。</block>
  <block id="bf1cadd7aa4e541e255df26af5451d85" category="inline-link-macro">RedHat 的 OpenShift 部署指南</block>
  <block id="eb502d6483a644e9b6f61ca4719276d8" category="paragraph">上述变量以及部署过程可能会随 OpenShift 的每个版本而发生变化。确保您查看并遵循 <block ref="5ad72ffc1eda2c257c8947a0ad66dddb" category="inline-link-macro-rx"></block> 为您的版本配置，以便为您的环境进行配置。</block>
  <block id="d03f8f06d8317baa619ceba8c71e0be3" category="summary">了解 NetApp 存储平台提供的数据保护和可恢复性选项。Astra Trident 可以配置可利用其中某些功能的卷。对于具有持久性要求的每个应用程序，您都应制定完整的数据保护和恢复策略。</block>
  <block id="7e7397a7b79323762c61941fc0e6b5f9" category="doc">数据保护</block>
  <block id="cfee9077e497a91b77466a20f58fcdff" category="paragraph">了解 NetApp 存储平台提供的数据保护和可恢复性选项。Astra Trident 可以配置可利用其中某些功能的卷。对于具有持久性要求的每个应用程序，您都应制定一个数据保护和恢复策略。</block>
  <block id="058d5afd2ccf1b3be426f9ad27ab2f41" category="section-title">备份 etcd 集群数据</block>
  <block id="26beed33bbef26c53a76c2b450d8092c" category="paragraph">Astra Trident 会将其元数据存储在 Kubernetes 集群的 `etcd` 数据库中。定期备份 `etcd` 集群数据对于在发生灾难时恢复 Kubernetes 集群非常重要。</block>
  <block id="f3a29486bed19a90f2da6d007818b427" category="list-title">步骤</block>
  <block id="6b8252dd799aef1e72351975d4d39231" category="list-text">使用 `etcdctl snapshot save` 命令可以为 `etcd` 集群创建时间点快照：</block>
  <block id="54466a78f910aa9c206047e0a2afdae1" category="paragraph">此命令通过旋转 etcd 容器来创建 etcd 快照，并将其保存在 ` /backup` 目录中。</block>
  <block id="1475db623f0eaa95e737c3463bae738f" category="list-text">发生灾难时，您可以使用 etcd 快照启动 Kubernetes 集群。使用 `etcdctl snapshot restore` 命令还原为 ` /var/lib/etcd` 文件夹创建的特定快照。还原后，确认 ` /var/lib/etcd` 文件夹是否已填充 `mMember` 文件夹。以下是 `etcdctl snapshot restore` 命令的示例：</block>
  <block id="79ddedac8d398dd5b0c07d4319dcc009" category="list-text">在初始化 Kubernetes 集群之前，请复制所有必要的证书。</block>
  <block id="bdad273c35514cf4ff054dc686b32002" category="list-text">使用 `` -ignore-prefly-errors=DirAvailable-var-lib-etcd`` 标志创建集群。</block>
  <block id="6305ecb03aa7de9ef25f8415e859ea4b" category="list-text">集群启动后，请确保 Kube-system Pod 已启动。</block>
  <block id="8c416419987890cfcc65ea9e92da3cfa" category="list-text">使用 `kubectl get crd` 命令验证 Trident 创建的自定义资源是否存在，并检索 Trident 对象以确保所有数据均可用。</block>
  <block id="e5356885fecc2a90a54498a26b14b810" category="section-title">使用 ONTAP 快照恢复日期</block>
  <block id="c311aef86a7cd24a1d8755988091889b" category="paragraph">快照通过为应用程序数据提供时间点恢复选项发挥着重要作用。但是，快照本身并不是备份，它们无法防止存储系统故障或其他灾难。但是，在大多数情况下，它们是一种方便，快速和轻松的数据恢复方式。了解如何使用 ONTAP 快照技术为卷创建备份以及如何还原这些备份。</block>
  <block id="f0587fe4869074d7cfefe4e8bf02eaeb" category="list-text">如果未在后端定义 Snapshot 策略，则默认使用 `none` 策略。这会导致 ONTAP 不会自动创建快照。但是，存储管理员可以通过 ONTAP 管理界面手动创建快照或更改快照策略。这不会影响 Trident 操作。</block>
  <block id="a5198a3ff669782d450e222946ec0482" category="list-text">默认情况下， Snapshot 目录处于隐藏状态。这有助于最大程度地兼容使用 `ontap-NAS` 和 `ontap-nas-经济` 驱动程序配置的卷。使用 `ontap-nas` 和 `ontap-nas-economy` 驱动程序时，请启用 ` .snapshot` 目录，以使应用程序能够直接从快照恢复数据。</block>
  <block id="d34d16e8f00776a7cc63851ebd4e9395" category="list-text">使用 `volume snapshot restore` ONTAP 命令行界面命令将卷还原到先前快照中记录的状态。还原快照副本时，还原操作会覆盖现有卷配置。创建 Snapshot 副本后对卷中数据所做的任何更改都将丢失。</block>
  <block id="3225a41cc13787a78ef89153b870bffe" category="section-title">使用 ONTAP 复制数据</block>
  <block id="5bec6ef5bd67015d1da2f04dc2a24b80" category="paragraph">复制数据在防止存储阵列故障导致的数据丢失方面发挥着重要作用。</block>
  <block id="eb75aeb3b4b2b9734ba3e52f5483f0b2" category="inline-link">ONTAP 文档</block>
  <block id="40491088e02d790071b9ddbc3f95f983" category="admonition">要了解有关 ONTAP 复制技术的详细信息，请参见<block ref="dd7cb2553dd5eb568b9a23ce332fc9a4" category="inline-link-rx"></block>。</block>
  <block id="541959f741a3180066a37aee2adf7d01" category="section-title">SnapMirror Storage Virtual Machine （ SVM ）复制</block>
  <block id="794cb725c5631ad99b5b7c000307f0df" category="inline-link">SnapMirror</block>
  <block id="15bf9c06ed0c503c4ee904bf4b3a85a9" category="paragraph">您可以使用<block ref="a2a4907c93db22784422a1bc7047ac73" category="inline-link-rx"></block> 复制完整的 SVM ，其中包括其配置设置及其卷。发生灾难时，您可以激活 SnapMirror 目标 SVM 以开始提供数据。系统还原后，您可以切换回主系统。</block>
  <block id="8657190fa7a98fbc200c5c90a08cac65" category="paragraph">Astra Trident 无法自行配置复制关系，因此存储管理员可以使用 ONTAP 的 SnapMirror SVM 复制功能将卷自动复制到灾难恢复（ Disaster Recovery ， DR ）目标。</block>
  <block id="bdb161b363522f5fc614f70c10792020" category="paragraph">如果您计划使用 SnapMirror SVM 复制功能或当前正在使用此功能，请考虑以下事项：</block>
  <block id="34fb9af35ab36a2cead16ad98b140441" category="list-text">您应为每个 SVM 创建一个单独的后端，此后端已启用 SVM-DR 。</block>
  <block id="1c0b44a5294fd1ebbc8e78476cf29358" category="list-text">您应配置存储类，以便在需要时不选择复制的后端。这一点对于避免将不需要复制关系保护的卷配置到支持 SVM-DR 的后端非常重要。</block>
  <block id="21f180602301e7ac5b6cce6b6b7399e9" category="list-text">应用程序管理员应了解与复制数据相关的额外成本和复杂性，在利用数据复制之前，应确定恢复计划。</block>
  <block id="59b50d3d22a40bf39d0e648e2d49092c" category="list-text">在激活 SnapMirror 目标 SVM 之前，请停止所有计划的 SnapMirror 传输，中止所有正在进行的 SnapMirror 传输，中断复制关系，停止源 SVM ，然后启动 SnapMirror 目标 SVM 。</block>
  <block id="7cf7bfd0b57a375894c362efd521d4a6" category="list-text">Astra Trident 不会自动检测 SVM 故障。因此，发生故障时，管理员应运行 `tridentctl backend update` 命令以触发 Trident 向新后端的故障转移。</block>
  <block id="1904adbabdda29d7a5ab43352f36c6ed" category="paragraph">下面简要介绍了 SVM 设置步骤：</block>
  <block id="3c2f5fc4909af1c1359e564eb6db48b0" category="list-text">在源和目标集群以及 SVM 之间设置对等关系。</block>
  <block id="3b1329fc73441b5a106271d6f3497f1e" category="list-text">使用 ` 子类型 dp-destination` 选项创建目标 SVM 。</block>
  <block id="2ce677015d60734da686668ee7962dd0" category="list-text">创建复制作业计划以确保按所需时间间隔进行复制。</block>
  <block id="e9eeea68d62192550b641463a212f6f7" category="list-text">使用 ` -identity-preserve true` 选项创建从目标 SVM 到源 SVM 的 SnapMirror 复制，以确保将源 SVM 配置和源 SVM 接口复制到目标。从目标 SVM 初始化 SnapMirror SVM 复制关系。</block>
  <block id="fb45980442af5aaba98c4d47ae4d3bfd" category="image-alt">显示了设置 SVM 所涉及的步骤。</block>
  <block id="1e4e7c145198bb50a238b75b451a761f" category="section-title">Trident 的灾难恢复工作流</block>
  <block id="b955e2b8063ba57e27a4ab2b5317f40c" category="paragraph">Astra Trident 19.07 及更高版本使用 Kubernetes CRD 存储和管理其自身状态。它使用 Kubernetes 集群的 `etcd` 存储其元数据。此处我们假定 Kubernetes `etcd` 数据文件和证书存储在 NetApp FlexVolume 上。此 FlexVolume 驻留在 SVM 中， SVM 与二级站点的目标 SVM 具有 SnapMirror SVM-DR 关系。</block>
  <block id="cc457da166ae89d5689724340cb13732" category="paragraph">以下步骤介绍如何在发生灾难时使用 Astra Trident 恢复单个主 Kubernetes 集群：</block>
  <block id="53ac5e7226086e14e63a8c160480dc72" category="list-text">如果源 SVM 发生故障，请激活 SnapMirror 目标 SVM 。为此，您应停止计划的 SnapMirror 传输，中止正在进行的 SnapMirror 传输，中断复制关系，停止源 SVM 并启动目标 SVM 。</block>
  <block id="2e22b90c5468159621965197ed565e28" category="list-text">从目标 SVM 中，将包含 Kubernetes `etcd` 数据文件和证书的卷挂载到要设置为主节点的主机上。</block>
  <block id="40d502a83976e38daa5473f7aa22abae" category="list-text">将与 Kubernetes 集群相关的所有必需证书复制到 ` /etc/Kubernetes /PKI` 下，并将 etcd `mMember` files 复制到 ` /var/lib/etcd` 下。</block>
  <block id="ca8fc386b365ae9b5a3b4bbadae7d7f3" category="list-text">使用 `kubeadm init` 命令和 ` -ignore-prefly-errors=DirAvailable-var-lib/etcd` 标志创建 Kubernetes 集群。Kubernetes 节点使用的主机名应与源 Kubernetes 集群相同。</block>
  <block id="e0e99766128c0aba0f0aa6c04f32348c" category="list-text">运行 `kubectl get crd` 命令验证所有 Trident 自定义资源是否均已启动并检索 Trident 对象以验证所有数据是否可用。</block>
  <block id="5a869093fda46649157b8eb12219a2f2" category="list-text">运行 ` ./tridentctl update backend &lt;backend-name&gt; -f &lt;backend-json-file&gt; -n &lt;namespace&gt;` 命令，更新所有必需的后端以反映新的目标 SVM 名称。</block>
  <block id="dbd1e2ae426afc58b4818d42ea354b74" category="admonition">对于应用程序永久性卷，激活目标 SVM 后，由 Trident 配置的所有卷将开始提供数据。按照上述步骤在目标端设置 Kubernetes 集群后，所有部署和 Pod 均会启动，容器化应用程序应正常运行。</block>
  <block id="d384359ca03c8d46191c719c57744679" category="section-title">SnapMirror 卷复制</block>
  <block id="118fa9a7e0f8d0db1e27394b81880427" category="paragraph">ONTAP SnapMirror 卷复制是一项灾难恢复功能，可用于在卷级别从主存储故障转移到目标存储。SnapMirror 通过同步快照在二级存储上创建主存储的卷副本或镜像。</block>
  <block id="19f60a36276037e5b82b5096d2ba7a5c" category="paragraph">下面简要介绍了 ONTAP SnapMirror 卷复制设置步骤：</block>
  <block id="c4e9d0a10c58301ad78e9e9bf74f9229" category="list-text">在卷所在的集群与从卷提供数据的 SVM 之间设置对等关系。</block>
  <block id="b1c132fa6284fd6d42f93781032cd962" category="list-text">创建一个 SnapMirror 策略，用于控制关系的行为并指定该关系的配置属性。</block>
  <block id="d9934e78a9254dde4a227181c30fa2d2" category="inline-link">`snapmirror create` 命令</block>
  <block id="0a30bcd5b223c18be449821765a8ec07" category="list-text">使用在目标卷和源卷之间创建 SnapMirror 关系<block ref="bfbfdbcdb00ddafcc3e3ca740d1d316b" category="inline-link-rx"></block> 并分配相应的 SnapMirror 策略。</block>
  <block id="20872623d19783e0dbe00afcdcb9ba46" category="list-text">创建 SnapMirror 关系后，初始化此关系，以便完成从源卷到目标卷的基线传输。</block>
  <block id="af1fe101ed84f2b2bc465f0a9e92a35f" category="image-alt">显示了 SnapMirror 卷复制设置。</block>
  <block id="1d3ec4cce0f34c07e814ebbd88f5edd8" category="section-title">Trident 的 SnapMirror 卷灾难恢复工作流</block>
  <block id="83e05258883cd6b92e2fe5b113f1ebc6" category="paragraph">以下步骤介绍如何使用 Astra Trident 恢复单个主 Kubernetes 集群。</block>
  <block id="b950aff3484c4c998d3b7a36ff1d6553" category="list-text">发生灾难时，停止所有计划的 SnapMirror 传输并中止所有正在进行的 SnapMirror 传输。中断目标卷和源卷之间的复制关系，使目标卷变为读 / 写卷。</block>
  <block id="521637d2f234b6223688c168d29f6b72" category="list-text">从目标 SVM 中，将包含 Kubernetes `etcd` 数据文件和证书的卷挂载到将设置为主节点的主机上。</block>
  <block id="d911c905c09c9615d35c97f404dd2884" category="list-text">通过运行 `kubeadm init` 命令和 ` -ignore-prefly-errors=DirAvailable-var-lib/etcd` 标志来创建 Kubernetes 集群。主机名应与源 Kubernetes 集群相同。</block>
  <block id="4b4d4e6a1634d2560e81a9a1821e2818" category="list-text">运行 `kubectl get crd` 命令以验证所有 Trident 自定义资源是否均已启动并检索 Trident 对象，以确保所有数据均可用。</block>
  <block id="4f04020fc477f4ade26e46ae0ba44688" category="list-text">清理先前的后端并在 Trident 上创建新的后端。指定目标 SVM 的新管理和数据 LIF ，新 SVM 名称和密码。</block>
  <block id="f4a5d35c2f46c3a6ee69fd6aa2d1ed16" category="section-title">应用程序永久性卷的灾难恢复工作流</block>
  <block id="77983829e737f00a29b43edacbba355e" category="paragraph">以下步骤介绍了在发生灾难时如何为容器化工作负载提供 SnapMirror 目标卷：</block>
  <block id="aefd7239e178b3ae439ae7004435bd18" category="list-text">停止所有计划的 SnapMirror 传输并中止所有正在进行的 SnapMirror 传输。中断目标卷和源卷之间的复制关系，使目标卷变为读 / 写卷。清理使用与源 SVM 上的卷绑定的 PVC 的部署。</block>
  <block id="c64f364f814f31948e0882b74d5ddfe1" category="list-text">按照上述步骤在目标端设置 Kubernetes 集群后，请从 Kubernetes 集群中清理部署， PVC 和 PV 。</block>
  <block id="6973ba748ea89f06ab3640118969d780" category="list-text">通过指定目标 SVM 的新管理和数据 LIF ，新 SVM 名称和密码，在 Trident 上创建新的后端。</block>
  <block id="1fd415590fff525d8e3562951ed79081" category="list-text">使用 Trident 导入功能将所需卷作为 PV 导入，并绑定到新 PVC 。</block>
  <block id="99a01026c124f91b08d854efa31d450b" category="list-text">使用新创建的 PVC 重新部署应用程序部署。</block>
  <block id="7a183359334a99fc80b796244313284c" category="section-title">使用 Element 快照恢复数据</block>
  <block id="2d51cea50aa816e6be9c663c2ad2686a" category="paragraph">通过为 Element 卷设置快照计划并确保按所需间隔创建快照来备份此卷上的数据。您应使用 Element UI 或 API 设置快照计划。目前，无法通过 `solidfire-san` 驱动程序为卷设置快照计划。</block>
  <block id="c42cc84c1560600f6f5986a958de0735" category="paragraph">如果发生数据损坏，您可以使用 Element UI 或 API 选择特定快照并手动将卷回滚到快照。此操作将还原自创建快照以来对卷所做的任何更改。</block>
  <block id="e20acf6d4b1275a0b5d2eb01c845adff" category="summary">NetApp 以多种方式为 Trident 提供支持。全天候提供广泛的免费自助支持选项，例如，可提供宽松通道。</block>
  <block id="db5eb84117d06047c97c9a0191b5fffe" category="doc">支持</block>
  <block id="14340f3a4eb25a54f8446036d807d7c8" category="paragraph">Astra Trident 是一个官方支持的 NetApp 项目。您可以使用任何标准机制联系 NetApp ，并获得所需的企业级支持。</block>
  <block id="31521e7ff20a98e479b412febf1ac4b4" category="inline-link">NetApp 的工作时间很长</block>
  <block id="b622c74429f1282e8ed1f79ee8d53260" category="paragraph">此外，在 `containers` Channel on 上还有一个由容器用户（包括 Astra Trident 开发人员）组成的活跃公有社区<block ref="e5c49b87a1fe6d362b72260d2620cf35" category="inline-link-rx"></block>。这是一个很好的地方，可以提出有关项目的一般问题，并与志同道合的同行讨论相关主题。</block>
  <block id="dec54888538ac86f51d29a3d043e6bf6" category="summary">您可以使用操作员轻松升级现有的 Astra Trident 安装。</block>
  <block id="5ff3faebb0ff710340bdbee89a4667ad" category="doc">使用操作员升级</block>
  <block id="b8ce48f9165ac0cead930cd72b36b5ac" category="paragraph">要使用运算符进行升级，应满足以下条件：</block>
  <block id="933c98c07c43994c690a4d57fff2fd1f" category="list-text">您应安装基于 CSI 的 Astra Trident 。要检查是否正在运行 CSI Trident ，请检查 Trident 命名空间中的 Pod 。如果它们遵循 `trident CSI - *` 命名模式，则表示您正在运行 CSI Trident 。</block>
  <block id="b53958f3b6708eb5412679540db1febc" category="list-text">您应安装基于 CRD 的 Trident 。这表示 19.07 及更高版本的所有版本。如果您安装的是基于 CSI 的安装，则很可能是基于 CRD 的安装。</block>
  <block id="ba45a58fb6371fc5a91fb8a5d399becd" category="list-text">如果您已卸载 CSI Trident ，并且安装中的元数据仍然存在，则可以使用操作员进行升级。</block>
  <block id="33deedceb6eaeb2f124b7ce830e212a8" category="list-text">在给定 Kubernetes 集群中的所有命名空间中，只应安装一个 Astra Trident 。</block>
  <block id="f6c44c912e06b8221085c219600c6387" category="inline-link-macro">1.17 及更高版本</block>
  <block id="0805928cc4c4b801e682a6cd2006e692" category="list-text">您应使用运行的 Kubernetes 集群 <block ref="b1e96583006584730c41f3baa3725240" category="inline-link-macro-rx"></block>。</block>
  <block id="f5d517b06fc0b1af5d599776e2f6f1d6" category="inline-link">本博客</block>
  <block id="093e1971a4b17fce7e3e4d94854a46ba" category="list-text">如果存在字母快照 CRD ，则应使用 `tridentctl obliviate alpha-snapshot-crd` 将其删除。此操作将删除 alpha snapshot 规范的 CRD 。有关应删除 / 迁移的现有快照，请参见<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block>。</block>
  <block id="199ed8c975e8bb544d18428ba17adbc3" category="inline-link">GitHub 上的问题描述详细信息</block>
  <block id="398b69b685d2969c9e5d2f8cfbff3972" category="admonition">在 OpenShift 容器平台上使用操作符升级 Trident 时，应升级到 Trident 21.01.1 或更高版本。21.01.0 版发布的 Trident 运算符包含一个已知的问题描述，该 已在 21.01.1 中修复。有关详细信息，请参见<block ref="bcebcdd21adcbb3d7c640d63a711c6fb" category="inline-link-rx"></block>。</block>
  <block id="2f6881ec6a84d1ac9ef2e551f3ca8466" category="section-title">升级集群范围的操作员安装</block>
  <block id="532223fc600c8862511462ff30738c55" category="paragraph">要从 * Trident 21.01 及更高版本 * 升级，请执行以下步骤。</block>
  <block id="238e63aecc23c1bc2611ca883f075f1f" category="list-text">删除用于安装当前 Astra Trident 实例的 Trident 运算符。例如，如果要从 21.01 升级，请运行以下命令：</block>
  <block id="caa6267a6d2c9b631544a2ce0d5e4180" category="list-text">（可选）如果要修改安装参数，请编辑安装 Trident 时创建的 `TridentOrchestrator` 对象。这些更改可能包括修改自定义 Trident 映像，从中提取容器映像的专用映像注册表，启用调试日志或指定映像提取密钥等。</block>
  <block id="09b615e18699c6675b3705c00a495375" category="list-text">使用为新版本设置 Trident 操作符的 `bundle.yaml` 文件安装 Astra Trident 。运行以下命令：</block>
  <block id="d06b5297af318d2581021098f6b0d44d" category="section-title">升级命名空间范围的操作员安装</block>
  <block id="ddfa75d059a999aedec16392aae03bc4" category="paragraph">要从使用命名空间范围的运算符（版本 20.07 至 20.10 ）安装的 Astra Trident 实例进行升级，需要遵循以下步骤：</block>
  <block id="edf5c542759186ded2c7eeaae6b340a5" category="list-text">验证现有 Trident 安装的状态。要执行此操作，请检查 `TridentProvider` 的 * 状态 * 。状态应为 `installed` 。</block>
  <block id="683d018a2f7c70469fd74ba0eeae2a79" category="list-text">使用 Trident 安装程序随附的清单创建 `TridentOrchestrator` CRD 。</block>
  <block id="ede3d39a1c5211985b126b3f166cf601" category="inline-link">Trident 存储库</block>
  <block id="af39f09efb6e7b7133433dff92d0fffe" category="list-text">使用其清单删除命名空间范围的运算符。要完成此步骤，您需要使用 `bundle.yaml` 文件来部署命名空间范围的运算符。您可以从获取 `bundle.yaml`<block ref="1403b813895a8a78c447fca96240f2ac" category="inline-link-rx"></block>。请确保使用相应的分支。</block>
  <block id="5451265740f1553dff7af7814faa5277" category="inline-link-macro">参数列表</block>
  <block id="8afea862003d4f613fcffecc022fb20c" category="admonition">在删除命名空间范围的运算符后以及安装集群范围的运算符之前，您应对 Trident 安装参数进行必要的更改（例如，更改 `tridentImage` ， `autosupportImage` ，私有映像存储库以及提供 `imagePullSecs` 的值）。有关可更新的参数的完整列表，请参见 <block ref="e5ef433069537d0999d9cf3f906affdb" category="inline-link-macro-rx"></block>。</block>
  <block id="5fbede7820945c99130183fd2fd0f4b3" category="paragraph">此时，将删除 `trident 操作符 -xxxxxx-xxxxx` Pod 。</block>
  <block id="86463d362af5835ff8c3fd6587fbd24f" category="list-text">（可选）如果需要修改安装参数，请更新 `TridentProvider` 规范。这些更改可能包括修改私有映像注册表以从中提取容器映像，启用调试日志或指定映像提取密钥等。</block>
  <block id="df486b34cec5fdfba24de79fe6b388d4" category="list-text">安装集群范围的运算符。</block>
  <block id="d5eded1a43812da779b35ffbffedf46b" category="admonition">安装集群范围的运算符会启动将 `TridentProvider` 对象迁移到 `TridentOrchestrator` 对象的操作，删除 `TridentProvider` 对象和 `tridentProvisioner` CRD ，并将 Astra Trident 升级到所使用的集群范围运算符版本。在以下示例中， Trident 会升级到 21.07.1 。</block>
  <block id="cb84f171610775cc6f9d39511d6acee9" category="admonition">使用集群范围的运算符升级 Astra Trident 会将 `tridentProvider` 迁移到同名的 `tridentOrchestrator` 对象。此操作由操作员自动处理。在升级过程中， Astra Trident 也会安装在与之前相同的命名空间中。</block>
  <block id="61d74cfa0c3f53abef0b4694fba0522f" category="section-title">升级基于 Helm 的操作员安装</block>
  <block id="7734dd866cc8c135256bad90520fa719" category="paragraph">要升级基于 Helm 的操作员安装，请执行以下步骤。</block>
  <block id="3002cfcea36b7fb4d87da4d413730851" category="list-text">下载最新的 Astra Trident 版本。</block>
  <block id="2171a3791b6ac570c7910a5d1d7f4d89" category="list-text">使用 `helm upgrade` 命令。请参见以下示例：</block>
  <block id="00bca5f1181617a563b71b78a27434d0" category="paragraph">其中 `trident 操作符 -21.071.tgz` 反映了要升级到的版本。</block>
  <block id="1869e61179995eed8692bfc705434d2b" category="list-text">运行 `Helm list` 以验证图表和应用程序版本均已升级。</block>
  <block id="1d0b5ffc29a6dba36314ccbba6a46038" category="admonition">要在升级期间传递配置数据，请使用 ` -set` 。</block>
  <block id="4a6b869a481b52472aa62cfa4d9d255e" category="paragraph">例如，要更改默认值 `tridentDebug` ，请运行以下命令：</block>
  <block id="6b30e95bff9143b45494dd9486e9515d" category="paragraph">如果您运行的是 ` $tridentctl logs` ，则可以看到调试消息。</block>
  <block id="ad00f75f90e86259efc5e8512fe4c23a" category="admonition">如果在初始安装期间设置了任何非默认选项，请确保这些选项包含在 upgrade 命令中，否则，这些值将重置为其默认值。</block>
  <block id="5c83dd886f5edc620e809e7800bc225f" category="section-title">从非操作员安装升级</block>
  <block id="69f43f0aadf9091408f80d6d1e0fdd45" category="paragraph">如果您的 CSI Trident 实例满足上述前提条件，则可以升级到最新版本的 Trident 操作符。</block>
  <block id="4ab464bddccdcbc36fab4cea802025f9" category="list-text">从清单中创建 `tridentorchator` CRD 。</block>
  <block id="835fd860290737b70acf870a253c3549" category="list-text">部署操作员。</block>
  <block id="06da281bf5e01c3c59892dc886cd0067" category="list-text">创建 `TridentOrchestrator` CR 以安装 Astra Trident 。</block>
  <block id="f420eb91a420c03f1792a6504b30277b" category="paragraph">现有后端和 PVC 会自动可用。</block>
  <block id="1e209c07680392db2505687941188c9f" category="summary">了解降级到早期版本的 Astra Trident 所涉及的步骤。</block>
  <block id="9b51b245233e60555d569a43ebaa1b8d" category="doc">降级 Astra Trident</block>
  <block id="f58ee9343b12a3276981187a42480ba7" category="paragraph">您可能会考虑降级的各种原因，例如：</block>
  <block id="e930f1fff9365ca35f55f1e61bef69a9" category="list-text">应急规划</block>
  <block id="235115784feaabab0df1d64a2019b176" category="list-text">立即修复因升级而发现的错误</block>
  <block id="41768ab308324d6b4a49e2e225427666" category="list-text">依赖关系问题，升级失败和不完整</block>
  <block id="9bb6c30b6b6e3a9fbbd83b458a3556eb" category="section-title">何时降级</block>
  <block id="97442cfde1061a7c844e8d4c06f79720" category="paragraph">迁移到使用 CRD 的 Astra Trident 版本时，应考虑降级。由于 Astra Trident 现在使用 CRD 来保持状态，因此创建的所有存储实体（后端，存储类， PV 和卷快照）都已关联 CRD 对象，而不是写入到 `trident` PV （由早期安装的 Astra Trident 版本使用）中的数据。新创建的 PV ，后端和存储类均作为 CRD 对象进行维护。如果需要降级，则只能对使用 CRD （ 19.07 及更高版本）运行的 Astra Trident 版本尝试执行此操作。这是为了确保在降级后，当前 Astra Trident 版本上执行的所有操作均可见。</block>
  <block id="cb4d3c8706ed4dd2a49a007f19e8b30a" category="section-title">何时不降级</block>
  <block id="7be40d1b43eccf7d81bd7ad70a7cee5b" category="paragraph">您不应降级到使用 `etcd` 保持状态（ 19.04 及更早版本）的 Trident 版本。降级后，使用当前 Astra Trident 版本执行的所有操作都不会反映出来。在回滚到早期版本时，新创建的 PV 不可用。在迁移回早期版本时，对后端， PV ，存储类和卷快照（已创建 / 更新 / 删除）等对象所做的更改对 Astra Trident 不可见。恢复到早期版本不会中断对已使用早期版本创建的 PV 的访问，除非已对其进行升级。</block>
  <block id="716e6c4d72b03c2b5b4503d5e968e654" category="section-title">使用操作员安装 Astra Trident 时的降级过程</block>
  <block id="286ac65245e7b7508f3cdf1dea1c60eb" category="paragraph">对于使用 Trident 操作员完成的安装，降级过程有所不同，不需要使用 `tridentctl` 。</block>
  <block id="41cc548b7b7993679e555423a014ca5c" category="paragraph">对于使用 Trident 操作符完成的安装， Astra Trident 可以降级为以下任一项：</block>
  <block id="c3d92c281c17e41ffac420b45790ecbf" category="list-text">使用命名空间范围的运算符（ 20.07 - 20.10 ）安装的版本。</block>
  <block id="69f5b5f7aa4a5f07267b9c758e2580e6" category="list-text">使用集群范围运算符（ 21.01 及更高版本）安装的版本。</block>
  <block id="0d8778040c29d89141a733b060314da3" category="section-title">降级为集群范围的运算符</block>
  <block id="12a3bd4ff105bed8650ca128636a078f" category="paragraph">要将 Astra Trident 降级为使用集群范围运算符的版本，请执行以下步骤。</block>
  <block id="43f17763173fe230bdd78477152f5f7d" category="inline-link-macro">卸载 Astra Trident</block>
  <block id="f472e2d2602fec8483b064616fa5f543" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>。* 除非要完全删除现有安装，否则请勿删除这些 CRD</block>
  <block id="3864c0c37bf26f8a7686e5c04435974c" category="inline-link">Trident GitHub 报告</block>
  <block id="78a26b79451266c6562d8d11cdb86ad0" category="list-text">删除集群范围的运算符。为此，您需要使用清单来部署操作员。您可以从获取<block ref="08fa9926a4347665a77bd7911809a1ce" category="inline-link-rx"></block>。确保切换到所需的分支。</block>
  <block id="44d9737dc7f423d188a4b34663c5f06e" category="list-text">通过安装所需版本的 Astra Trident 继续降级。按照所需版本的文档进行操作。</block>
  <block id="0e792058c21e7156d25e8ae8f2d784a0" category="section-title">降级到命名空间范围的运算符</block>
  <block id="8ad79c030a4ebdd2f446157ba529561e" category="paragraph">本节总结了降级到 20.07 到 20.10 范围内的 Astra Trident 版本所涉及的步骤，该版本将使用命名空间范围的运算符进行安装。</block>
  <block id="a7c80f52f9be4831ca776b56dc642a45" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>。`除非要完全删除现有安装，否则请勿删除 CRD 。确保已删除` tridentOrchestrator 。</block>
  <block id="141ed8ae2dd3c3efac0c25f12b058c87" category="list-text">删除集群范围的运算符。为此，您需要使用清单来部署操作员。您可以从此处获取<block ref="08fa9926a4347665a77bd7911809a1ce" category="inline-link-rx"></block>。确保切换到所需的分支。</block>
  <block id="2389eabedca3341193952356ec53cd0c" category="list-text">删除 `tridentorchator` CRD 。</block>
  <block id="2982be9f91f77222d75873452bfc7696" category="paragraph">已卸载 Astra Trident 。</block>
  <block id="0f46a51f24c3700da8c74b9a5294a22f" category="list-text">通过安装所需版本继续降级。按照所需版本的文档进行操作。</block>
  <block id="5f7d982e216126a476d4ca0051837e2a" category="section-title">使用 Helm 降级</block>
  <block id="fe0182349853dde39c65151b592bc343" category="paragraph">要降级，请使用 `helm rollback` 命令。请参见以下示例：</block>
  <block id="6506fb901be776a97bf61f4f21fb84ce" category="section-title">使用 tridentctl 安装 Astra Trident 时的降级过程</block>
  <block id="d1008d4e2b1eb300375d48496c96e8b0" category="paragraph">如果您使用 `tridentctl` 安装了 Astra Trident ，则降级过程涉及以下步骤。此顺序将指导您完成从 Astra Trident 21.07 迁移到 20.07 的降级过程。</block>
  <block id="e08f959c89cb36ec887089ce4a7c1bcc" category="admonition">在开始降级之前，您应创建 Kubernetes 集群的 `etcd` 的快照。这样，您就可以备份 Astra Trident 的 CRD 的当前状态了。</block>
  <block id="e36e921de70428b33bb0e5c22f4f1d03" category="list-text">确保使用 `tridentctl` 安装 Trident 。如果您不确定如何安装 Astra Trident ，请运行以下简单测试：</block>
  <block id="d7c7b52356c18ead4409ef4ca7e2eac8" category="list-text">列出 Trident 命名空间中的 Pod 。</block>
  <block id="225b7f623c2562a1ed24395fd3852b70" category="list-text">确定集群中运行的 Astra Trident 的版本。您可以使用 `tridentctl` 或查看 Trident Pod 中使用的图像。</block>
  <block id="46da6852e307b4f4a0e965c9c18fe576" category="list-text">如果您 * 未看到 * a `tridentOrchestrator` ，（或） a `tridentprovisioner` ，（或）名为 `trident — operator-xxxxxxxxxx-xxxxx` 的 Pod ，则已安装 Astra Trident * 和 `tridentctl` 。</block>
  <block id="72b739b65841b5d903e9ec216f0c4fd1" category="list-text">使用现有的 `tridentctl` 二进制文件卸载 Astra Trident 。在这种情况下，您将使用 21.07 二进制文件卸载。</block>
  <block id="6445365d100b18e233ebf2d08d116aee" category="inline-link-macro">自定义安装</block>
  <block id="ca35ad40c102410833ee6b7227e3cfcc" category="list-text">完成此操作后，获取所需版本的 Trident 二进制文件（在此示例中为 20.07 ），并使用它安装 Astra Trident 。您可以为生成自定义 YAML <block ref="e519c8a747d0bcd553094af015469d7d" category="inline-link-macro-rx"></block> 如果需要，</block>
  <block id="03347682a0c8323a17a17933bbf4e18c" category="paragraph">降级过程已完成。</block>
  <block id="3a90bea856daf0616bcbdde1b9d9ad0b" category="summary">根据 Astra Trident 的安装方式，有多种卸载方法。</block>
  <block id="bdcf993f8f3d91925d60754cd864f3c0" category="section-title">使用 Helm 卸载</block>
  <block id="8656f6a3d04342ff6248bd7d32949c2a" category="paragraph">如果您使用 Helm 安装了 Astra Trident ，则可以使用 `helm uninstall` 将其卸载。</block>
  <block id="e2a3593a8e9900eadda10d47bc2ff47c" category="section-title">使用 Trident 操作符卸载</block>
  <block id="c416a70504ae36e8cfbf555ad0d13ab9" category="paragraph">如果您使用操作符安装了 Astra Trident ，则可以通过执行以下操作之一卸载它：</block>
  <block id="1159b3a6f6975215eaff7b18f9fdbe8e" category="list-text">`编辑` TridentOrchestrator `设置卸载标志： * 您可以编辑` TridentOrchestrator `s并设置` Pec.uninstall=true 。编辑 `TridentOrchestrator` CR 并设置 `uninstall` 标志，如下所示：</block>
  <block id="245e84de93b9b41f643f9e737c17e702" category="paragraph">当 `uninstall` 标志设置为 `true` 时， Trident 操作员将卸载 Trident ，但不会删除 Trident Orchestrator 本身。如果要重新安装 Trident ，应清理 Trident Orchestrator 并创建新的 Trident 。</block>
  <block id="a5e00cb8c456b8892f7af2349fe6e10a" category="list-text">`删除` TridentOrchestrator `： * 删除用于部署 Astra Trident 的` Trident Orchestrator CR 后，您可以指示操作员卸载 Trident 。操作员将处理 `TridentOrchestrator` 的删除，并继续删除 Astra Trident 部署和子集，同时删除在安装过程中创建的 Trident Pod 。要完全删除 Astra Trident （包括其创建的 CRD ）并有效地擦除板，您可以编辑 `TridentOrchestrator` 以传递 `wipeout` 选项。请参见以下示例：</block>
  <block id="8aaaff274ba10c527c6bf8facd1c9092" category="paragraph">这将完全卸载 Astra Trident 并清除与后端及其管理的卷相关的所有元数据。后续安装将视为全新安装。</block>
  <block id="1f119048e6c0b2f219b28b7efae30285" category="admonition">只有在执行完全卸载时，才应考虑擦除 CRD 。此操作无法撤消。* 除非您希望重新启动并创建全新的 Astra Trident 安装，否则请勿擦除 CRD 。</block>
  <block id="ed116003561aef0bea77cb4c5f6fe418" category="section-title">使用 tridentctl 卸载</block>
  <block id="20402206432f6b6e75899e8f585ae984" category="paragraph">在 `tridentctl` 中运行 `uninstall` 命令，如下所示删除除 CRD 和相关对象之外与 Astra Trident 关联的所有资源，从而可以轻松地重新运行安装程序以更新到最新版本。</block>
  <block id="1b600643682d5a3280681ef82d7e6ae4" category="paragraph">要完全删除 Astra Trident ，您应删除由 Astra Trident 创建的 CRD 的最终结果并删除这些 CRD 。</block>
  <block id="3bda6d3452a50ffddd40bb74b05d6c50" category="summary">Astra Trident 遵循季度发布节奏，每个日历年提供四个主要版本。每个新版本都是在先前版本的基础上构建的，可提供新功能和性能增强以及错误修复和改进功能。我们建议您每年至少升级一次，以利用 Astra Trident 中的新功能。</block>
  <block id="3386987a97643481040e99019808e020" category="doc">升级 Astra Trident</block>
  <block id="66bc438a5af66629e5b414e233cb5834" category="admonition">要升级到之前的五个版本，您需要执行多步升级。</block>
  <block id="d442f21894fbfe232b6d52b52a10ec35" category="section-title">确定要升级到的版本</block>
  <block id="fd6a74b5e363eaa218988afd6ae5140b" category="list-text">您可以从 `YY-1.mm` 版本和任何介于两者之间的版本升级到 `YY.mm` 版本。例如，您可以从 19.07 及更高版本直接升级到 20.07 （包括 DOT 版本，例如 19.07.1 ）。</block>
  <block id="daf61148013081df2c82930a3a46feb6" category="list-text">如果您使用的是早期版本，则应执行多步骤升级。这要求您首先升级到适合您的四个版本窗口的最新版本。例如，如果您运行的是 18.07 ，并希望升级到 20.07 版本，请按照以下所述执行多步骤升级过程：</block>
  <block id="6ed2af44865aa9f6dddcebd57d996cf1" category="list-text">首次从 18.07 升级到 19.07 。有关升级的具体说明，请参见相应版本的文档。</block>
  <block id="ff115c7087db60c699cccdb21f39ea66" category="list-text">然后从 19.07 升级到 20.07 。</block>
  <block id="8d66ed6671344ec6017707c38250329c" category="admonition">对于 19.04 及更早版本的所有升级，都需要将 Astra Trident 的元数据从其自身的 `etcd` 迁移到 CRD 对象。请务必查看此版本的文档，了解升级的工作原理。</block>
  <block id="558ab0bef1894a7a726109d36632d09d" category="inline-link-macro">已知问题</block>
  <block id="33966eba1ed0cde6afda5a97ffaffb09" category="inline-link">安全上下文</block>
  <block id="ceb268093ddd5aa9df1769eda5d1c8cd" category="inline-link">输入示例：</block>
  <block id="9d267d893296d1b56789c03ad196afc8" category="inline-link">`storage-class-basic 。 yaml.temp`</block>
  <block id="4e4578e23d9d48bd9338b1581f884392" category="inline-link">`storage-class-brone-default.yaml`</block>
  <block id="1ca02e26ff81cefae18a0a8d994ca94a" category="admonition">升级时，请务必提供 `parameter.FSType` in `StorageClasses` used by Astra Trident 。您可以删除并重新创建 `StorageClasses` ，而不会中断已有卷。这是执行的一项 * 要求 *<block ref="cafe4c6014d8c45aaac70e49318f1a2a" category="inline-link-rx"></block> SAN 卷。。<block ref="25daec0b57549a6ad43dbc62a9e717ca" category="inline-link-rx"></block> 目录包含示例，例如<block ref="d308f4d12b21bf269d64643e1eceeeb2" category="inline-link-rx"></block> 和<block ref="b6ff3ec2ac914a047085c08d5843e316" category="inline-link-rx"></block>。有关详细信息，请参见 <block ref="139a59f2208174d2bf825b80dc580275" category="inline-link-macro-rx"></block>。</block>
  <block id="17cfb8bd7f378fa26b63ee73d467cb82" category="section-title">我应选择哪种升级路径？</block>
  <block id="46940159293e259bcf0bb4df75448100" category="paragraph">您可以使用以下路径之一进行升级：</block>
  <block id="dc1a9a8ad35cc8aa946e0a2e3f959e2b" category="list-text">使用 Trident 运算符。</block>
  <block id="4b78e512c67306c61715208417a1cfd7" category="list-text">使用 `tridentctl` 。</block>
  <block id="756bc985c24584ee6c7338b28f771da8" category="admonition">从 Kubernetes 1.20 开始， CSI 卷快照现在是 GA 功能。在升级 Astra Trident 时，在执行升级之前，必须删除所有先前的 alpha snapshot CRS 和 CRD （卷快照类，卷快照和卷快照内容）。请参见<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block> 了解将 alpha 快照迁移到测试版 /GA 规范所涉及的步骤。</block>
  <block id="6958a3036b19c13782ecd0024d772b5f" category="paragraph">如果满足以下条件，则可以使用 Trident 操作符进行升级：</block>
  <block id="9f5cdec8485f67ded88c50f021a562e1" category="list-text">您正在运行 CSI Trident （ 19.07 及更高版本）。</block>
  <block id="e682693c5c270204af79541caa0e63ba" category="list-text">您已安装基于 CRD 的 Trident 版本（ 19.07 及更高版本）。</block>
  <block id="4a0e21a0d69199588534154f29f4af94" category="list-text">您正在执行自定义安装（使用自定义 YAML ）。</block>
  <block id="3814df1eaf856112f1f0b22f7f0600e5" category="admonition">如果您使用的是基于 `etcd` 的 Trident 版本（ 19.04 或更早版本），请勿使用运算符升级 Trident 。</block>
  <block id="773f6f7f15c751e861d5494e4d510675" category="paragraph">如果您不想使用该运算符，或者您的自定义安装操作符不支持，则可以使用 `tridentctl` 进行升级。这是 Trident 19.04 及更早版本的首选升级方法。</block>
  <block id="152a676ac450f5b96a35605dde352607" category="section-title">对运算符进行了更改</block>
  <block id="fc7e892a21e797d0592360430a5deedd" category="paragraph">Astra Trident 21.01 版为操作员引入了一些关键的架构变更，即：</block>
  <block id="4d1b9ac70f0037098e345cb389ea45d9" category="list-text">操作符现在为 * 集群范围 * 。以前的 Trident 运算符实例（版本 20.04 到 20.10 ）为 * 命名空间范围 * 。集群范围内的运算符具有优势，原因如下：</block>
  <block id="d898743d222c4e0e5e333941bee1ed57" category="list-text">资源责任：操作员现在可以在集群级别管理与 Astra Trident 安装相关的资源。在安装 Astra Trident 过程中，操作员使用 `ownerReferences` 创建和维护多个资源。在集群范围的资源上维护 `所有权参考` 可能会在某些 Kubernetes 分销商（例如 OpenShift ）上引发错误。使用集群范围的运算符可缓解此问题。对于 Trident 资源的自动修复和修补，这是一项基本要求。</block>
  <block id="375aa3155c54339a366f23cdb01301e5" category="list-text">卸载期间清理：要完全删除 Astra Trident ，需要删除所有关联的资源。命名空间范围的运算符可能会在删除集群范围的资源（例如 clusterRole ， ClusterRoleBinding-and PodSecurityPolicy ）时遇到问题，并导致清理不完整。集群范围的运算符可消除此问题描述。用户可以完全卸载 Astra Trident 并在需要时重新安装。</block>
  <block id="6d68e880fd5e5254e122e99a78417abd" category="list-text">`TridentProvider` 现已替换为 `TridentOrchestrator` 作为用于安装和管理 Astra Trident 的自定义资源。此外，还为 `TridentOrchestrator` 规范引入了一个新字段。用户可以使用 `spec.namespace` 字段指定必须安装 / 升级命名空间 Trident 。您可以查看一个示例<block ref="2890210b17eb9668a60ececdebcd5910" category="inline-link-rx"></block>。</block>
  <block id="9c83e144e5481ac6766f4055e566594d" category="section-title">了解更多信息</block>
  <block id="7d224494dc0d22edaed4c965cdddffe6" category="inline-link-macro">使用 Trident 操作符进行升级</block>
  <block id="85f4fc5b4c12e5ede408e45a6d484dc1" category="list-text"><block ref="85f4fc5b4c12e5ede408e45a6d484dc1" category="inline-link-macro-rx"></block></block>
  <block id="b41f68e89b7b02a9077fb800d31a2fbe" category="inline-link-macro">使用 `tridentctl` 进行升级</block>
  <block id="efb20f59615d4d5ee0437ba57aecbe50" category="list-text"><block ref="efb20f59615d4d5ee0437ba57aecbe50" category="inline-link-macro-rx"></block></block>
  <block id="f71fd95d4de4797557e6830c1448c945" category="summary">您可以使用 `tridentctl` 轻松升级现有的 Astra Trident 安装。</block>
  <block id="6224e22d5a77816dd8b659c25a3f88a5" category="paragraph">升级到最新版本的 Astra Trident 时，请考虑以下事项：</block>
  <block id="98c7e2ecbd5f5a638272ee366b25b6a1" category="inline-link">卷快照</block>
  <block id="8f9f7d64f0943a9bec25cdd7b786022a" category="list-text">从 Trident 20.01 开始，仅限测试版<block ref="0b290b7ed02de23dc49888d0fa4fc114" category="inline-link-rx"></block> 受支持。Kubernetes 管理员应注意安全地备份或将 alpha Snapshot 对象转换为测试版，以保留原有的 alpha Snapshot 。</block>
  <block id="ec35126af255fdfac3b9a8e16e971389" category="list-text">测试版的卷快照引入了一组经过修改的 CRD 和一个快照控制器，这两个控制器都应在安装 Astra Trident 之前进行设置。</block>
  <block id="a4155944ba4eeb0c41401ab7bb85d3d9" category="inline-link">本博客</block>
  <block id="06f3d92245489ff0e9444c95095ed61b" category="admonition"><block ref="d0e35df46eec7926f0d8844193807dad" category="inline-link-rx"></block> 讨论将 alpha 卷快照迁移到测试版格式所涉及的步骤。</block>
  <block id="4ff0a9f6065b24ce3d325bad3223f4e2" category="paragraph">卸载并重新安装 Astra Trident 可作为升级。卸载 Trident 时，不会删除 Astra Trident 部署所使用的永久性卷声明（ PVC ）和永久性卷（ PV ）。在 Astra Trident 脱机期间，已配置的 PV 仍可用，而 Astra Trident 将在恢复联机后为在此期间创建的任何 PVC 配置卷。</block>
  <block id="398a8bf92020ed0b4edb1445d1380971" category="admonition">升级 Astra Trident 时，请勿中断升级过程。确保安装程序运行完毕。</block>
  <block id="068051b0ea15e91fd236b514c8b35ffe" category="section-title">升级后的后续步骤</block>
  <block id="ba79ef627bc5ee010211ca922024f9e4" category="paragraph">要使用新 Trident 版本中提供的丰富功能（例如按需卷快照），您可以使用 `tridentctl upgrade` 命令升级卷。</block>
  <block id="1f97048c5a9c81e85e588044b15b51c8" category="paragraph">如果存在旧卷，则应将其从 NFS/iSCSI 类型升级到 CSI 类型，以便能够使用 Astra Trident 中的一整套新功能。Trident 配置的原有 PV 支持传统功能集。</block>
  <block id="aae0cab55b3d14012cfc61ef5ad46105" category="paragraph">决定将卷升级到 CSI 类型时，请考虑以下事项：</block>
  <block id="9407b572db9501134ce92167448428fb" category="list-text">您可能不需要升级所有卷。以前创建的卷将继续可访问并正常运行。</block>
  <block id="35127b2fd7c387c56305575dfafe2a97" category="list-text">升级时， PV 可以作为部署 / 状态集的一部分挂载。不需要关闭部署 / 状态集。</block>
  <block id="260eeb1b0c4ec05a9788dc485ed03d36" category="list-text">升级时，您 * 无法 * 将 PV 连接到独立 POD 。在升级卷之前，您应关闭 POD 。</block>
  <block id="2d59c3aee4c9fe757980153c65e922d0" category="list-text">您只能升级绑定到 PVC 的卷。升级前，应删除和导入未绑定到 PVC 的卷。</block>
  <block id="f2e9d80774fbee2a6152ad9c7db8e0ee" category="section-title">卷升级示例</block>
  <block id="eff342caa8bb47fc3653d7b149aa91d4" category="paragraph">以下示例显示了如何执行卷升级。</block>
  <block id="fbc477673a43a428e429fe6902c6e36a" category="list-text">运行 `kubectl get pv` 以列出 PV 。</block>
  <block id="09d5f690bff68f8b4ffeeed3dac1f534" category="paragraph">目前， Trident 20.07 使用 `netapp.io/trident` 配置程序创建了四个 PV 。</block>
  <block id="581ee670123fe76ff75275867ef06bcc" category="list-text">运行 `kubectl describe PV` 以获取 PV 的详细信息。</block>
  <block id="a20b570eccfacf0ac4684823643f91a1" category="paragraph">PV 是使用 `netapp.io/trident` 配置程序创建的，其类型为 NFS 。要支持 Astra Trident 提供的所有新功能，应将此 PV 升级到 CSI 类型。</block>
  <block id="5be1e244815de403bf79074735c2621f" category="list-text">运行 `tridenctl upgrade volume &lt;name-o-trident -volume&gt;` 命令将原有的 Astra Trident 卷升级到 CSI 规范。</block>
  <block id="c18e246999f594d4fb39c857bcdd1e09" category="list-text">运行 `kubectl describe PV` 以验证此卷是否为 CSI 卷。</block>
  <block id="fb741f44b40455e466443f8f96ace85e" category="paragraph">通过这种方式，您可以将由 Astra Trident 创建的 NFS/iSCSI 类型的卷逐个升级到 CSI 类型。</block>
  <block id="48dec026afe488df8faca35c5c3a39ea" category="summary">了解如何在 Trident 安装中创建和使用 Element 后端。</block>
  <block id="f58e95baa778c9a2bd1a4597fb49d9b7" category="doc">ONTAP 驱动程序</block>
  <block id="0e842f431ce1b4dfb57598e5682e3adc" category="paragraph">Astra Trident 提供了五个唯一的 ONTAP 存储驱动程序，用于与 ONTAP 集群进行通信。详细了解每个驱动程序如何处理卷的创建，访问控制及其功能。</block>
  <block id="48cf24486d9a8e65a142b25682f19949" category="cell">驱动程序</block>
  <block id="888a77f5ac0748b6c8001822417df8b6" category="cell">协议</block>
  <block id="1b5e109e8afd1f9b7f5bbf951eea3442" category="cell">卷模式</block>
  <block id="d5e2d9f8d8f10044e38b71b49e675d2e" category="cell">支持的访问模式</block>
  <block id="15971126972a002fcddb2c507534e371" category="cell">支持的文件系统</block>
  <block id="ac52cf637478f3656a1fdee5c02324fd" category="paragraph">文件系统</block>
  <block id="0d3a79885df431b0b67b50b9479e2fee" category="paragraph">rwo ， rwx ， rox</block>
  <block id="9f47e55b538b64923f2ee8c19bc6887a" category="paragraph">"" ， NFS</block>
  <block id="e1e4c8c9ccd9fc39c391da4bcd093fb2" category="paragraph">块</block>
  <block id="aa91b58ced7ef060eb0e27ac4e1d18a8" category="paragraph">rwo ， rox ， rwx</block>
  <block id="bc2e0aeb951ff36e6703a1ff5419eb02" category="paragraph">无文件系统。原始块设备</block>
  <block id="0b86d82002caac6130185da4ef1be67e" category="paragraph">工单， ROX</block>
  <block id="a029cca698cbf05f07897f86c43cf9e8" category="paragraph">`xfs` ， `ext3` ， `ext4`</block>
  <block id="4ff78ba07210a8b4db65f6ef62b4e1b4" category="admonition">可以使用安全角色的登录凭据（用户名 / 密码）或使用 ONTAP 集群上安装的私钥和证书对 ONTAP 后端进行身份验证。您可以使用 `tridentctl update backend` 来更新现有后端，以便从一种身份验证模式移至另一种身份验证模式。</block>
  <block id="d00888bc1409d1c598b90af117bd3551" category="summary">在 Astra Trident 中配置有两个主要阶段。第一阶段会将存储类与一组合适的后端存储池相关联，并在配置之前进行必要的准备。第二阶段包括卷创建本身，需要从与待定卷的存储类关联的存储池中选择一个存储池。</block>
  <block id="8a7354f894ef62fb3f076510315bf206" category="doc">Astra Trident 简介</block>
  <block id="7c738d9c13e4e5770c6b455ab345afd7" category="paragraph">Astra Trident 也是 NetApp Astra 的一项基础技术，利用 NetApp 行业领先的快照，备份，复制和克隆数据管理技术，可满足 Kubernetes 工作负载的数据保护，灾难恢复，可移动性和迁移用例。</block>
  <block id="4bd05efa612e48dd723de2bdd29f88e2" category="section-title">支持的 Kubernetes 集群架构</block>
  <block id="85b179f2c10f76f0171b4d9d3f2d5171" category="paragraph">以下 Kubernetes 架构支持 Astra Trident ：</block>
  <block id="c91cda04d3ac5ae2da327d347d4bbefe" category="cell">Kubernetes 集群架构</block>
  <block id="eaa4dc5078017a5c5bebf383ab6f5124" category="cell">supported</block>
  <block id="c0057eecd4b1a67d11dc801b8992a574" category="cell">默认安装</block>
  <block id="0c69c79a8788e0e4572d0c4838e69401" category="cell">单个主节点，计算节点</block>
  <block id="1fc3441370ae575a64d605fcd15a05fd" category="cell">多主机，计算</block>
  <block id="7cb2eb9488f3532834f7ef233ae894dd" category="cell">主， `etcd` ，计算</block>
  <block id="5e5f49db20e29f6377e57e98932dae57" category="cell">主机，基础架构，计算</block>
  <block id="ae663d0d321764bd88b8d864cd3afc9e" category="section-title">什么是 Astra ？</block>
  <block id="dd91e88f9a6ec30684f494c41baeeee0" category="paragraph">借助 Astra ，企业可以更轻松地在公有云内部和内部环境中管理，保护和移动 Kubernetes 上运行的数据丰富的容器化工作负载。Astra 使用 NetApp 在公有云和内部环境中成熟而广泛的存储产品组合中的 Astra Trident 配置和提供永久性容器存储。此外，它还提供了一组丰富的高级应用程序感知型数据管理功能，例如快照，备份和还原，活动日志和主动克隆，用于数据保护，灾难 / 数据恢复，数据审核以及 Kubernetes 工作负载的迁移用例。</block>
  <block id="02030c8e07c049062fbbba9a32b01067" category="summary">虚拟存储池在 Astra Trident 的存储后端和 Kubernetes 的 StorageClasses 之间提供了一个抽象层。管理员可以通过这些协议以一种通用的，与后端无关的方式定义各个方面，例如每个后端的位置，性能和保护，而不会使 StorageClass 指定要用于满足所需条件的物理后端，后端池或后端类型。</block>
  <block id="9f802733184b3e0fb080eddcf9ffeaef" category="doc">虚拟存储池</block>
  <block id="9f4406586d4a2343f2a5289e16131b3e" category="paragraph">虚拟存储池在 Astra Trident 的存储后端与 Kubernetes 的 `StorageClasses` 之间提供了一个抽象层。通过这些功能，管理员可以在不受后端影响的情况下以一种通用方式为每个后端定义位置，性能和保护等方面，而无需使用 `StorageClass` 指定要用于满足所需条件的物理后端，后端池或后端类型。</block>
  <block id="a4ff8f21d8d1ba289de3b08d19afbeab" category="paragraph">存储管理员可以在 JSON 或 YAML 定义文件中的任一 Astra Trident 后端定义虚拟存储池。</block>
  <block id="1c65ff50dcc9738f0ae4169e4f66589c" category="image-alt">显示了虚拟存储池的概念图。</block>
  <block id="2a778cf7220cdde142651975e1bcd90f" category="paragraph">在虚拟池列表之外指定的任何方面对于后端都是全局的，并将应用于所有虚拟池，而每个虚拟池可能会分别指定一个或多个方面（覆盖任何后端 - 全局方面）。</block>
  <block id="6aefc2a02fa1ec1f6ac8e9dbd5104efe" category="admonition">定义虚拟存储池时，请勿尝试在后端定义中重新排列现有虚拟池的顺序。此外，建议不要编辑 / 修改现有虚拟池的属性，而是定义新的虚拟池。</block>
  <block id="5a53576f0ba98311e845ad0243bed6b7" category="paragraph">大多数方面都以后端特定术语来指定。重要的是，这些宽高值不会在后端驱动程序之外公开，也不能在 `StorageClasses` 中进行匹配。而是管理员为每个虚拟池定义一个或多个标签。每个标签都是一个键：值对，标签可能在唯一的后端通用。与其他方面一样，可以为每个池指定标签，也可以为后端指定全局标签。与具有预定义名称和值的方面不同，管理员可以根据需要全权定义标签键和值。</block>
  <block id="a4d6bfb65b6541e04772c0d5180e726e" category="paragraph">`StorageClass` 通过引用选择器参数中的标签来标识要使用的虚拟池。虚拟池选择器支持六个运算符：</block>
  <block id="e1b3ec89ead7f83a9245ed5c9cacfdbf" category="cell">运算符</block>
  <block id="0a52730597fb4ffa01fc117d9e71e3a9" category="cell">示例</block>
  <block id="499badcb6f450c7f46c51d873eb84286" category="cell">` =`</block>
  <block id="354653142ec321459dfd6d71444e992e" category="cell">性能 = 高级</block>
  <block id="d2c49c25d96d87e40bc641b9d5302b36" category="cell">池的标签值必须匹配</block>
  <block id="5a5292b0a0d0379f0f1b12801b09b266" category="cell">` ！ =`</block>
  <block id="eccde6822783bd75209c9b6a2d357f6c" category="cell">性能！ = 至高</block>
  <block id="2944853a5f146abd2671adbecd5c25a3" category="cell">池的标签值不能匹配</block>
  <block id="ae2bef277194f73d24a36a78009aac1e" category="cell">`在` 中</block>
  <block id="f8cf8c23afb5459dbf7c24b685caf85b" category="cell">位置（东部，西部）</block>
  <block id="26aac934d614b1b3e5db46d8fc664ec6" category="cell">池的标签值必须位于一组值中</block>
  <block id="1a031eecbce49366e550273b9321b909" category="cell">`注释`</block>
  <block id="b5585f3f9b45f391fee5dd15e6516450" category="cell">性能注释（银牌，铜牌）</block>
  <block id="499fec8ad2646f2de982559111e26a4c" category="cell">池的标签值不能为 b</block>
  <block id="ae8e28c37a725c4bb4a74663ac8615ea" category="summary">详细了解 Astra Trident 如何使用卷访问组。</block>
  <block id="b4621305109716b02eed0cf25fabab13" category="doc">卷访问组</block>
  <block id="33911b1eec54b4b5a7fbc504e6569989" category="inline-link">卷访问组</block>
  <block id="649833006ff7b612c3d988173b6417d5" category="paragraph">了解有关 Astra Trident 如何使用的更多信息<block ref="783dd6ea9e0b09c84db9ccd072a61c55" category="inline-link-rx"></block>。</block>
  <block id="e93c18adf30bc91499234d0ec7863499" category="admonition">如果使用的是 CHAP ，请忽略此部分，建议使用此部分来简化管理并避免下面所述的扩展限制。此外，如果您在 CSI 模式下使用 Astra Trident ，则可以忽略此部分。在作为增强型 CSI 配置程序安装时， Astra Trident 会使用 CHAP 。</block>
  <block id="3c56a859b413098b6bf2c54aff32a842" category="paragraph">Astra Trident 可以使用卷访问组来控制对其配置的卷的访问。如果禁用了 CHAP ，则它会查找名为 `trident` 的访问组，除非您在配置中指定了一个或多个访问组 ID 。</block>
  <block id="025d19ee81e813e3ba40553cd4908638" category="paragraph">虽然 Astra Trident 会将新卷与已配置的访问组相关联，但它不会自行创建或管理访问组。在将存储后端添加到 Astra Trident 之前，访问组必须存在，并且这些访问组必须包含 Kubernetes 集群中每个节点的 iSCSI IQN ，这些节点可能会挂载该后端配置的卷。在大多数安装中，包括集群中的每个工作节点。</block>
  <block id="dff8ca466bae899e4dbc68c3a552033f" category="paragraph">对于节点数超过 64 个的 Kubernetes 集群，您应使用多个访问组。每个访问组最多可以包含 64 个 IQN ，每个卷可以属于四个访问组。在最多配置四个访问组的情况下，集群中大小最多为 256 个节点的任何节点都可以访问任何卷。有关卷访问组的最新限制，请参见<block ref="ac4000c3a85e5909daa6593f9f0617fd" category="inline-link-rx"></block>。</block>
  <block id="4f5254b466f691d7b0c50fb0d8286075" category="paragraph">如果要将配置从使用默认 `trident` 访问组的修改为也使用其他访问组的配置，请在列表中包含 `trident` 访问组的 ID 。</block>
  <block id="4d5445eb6c70cdab8d3ad5e71367f42a" category="summary">详细了解 Astra Trident 如何为其驱动程序创建卷快照。</block>
  <block id="e9c3828cd06711f9036bb4ce862a32c5" category="doc">卷快照</block>
  <block id="4fb7e6ff3b63c56522fdea39e41d701e" category="list-text">对于 `ontap-nas` ， `ontap-san` ， `AWS-CVS` ， `GCP-CVS` 和 `azure-netapp-files` 驱动程序， 每个永久性卷（ PV ）都会映射到一个 FlexVol 。因此，卷快照会创建为 NetApp 快照。与竞争对手的 Snapshot 技术相比， NetApp 的 Snapshot 技术可提供更高的稳定性，可扩展性，可恢复性和性能。无论是在创建 Snapshot 副本所需的时间还是在存储空间中，这些 Snapshot 副本都极为高效。</block>
  <block id="98c670ffe759cc20cd8a31d49bd0b4fc" category="list-text">对于 `ontap-san-economy-经济` 驱动程序， PV 会映射到在共享 FlexVol 上创建的 LUN 。可以通过对关联 LUN 执行 FlexClones 来实现 PV 的卷快照。借助 ONTAP 的 FlexClone 技术，即使是最大的数据集，也可以几乎即时创建副本。副本与其父级共享数据块，除了元数据所需的存储之外，不会占用任何存储。</block>
  <block id="9dbabbadda024bb7b1d0db43ab31b45f" category="list-text">对于 `solidfire-san` 驱动程序，每个 PV 都会映射到在 NetApp Element 软件 /NetApp HCI 集群上创建的 LUN 。VolumeSnapshot 由底层 LUN 的 Element Snapshot 表示。这些快照是时间点副本，只占用少量系统资源和空间。</block>
  <block id="34f731018ae783f70901b14b4950c3a7" category="list-text">使用 `ontap-nas` 和 `ontap-san` 驱动程序时， ONTAP 快照是 FlexVol 的时间点副本，并占用 FlexVol 本身的空间。这样，在创建 / 计划快照时，卷中的可写空间量会随着时间的推移而减少。解决此问题的一个简单方法是，通过 Kubernetes 调整大小来增大卷的大小。另一个选项是删除不再需要的快照。删除通过 Kubernetes 创建的卷快照后， Astra Trident 将删除关联的 ONTAP 快照。也可以删除未通过 Kubernetes 创建的 ONTAP 快照。</block>
  <block id="1eb824f8d9b30b3f4e089938e719fefe" category="paragraph">借助 Astra Trident ，您可以使用 VolumeSnapshots 创建新的 PV 。通过对支持的 ONTAP 和 CVS 后端使用 FlexClone 技术，可以从这些快照创建 PV 。从快照创建 PV 时，后备卷是快照父卷的 FlexClone 。`solidfire-san` 驱动程序使用 Element 软件卷克隆从快照创建 PV 。此时，它将从 Element 快照创建一个克隆。</block>
  <block id="89c3bcf0ecc1114f8d19734d9156cb40" category="doc">配置</block>
  <block id="2bd42f922a8c0b54b90557eba2071a76" category="paragraph">将后端存储池与存储类关联取决于存储类请求的属性及其 `storagePools` ， `addtionalStoragePools` 和 `excludeStoragePools` 列表。创建存储类时， Trident 会将其每个后端提供的属性和池与存储类请求的属性和池进行比较。如果存储池的属性和名称与请求的所有属性和池名称匹配，则 Astra Trident 会将该存储池添加到该存储类的一组合适存储池中。此外， Astra Trident 会将 `addtionalStoragePools` 列表中列出的所有存储池添加到该集中，即使其属性不满足存储类请求的所有或任何属性也是如此。您应使用 `excludeStoragePools` 列表覆盖存储池并将其从存储类中删除。每次添加新后端时， Astra Trident 都会执行类似的过程，检查其存储池是否满足现有存储类的要求，并删除任何已标记为已排除的。</block>
  <block id="668ccb4dd1c284f07a3062637c57d21a" category="paragraph">然后， Astra Trident 会使用存储类和存储池之间的关联来确定在何处配置卷。创建卷时， Astra Trident 会首先获取该卷的存储类的一组存储池， 此外，如果为卷指定协议，则 Astra Trident 会删除无法提供所请求协议的存储池（例如， NetApp HCI/SolidFire 后端无法提供基于文件的卷，而 ONTAP NAS 后端无法提供基于块的卷）。Astra Trident 会随机分配此结果集的顺序，以便均匀分布卷，然后迭代并依次尝试在每个存储池上配置卷。如果在一个上成功，则它会成功返回，并记录在此过程中遇到的任何故障。只有在 * 无法在 * 所有 * 可用于请求的存储类和协议的存储池上配置时， Astra Trident 才会返回故障。</block>
  <block id="3d522b99ca94333433532daa23e7ceab" category="summary">查找有关 Astra Trident 的安装，配置，升级和故障排除的常见问题解答。</block>
  <block id="af2a4d2810d86aa0169c117f82682f9a" category="doc">常见问题解答</block>
  <block id="96ab491ef73d5db0cd15f55e1552cc22" category="section-title">一般问题</block>
  <block id="b34c3d20de0f1b2c7a69bdc59002ad47" category="section-title">Astra Trident 的发布频率如何？</block>
  <block id="2f55088c7d055eb361252b15d5d7af10" category="paragraph">Astra Trident 每三个月发布一次： 1 月， 4 月， 7 月和 10 月。这是 Kubernetes 发布后一个月。</block>
  <block id="15602d1e4b699ebca549a3d953672d8c" category="section-title">Astra Trident 是否支持特定版本的 Kubernetes 中发布的所有功能？</block>
  <block id="d860923e20119473e7f7d50683cb0559" category="paragraph">Astra Trident 通常不支持 Kubernetes 中的 alpha 功能。在 Kubernetes 测试版之后的两个 Trident 版本中， Trident 可能支持测试版功能。</block>
  <block id="52ffcf336df0055235949cf324a8624b" category="section-title">Astra Trident 的运行是否依赖于其他 NetApp 产品？</block>
  <block id="9a10bc69a2553cd055c7b66932fd3864" category="paragraph">Astra Trident 与其他 NetApp 软件产品没有任何依赖关系，它可以作为独立应用程序运行。但是，您应具有 NetApp 后端存储设备。</block>
  <block id="bda04f64eaa9613cb4923cf43e24954c" category="section-title">如何获取完整的 Astra Trident 配置详细信息？</block>
  <block id="6d6d1fbb6191413b3262aed487048f1e" category="paragraph">使用 `tridentctl get` 命令可获取有关 Astra Trident 配置的详细信息。</block>
  <block id="d8634bcd1659c9cdf6f1a7a92ec00c30" category="section-title">我能否获取有关 Astra Trident 如何配置存储的指标？</block>
  <block id="1435574cfec44734b2bfc2b94327b118" category="paragraph">是的。Trident 20.01 引入了 Prometheus 端点，可用于收集有关 Astra Trident 操作的信息，例如托管的后端数量，配置的卷数量，占用的字节数等。您还可以使用 Cloud Insights 进行监控和分析。</block>
  <block id="3e9ebf4af3f0b9d1852396d46171ef99" category="section-title">使用 Astra Trident 作为 CSI 配置程序时，用户体验是否会发生变化？</block>
  <block id="05f95d89af1ccd9b986014406a4b1fc8" category="paragraph">否在用户体验和功能方面没有变化。使用的配置程序名称是 `csi.trident.netapp.io` 。如果要使用当前版本和未来版本提供的所有新功能，建议使用此方法安装 Astra Trident 。</block>
  <block id="0a7e87df44869b8d60a83f35d1e2747b" category="section-title">在 Kubernetes 集群上安装和使用 Astra Trident</block>
  <block id="ffb25b8f3453272318fba778e825268f" category="section-title">支持哪些版本的 etcd ？</block>
  <block id="6a3ad0d68dcfe0164611dadb7f7656f9" category="paragraph">Astra Trident 不再需要 `etcd` 。它使用 CRD 来保持状态。</block>
  <block id="bde6cb03741f92107c63aeebe62d3278" category="section-title">Astra Trident 是否支持从专用注册表脱机安装？</block>
  <block id="eeabb890ce57551c5685ffb613b78406" category="paragraph">可以， Astra Trident 可以脱机安装。请参见 <block ref="f0cd5c2694f3680f6758ce5ce7e21a5b" category="inline-link-macro-rx"></block>。</block>
  <block id="1c51806b370d428d5779dbcacd940174" category="section-title">是否可以远程安装 Astra Trident ？</block>
  <block id="bf858450c271da75a3df3a15ca761330" category="paragraph">是的。Astra Trident 18.10 及更高版本支持从 `kubectl` 访问集群的任何计算机远程安装。验证 `kubectl` 访问后（例如，从远程计算机启动 `kubectl get nodes` 命令进行验证），请按照安装说明进行操作。</block>
  <block id="12694c2de4575e39a6f7e81d55e35de9" category="section-title">是否可以使用 Astra Trident 配置高可用性？</block>
  <block id="f1cf2ca3af6ca7c374ad2104f570c790" category="paragraph">Astra Trident 以 Kubernetes 部署（ ReplicaSet ）的形式安装有一个实例，因此它具有内置的 HA 。您不应增加部署中的副本数量。如果安装了 Astra Trident 的节点丢失或 POD 无法访问， Kubernetes 会自动将 POD 重新部署到集群中运行正常的节点。Astra Trident 仅支持控制平面，因此，如果重新部署 Astra Trident ，当前安装的 Pod 不会受到影响。</block>
  <block id="1656e4b34abdb6d497b40cac65366767" category="section-title">Astra Trident 是否需要访问 Kube-system 命名空间？</block>
  <block id="6f67e1edfd4aa5b0e695528a9c7d8898" category="paragraph">Astra Trident 从 Kubernetes API 服务器读取数据，以确定应用程序何时请求新的 PVC ，因此需要访问 Kube-system 。</block>
  <block id="16cdb35003b5bcf0f30556e0bc477511" category="section-title">Astra Trident 使用哪些角色和特权？</block>
  <block id="dd57666df1542a5c5c1c8ea446433dba" category="paragraph">Trident 安装程序会创建一个 Kubernetes ClusterRole ，该 ClusterRole 可对集群的 PersistentVolume ， PersistentVolumeClaim ， StorageClass 和 Kubernetes 集群的 Secret 资源进行特定访问。请参见 <block ref="21005beb39aa5b473ddc4fbc9c302e0b" category="inline-link-macro-rx"></block>。</block>
  <block id="8ff39a39871cc30228035bc0580a6af4" category="section-title">是否可以在本地生成 Astra Trident 用于安装的准确清单文件？</block>
  <block id="34edccb29a11f4f0728f07bbefd9d0e6" category="paragraph">如果需要，您可以在本地生成和修改 Astra Trident 用于安装的确切清单文件。请参见 <block ref="21005beb39aa5b473ddc4fbc9c302e0b" category="inline-link-macro-rx"></block>。</block>
  <block id="e6af67b71bd46d7588b50f28e1414f9b" category="section-title">是否可以为两个单独的 Kubernetes 集群的两个单独的 Astra Trident 实例共享同一个 ONTAP 后端 SVM ？</block>
  <block id="7bbf9b47e035f0f9bb7c46098e78fb4d" category="paragraph">尽管不建议这样做，但您可以对两个 Astra Trident 实例使用同一个后端 SVM 。在安装期间为每个实例指定唯一的卷名称和 / 或在 `setup/backend.json` 文件中指定唯一的 `StoragePrefix` 参数。这是为了确保不会对这两个实例使用相同的 FlexVol 。</block>
  <block id="9840a5bb6278469ed550bcdcc92c29c5" category="section-title">是否可以在 ContainerLinux （以前称为 CoreOS ）下安装 Astra Trident ？</block>
  <block id="7a35680d9db247612b732ae47144f030" category="paragraph">Astra Trident 只是 Kubernetes Pod ，可安装在 Kubernetes 运行的任何位置。</block>
  <block id="5fc6de1b535ebb2a5380b6aa607e4cca" category="section-title">是否可以将 Astra Trident 与 NetApp Cloud Volumes ONTAP 结合使用？</block>
  <block id="5d1cff73e26dc54ef52bdca5a29b319c" category="paragraph">是的， AWS ， Google Cloud 和 Azure 支持 Astra Trident 。</block>
  <block id="2ddee53d5c18f6e78f18dad82851303e" category="section-title">Astra Trident 是否支持 Cloud Volumes Services ？</block>
  <block id="404ebcdc21eb83145ddb36d33bd8c09e" category="paragraph">是的， Astra Trident 支持 Azure 中的 Azure NetApp Files 服务以及 AWS 和 GCP 中的 Cloud Volumes Service 。</block>
  <block id="92d1656d06303733c5e1398fb273a17e" category="section-title">故障排除和支持</block>
  <block id="9985a592486717ae388709b9267da4f9" category="section-title">NetApp 是否支持 Astra Trident ？</block>
  <block id="cc56e0da96ceaf708545923f1094815b" category="paragraph">虽然 Astra Trident 是开源且免费提供的，但只要您的 NetApp 后端受支持， NetApp 就会完全支持它。</block>
  <block id="a3d907947129a58ee6f9e23074840c8f" category="section-title">如何提出支持案例？</block>
  <block id="0265687df6c09d532b03477776c6d075" category="paragraph">要提交支持案例，请执行以下操作之一：</block>
  <block id="5dab8cca21a0ff4e72d4e2a1ee5156ea" category="list-text">请联系您的支持客户经理并获得帮助以提交服务单。</block>
  <block id="09ea0908fbfc4cde85bf416e35dc55c8" category="inline-link">NetApp 支持</block>
  <block id="a13956d424374973d31e5883b8bf8b6a" category="list-text">联系以提出支持案例<block ref="116f7ad90a3c7441981f82d8f8fba4d5" category="inline-link-rx"></block>。</block>
  <block id="3e77e87e5ee8fb4f6f910f4cf0594fc2" category="section-title">如何生成支持日志包？</block>
  <block id="7938aed248d09a5120eaf414e6c1d574" category="paragraph">您可以运行 `tridentctl logs -a` 来创建支持包。除了在捆绑包中捕获的日志之外，还可以捕获 kubelet 日志以诊断 Kubernetes 端的挂载问题。获取 kubelet 日志的说明因 Kubernetes 的安装方式而异。</block>
  <block id="2c3543f339dc749a508ed5e5e5aaae23" category="section-title">如果需要提出新功能请求，我该怎么办？</block>
  <block id="42bfc6e3acd67192d42135138102a1de" category="inline-link">Trident Github</block>
  <block id="c2146fea25aea76bae1b5853f60a2f87" category="paragraph">在上创建问题描述<block ref="47273b71915582ec6db59ad21099cfb9" category="inline-link-rx"></block> 并在问题描述的主题和问题描述中提及 * RFE* 。</block>
  <block id="0aa1d7a95d75c0faa8302a803356b7b7" category="section-title">我应在何处提出缺陷？</block>
  <block id="4c1d312c39e7048d2c634824e243fdba" category="inline-link">Astra Trident Github</block>
  <block id="a814c59a6fef2fb64a2a32dedcf6f82e" category="paragraph">在上创建问题描述<block ref="e71a8230f1c77ee7d957187295b859e4" category="inline-link-rx"></block>。请务必包含与问题描述相关的所有必要信息和日志。</block>
  <block id="fd0759571f12527967b660b5b327c65b" category="section-title">如果我有有关 Astra Trident 的快速问题需要澄清，会发生什么情况？是否有社区或论坛？</block>
  <block id="3561f3a3c5576e2ce0dc0d1e268bb9b2" category="inline-link">Slack</block>
  <block id="f549c74b636d0ad80493d063fe6ecfc3" category="paragraph">如果您有任何问题，问题或请求，请通过我们的联系我们<block ref="2d9f7b5a7f56881c42c3b026a068eb36" category="inline-link-rx"></block> 团队或 GitHub 。</block>
  <block id="264c3819b5a8fdae87f1dc9af1988a90" category="section-title">我的存储系统密码已更改， Astra Trident 不再工作，如何恢复？</block>
  <block id="061ec2ab4d383b8f20e15eda656db8f7" category="paragraph">使用 `tridentctl update backend myBackend -f &lt;/path/to_new_backend.json&gt; -n trident` 更新后端的密码。将示例中的 `myBackend` 替换为后端名称，将 `` /path/to_new_backend.json` 替换为正确的 `backend.json` 文件的路径。</block>
  <block id="6100f37d544e87e462129f21e52bae7f" category="section-title">Astra Trident 找不到我的 Kubernetes 节点。如何修复此问题？</block>
  <block id="d5cf5c734786394c838bacc6597594c6" category="paragraph">Astra Trident 无法找到 Kubernetes 节点的原因可能有两种。这可能是因为 Kubernetes 中的网络问题描述或 DNS 问题描述。在每个 Kubernetes 节点上运行的 Trident 节点取消设置必须能够与 Trident 控制器进行通信，以便向 Trident 注册该节点。如果在安装 Astra Trident 后发生网络更改，则只有在添加到集群中的新 Kubernetes 节点上才会遇到此问题。</block>
  <block id="bcd549c9f0199c5b8d0b55f782bff9e8" category="section-title">如果 Trident POD 被销毁，是否会丢失数据？</block>
  <block id="136fed1edd42bf8ca22358da037d17fa" category="paragraph">如果 Trident POD 被销毁，数据不会丢失。Trident 的元数据存储在 CRD 对象中。已由 Trident 配置的所有 PV 都将正常运行。</block>
  <block id="3de05f78e401869f4630ec8cabf339df" category="section-title">是否可以直接从旧版本升级到新版本（跳过几个版本）？</block>
  <block id="ce44cbbc54839f39b351c091b0e3caa5" category="paragraph">NetApp 支持将 Astra Trident 从一个主要版本升级到下一个直接主要版本。您可以从 18.xx 升级到 19.xx ，从 19.xx 升级到 20.xx 等。在生产部署之前，您应在实验室中测试升级。</block>
  <block id="0399b9e6348e554937a4d65efc97a1b8" category="section-title">是否可以将 Trident 降级到先前版本？</block>
  <block id="d307563c01953bd90a41ddd049f96d51" category="inline-link-macro">有关降级的章节</block>
  <block id="0dedfa196a76d45ea496a2b3ebca850a" category="paragraph">如果要降级，需要评估许多因素。请参见 <block ref="4734dc58d0c9739f3584035ff28dc1f1" category="inline-link-macro-rx"></block>。</block>
  <block id="ba9c59aa9d07b25e124dcf6ca88d689a" category="section-title">管理后端和卷</block>
  <block id="ffe72215dff9a93d62ee68905212025e" category="section-title">是否需要在 ONTAP 后端定义文件中同时定义管理和数据 LIF ？</block>
  <block id="3a35d35cc18d96684d78b36a81422e0c" category="paragraph">NetApp 建议在后端定义文件中同时包含这两者。但是，只有管理 LIF 是必需的。</block>
  <block id="f3997f0b9446951754e665cfe7591cef" category="section-title">Astra Trident 是否可以为 ONTAP 后端配置 CHAP ？</block>
  <block id="805f73dde029c6c119993b4496bbdc9e" category="paragraph">是的。从 20.04 开始， Astra Trident 支持 ONTAP 后端的双向 CHAP 。这需要在后端配置中设置 `useCHAP=true` 。</block>
  <block id="952cc22022a80bb8079f6dd7afb289d2" category="section-title">如何使用 Astra Trident 管理导出策略？</block>
  <block id="700815d44ae9a359311f64dbebbd8d42" category="paragraph">Astra Trident 可以从 20.04 版开始动态创建和管理导出策略。这样，存储管理员便可在其后端配置中提供一个或多个 CIDR 块，并使 Trident 将属于这些范围的节点 IP 添加到其创建的导出策略中。通过这种方式， Astra Trident 会自动管理为给定 CIDR 中具有 IP 的节点添加和删除规则的操作。此功能需要 CSI Trident 。</block>
  <block id="ddd61a9bf73a6cb2a2375bcdfbecbe15" category="section-title">是否可以在 DataLIF 中指定端口？</block>
  <block id="c7449c080f216d9be59d8ff995985d39" category="paragraph">Astra Trident 19.01 及更高版本支持在 DataLIF 中指定端口。在 `backend.json` 文件中将其配置为 `` "managementLIF" ： &lt;IP address&gt; ： &lt;port&gt; "`` 。例如，如果管理 LIF 的 IP 地址为 192.0.2.1 ，端口为 1000 ，请配置 `` "managementLIF" ： "192.0.2.1 ： 1000"`` 。</block>
  <block id="1d08384060bd88a7801faae4fe346d06" category="section-title">IPv6 地址是否可用于管理和数据 LIF ？</block>
  <block id="955e051838e60a39384f98e20ef67d47" category="paragraph">是的。Astra Trident 20.01 支持为管理 LIF 定义 IPv6 地址，并为 ONTAP 后端定义 dataLIF 参数。您应确保地址遵循 IPv6 语义，并且管理 LIF 在方括号内进行定义（例如， `` [ec0d ： 6504 ： a9c1 ： ae67 ： 53d1 ： 4bdf ： ab32 ： e233]`` ）。您还应确保使用 `` -use-ipv6` 标志安装 Astra Trident ，以使其能够在 IPv6 上正常运行。</block>
  <block id="4c0e813a0bfed033d75bbfd8b18f556c" category="section-title">是否可以在后端更新管理 LIF ？</block>
  <block id="66d8fee83a94421ca416a2bdb33703b4" category="paragraph">可以，可以使用 `tridentctl update backend` 命令更新后端管理 LIF 。</block>
  <block id="c56cd7a01da4acc4fc86aa498cabfd99" category="section-title">是否可以更新后端的数据 LIF ？</block>
  <block id="9f811ba6d553275226edbacf07b2828b" category="paragraph">不可以，无法更新后端的数据 LIF 。</block>
  <block id="1e0e6fcec605e6450ba12b95969c8959" category="section-title">是否可以在适用于 Kubernetes 的 Astra Trident 中创建多个后端？</block>
  <block id="fb3cb30bfe23466a98407256c8b5164f" category="paragraph">Astra Trident 可以同时支持多个后端，可以使用相同的驱动程序，也可以使用不同的驱动程序。</block>
  <block id="6454319cc2398418b67f5b2df5aa5cd3" category="section-title">Astra Trident 如何存储后端凭据？</block>
  <block id="1d406f7ac7268b602da0989a4675480e" category="paragraph">Astra Trident 会将后端凭据存储为 Kubernetes Secretes 。</block>
  <block id="64a610ffaa66abeebc73d8159b9f73ec" category="section-title">Astra Trident 如何选择特定后端？</block>
  <block id="c6e9fbb586ad55ddf4bbda9814c6adc9" category="paragraph">如果无法使用后端属性自动为某个类选择合适的池，则会使用 `storagePools` 和 `addtionalStoragePools` 参数来选择一组特定的池。</block>
  <block id="3beefa69a05dde01d93a438a943a5a7a" category="section-title">如何确保 Astra Trident 不会从特定后端配置？</block>
  <block id="b5c265487a1fed6a3367664ccab664bb" category="paragraph">`excludeStoragePools` 参数用于筛选 Astra Trident 要用于配置的一组池，并将删除匹配的任何池。</block>
  <block id="e124ac30adf3eea60a13cd5f93980e7e" category="section-title">如果存在多个相同类型的后端，则 Astra Trident 如何选择要使用的后端？</block>
  <block id="c02ba3e7f8a02e0d1e29e2190a86e352" category="paragraph">如果配置了多个相同类型的后端，则 Astra Trident 会根据 `StorageClass` 和 `PersistentVolumeClaim` 中的参数选择相应的后端。例如，如果有多个 ontap-NAS 驱动程序后端，则 Astra Trident 会尝试匹配 `StorageClass` 和 `PersistentVolumeClaim` 组合中的参数，并匹配后端，这样可以满足 `StorageClass` 和 `PersistentVolumeClaim` 中列出的要求。如果有多个后端与请求匹配，则 Astra Trident 会随机从其中一个后端中进行选择。</block>
  <block id="7a2fd62f4a63259a7f94543a0ae01e76" category="section-title">Astra Trident 是否支持 Element 或 SolidFire 的双向 CHAP ？</block>
  <block id="b127099c71415d532da3a26ed73eb041" category="paragraph">是的。</block>
  <block id="7880810a250adc4ccf5108fe88325055" category="section-title">Astra Trident 如何在 ONTAP 卷上部署 qtree ？一个卷可以部署多少个 qtree ？</block>
  <block id="657cbdac1a85665b0b38b37c9a306925" category="paragraph">`ontap-nas-economy` 驱动程序可在同一个 FlexVol 中创建多达 200 个 qtree （可在 50 到 300 之间配置），每个集群节点创建 100 ， 000 个 qtree ，每个集群创建 2.4 M 个 qtree 。当您输入由经济型驱动程序提供服务的新的 `PersistentVolumeClaim` 时，驱动程序将查看是否已存在可为新的 qtree 提供服务的 FlexVol 。如果不存在可为 qtree 提供服务的 FlexVol ，则会创建一个新的 FlexVol 。</block>
  <block id="abbdd4298bb3e525fd172b2bbe5a451c" category="section-title">如何为在 ONTAP NAS 上配置的卷设置 Unix 权限？</block>
  <block id="a535e502931280dfaa539ecd1cbdfc0c" category="paragraph">您可以通过在后端定义文件中设置参数来对 Astra Trident 配置的卷设置 Unix 权限。</block>
  <block id="094ef47e6456d60b656401b0f2bbfcbd" category="section-title">如何在配置卷时配置一组显式 ONTAP NFS 挂载选项？</block>
  <block id="84ae0d345d4b749efbbc8103b0770e68" category="paragraph">默认情况下， Astra Trident 不会使用 Kubernetes 将挂载选项设置为任何值。要在 Kubernetes 存储类中指定挂载选项，请按照给定示例进行操作<block ref="cd55c45fce745b7032050d3a7a9ec326" category="inline-link-rx"></block>。</block>
  <block id="ae6bc3659bb0be0a7d9f98a63775b7c2" category="section-title">如何将配置的卷设置为特定导出策略？</block>
  <block id="700a2008fea63d02c24b85f2f75d357e" category="paragraph">要允许相应的主机访问卷，请使用后端定义文件中配置的 `exportPolicy` 参数。</block>
  <block id="9d5813dee71bcbf3d3a03c62354c3e55" category="section-title">如何使用 ONTAP 通过 Astra Trident 设置卷加密？</block>
  <block id="5467ffdca7c34378117097446e6a4408" category="paragraph">您可以使用后端定义文件中的加密参数在 Trident 配置的卷上设置加密。</block>
  <block id="ef1581716b653c4364dd5005dbe9e40a" category="section-title">通过 Astra Trident 为 ONTAP 实施 QoS 的最佳方式是什么？</block>
  <block id="f412d672b51ea3c57812ebf3be0ddccb" category="paragraph">使用 `StorageClasses` 为 ONTAP 实施 QoS 。</block>
  <block id="1c771b761835123a135e64f70567d768" category="section-title">如何通过 Astra Trident 指定精简配置或厚配置？</block>
  <block id="0d97afe7a571dc39db1c810013844332" category="paragraph">ONTAP 驱动程序支持精简或厚配置。ONTAP 驱动程序默认为精简配置。如果需要厚配置，则应配置后端定义文件或 `StorageClass` 。如果同时配置了这两者，则 `StorageClass` 优先。为 ONTAP 配置以下内容：</block>
  <block id="2d0384de8b72e53c3476a478a5d4ec53" category="list-text">在 `StorageClass` 上，将 `provisioningType` 属性设置为 thick 。</block>
  <block id="3764067c4b14276efb241c511c8b0cc2" category="list-text">在后端定义文件中，通过将 `backend spaceReserve 参数` 设置为 volume 来启用厚卷。</block>
  <block id="d4391b26a81fead46afc74243c4029aa" category="section-title">如何确保即使意外删除了 PVC 也不会删除所使用的卷？</block>
  <block id="e58a684cd1a44d4879defbb2ec06b9a4" category="paragraph">从版本 1.10 开始， Kubernetes 会自动启用 PVC 保护。</block>
  <block id="8d766c7d692523686b8954d72ee86ea4" category="section-title">是否可以扩展由 Astra Trident 创建的 NFS PVC ？</block>
  <block id="328e34871ba32779f27f3e8a8e78499a" category="paragraph">是的。您可以扩展由 Astra Trident 创建的 PVC 。请注意，卷自动增长是一项 ONTAP 功能，不适用于 Trident 。</block>
  <block id="f2f324d5d940b44cd307b613c6990e0c" category="section-title">如果我的卷是在 Astra Trident 外部创建的，是否可以将其导入到 Astra Trident ？</block>
  <block id="c894ce628e51d8d9d062a1e83cda37c8" category="paragraph">从 19.04 开始，您可以使用卷导入功能将卷引入 Kubernetes 。</block>
  <block id="3319194e0ba07a6aa327aefa1ab1e41f" category="section-title">是否可以在卷处于 SnapMirror 数据保护（ DP ）或脱机模式时导入它？</block>
  <block id="0b10afe39923054016a71caf423fdec6" category="paragraph">如果外部卷处于 DP 模式或脱机，则卷导入将失败。您会收到以下错误消息：</block>
  <block id="9fd7d017b60cc366b6bc3b6e55213abe" category="section-title">是否可以扩展由 Astra Trident 创建的 iSCSI PVC ？</block>
  <block id="29e2faaced65d1dd4c920c60e854e550" category="paragraph">Trident 19.10 支持使用 CSI 配置程序扩展 iSCSI PV 。</block>
  <block id="eed67b2d196c61d9c6cf4a50878ba446" category="section-title">如何将资源配额转换为 NetApp 集群？</block>
  <block id="45f78013e46c8f3e884ed0f7becbd5ab" category="paragraph">只要 NetApp 存储具有容量， Kubernetes 存储资源配额就应起作用。当 NetApp 存储由于容量不足而无法支持 Kubernetes 配额设置时， Astra Trident 会尝试配置，但会出错。</block>
  <block id="491a93842f7a65b8cbe82aca71db0d3f" category="section-title">是否可以使用 Astra Trident 创建卷快照？</block>
  <block id="9792ac41ce6f91861f84548e1b4a2b1c" category="paragraph">是的。Astra Trident 支持从快照创建按需卷快照和永久性卷。要从快照创建 PV ，请确保已启用 `VolumeSnapshotDataSource` 功能门。</block>
  <block id="1eedb8a6574b0c07ea61689a7e3ec8d4" category="section-title">哪些驱动程序支持 Astra Trident 卷快照？</block>
  <block id="24c649a639a2c31810a4dfc6ed0190da" category="section-title">如何为采用 ONTAP 的 Astra Trident 配置的卷创建快照备份？</block>
  <block id="0bdcd128fab544a7df404bc496a4126e" category="paragraph">此功能可从 `ontap-nas` ， `ontap-san` 和 `ontap-nas-flexgroup` 驱动程序获得。您也可以在 FlexVol 级别为 `ontap-san-economy` 驱动程序指定 `snapshotPolicy` 。</block>
  <block id="933b520ff6d70262ddb482995c684d57" category="paragraph">此功能也可在 `ontap-nas-economy` 驱动程序上使用，但可在 FlexVol 级别粒度上使用，而不能在 qtree 级别粒度上使用。要启用对由 Astra Trident 配置的卷创建快照的功能，请将后端参数选项 `snapshotPolicy` 设置为 ONTAP 后端定义的所需快照策略。Astra Trident 无法识别存储控制器创建的任何快照。</block>
  <block id="594e8a352537de25938bdd663d6211b5" category="section-title">是否可以为通过 Astra Trident 配置的卷设置快照预留百分比？</block>
  <block id="8db5662205f3a6430af4bea6f08e7d45" category="paragraph">可以，您可以通过在后端定义文件中设置 `snapshotReserve` 属性来预留特定百分比的磁盘空间，以便通过 Astra Trident 存储 Snapshot 副本。如果在后端定义文件中配置了 `snapshotPolicy` 和 `snapshotReserve` ，则会根据后端文件中提及的 `snapshotReserve` 百分比设置快照预留百分比。如果未提及 `snapshotReserve` 百分比数，则默认情况下， ONTAP 会将快照预留百分比设置为 5 。如果将 `snapshotPolicy` 选项设置为 none ，则快照预留百分比将设置为 0 。</block>
  <block id="6b0d34d8a0749198a6b80eec69479c86" category="section-title">是否可以直接访问卷快照目录和复制文件？</block>
  <block id="eb3a2d1eb3c4022269f4c6837332311a" category="paragraph">可以，您可以通过在后端定义文件中设置 `snapshotDir` 参数来访问 Trident 配置的卷上的 Snapshot 目录。</block>
  <block id="81dbf5e91cc69bfcf6477128389d8a25" category="section-title">是否可以通过 Astra Trident 为卷设置 SnapMirror ？</block>
  <block id="64dd4ea74b402889a9c341da491f4933" category="paragraph">目前，必须使用 ONTAP 命令行界面或 OnCommand 系统管理器在外部设置 SnapMirror 。</block>
  <block id="e321bf6d54ded18df56a41ea51223a2a" category="section-title">如何将永久性卷还原到特定 ONTAP 快照？</block>
  <block id="5325f5d2cf63aaaa6610f09e8aa4dc35" category="paragraph">要将卷还原到 ONTAP 快照，请执行以下步骤：</block>
  <block id="4e789db936072df2058e9f271a9b8db8" category="list-text">暂停正在使用永久性卷的应用程序 POD 。</block>
  <block id="b34baa75f4f799a23b19de9b94e86868" category="list-text">通过 ONTAP 命令行界面或 OnCommand 系统管理器还原到所需的快照。</block>
  <block id="08754f2800804f1fe3673c858b4b56e0" category="list-text">重新启动应用程序 POD 。</block>
  <block id="0d3ef54a4cc337b5d907b6639e51c6d4" category="section-title">如何区分每个客户 / 租户的存储类使用情况？</block>
  <block id="fda1b35892cb6f61447f0e49415937d9" category="paragraph">Kubernetes 不允许在命名空间中使用存储类。但是，您可以使用 Kubernetes 通过使用每个命名空间的存储资源配额来限制每个命名空间的特定存储类的使用。要拒绝特定命名空间对特定存储的访问，请将该存储类的资源配额设置为 0 。</block>
  <block id="ea3d51fb2b16acb7cb260f25bc8965b1" category="summary">Astra Trident 是由 NetApp 维护的开源存储配置程序和流程编排程序。通过它，您可以为 Docker 和 Kubernetes 管理的容器化应用程序创建存储卷。</block>
  <block id="30d965eef5ba25c6b9998ae38270b43e" category="doc">法律声明</block>
  <block id="c59ae8d7beeb519a23478ab048af482c" category="paragraph"><block ref="c59ae8d7beeb519a23478ab048af482c" category="inline-link-macro-rx"></block></block>
  <block id="55847a7d73d44b84804f47ee7863b80f" category="summary">部署 Astra Trident 后，您可以继续创建后端，创建存储类，配置卷以及将卷挂载到 Pod 中。</block>
  <block id="0b0ca016c0d99a4845777aeeebb032ac" category="section-title">第 1 步：创建后端</block>
  <block id="4f374e8dd911d1e70f7b7a53fdac1f2a" category="paragraph">现在，您可以继续创建一个后端，供 Astra Trident 配置卷使用。要执行此操作，请创建包含必要参数的 `backend.json` 文件。可以在 `sample-input` 目录中找到不同后端类型的示例配置文件。</block>
  <block id="8b389d7be97d6c697a4e775ff8338905" category="paragraph">请参见 <block ref="49641f5ab61d7a6ce07b1b6ba31204f8" category="inline-link-macro-rx"></block> 有关如何为后端类型配置文件的更多详细信息。</block>
  <block id="af445e1d9a0a481ba7f9b5f01df23a3d" category="paragraph">如果创建失败，则后端配置出现问题。您可以运行以下命令来查看日志以确定发生原因：</block>
  <block id="00715976efdc0cc3b7c5a8512fb0e08d" category="inline-link-macro">故障排除</block>
  <block id="936067ad00da88d877acb024c96f3129" category="paragraph">解决问题后，只需返回到此步骤的开头并重试。有关更多故障排除提示，请参见 <block ref="fa8c952f2dea85664a3e3e5dc210aa4c" category="inline-link-macro-rx"></block> 部分。</block>
  <block id="0cf7ce61dd48f9396923c05ab8f5e302" category="section-title">第 2 步：创建存储类</block>
  <block id="8c566ff50efde64c700b1188e862c328" category="inline-link">存储类</block>
  <block id="c44e939795fbf61079e70122d3e77735" category="paragraph">Kubernetes 用户使用指定的永久性卷声明（ Persistent Volume Claim ， PVC ）配置卷<block ref="bc70014ff50467618a31ef39142ab151" category="inline-link-rx"></block> 按名称。详细信息对用户隐藏，但存储类可标识用于该类的配置程序（在本例中为 Trident ）以及该类对配置程序的含义。</block>
  <block id="56cc6184a3bc4387f839993b204e4c5f" category="paragraph">创建存储类 Kubernetes 用户将指定何时需要卷。该类的配置需要为上一步创建的后端建模，以便 Astra Trident 可以使用它来配置新卷。</block>
  <block id="45a1f9131ca1bec07f47f45a194d9d58" category="paragraph">首先要使用的最简单存储类是基于安装程序随附的 `sample-input/storage-class-csi 。 yaml.tempdl` 文件，将 ` _backend_type_ _` 替换为存储驱动程序名称。</block>
  <block id="b4987be37083b7196f23d63ddd5d56df" category="paragraph">这是一个 Kubernetes 对象，因此您可以使用 `kubectl` 在 Kubernetes 中创建该对象。</block>
  <block id="a191af7083288f9d9556f3ebcd821a34" category="paragraph">现在， Kubernetes 和 Astra Trident 都应显示 * 基本 -CSI * 存储类， Astra Trident 应已发现后端的池。</block>
  <block id="3bdc1ec6969d1615bb58d7f0443bf1c2" category="section-title">第 3 步：配置第一个卷</block>
  <block id="a58b17a231318aa42ed47bfe0be43447" category="inline-link">永久性卷声明</block>
  <block id="512b66e66e82ba09d70c3e9f784aa8af" category="paragraph">现在，您已准备好动态配置第一个卷。可通过创建 Kubernetes 来完成此操作<block ref="95c09f225fe48abca705fd090f5f4c89" category="inline-link-rx"></block> （ PVC ）对象。</block>
  <block id="61e8eac65ddef26d4c4230d88cae8498" category="paragraph">为使用刚刚创建的存储类的卷创建 PVC 。</block>
  <block id="b357acbdc339437d16e4e967ecc6d0c2" category="paragraph">有关示例，请参见 `sample-input/vpva-basic CSI 。 yaml` 。确保存储类名称与您创建的名称匹配。</block>
  <block id="2fe8954464ccf22d2d06423b358f38a7" category="section-title">第 4 步：将卷挂载到 Pod 中</block>
  <block id="366556d176e685870d134b7fc6e9ca3c" category="paragraph">现在，让我们挂载卷。我们将启动一个 nginx pod ，将 PV 挂载到 ` /usr/share/nginx/html` 下。</block>
  <block id="6f5eca6ad9143d35bb33a1a17df3a848" category="paragraph">此时， Pod （应用程序）不再存在，但卷仍在。如果需要，您可以从另一个 POD 使用它。</block>
  <block id="3ba419ecccf23f33a6bae5d23f206fdd" category="paragraph">要删除卷，请删除声明：</block>
  <block id="1a00c9156117d9ec9fa3e45d5a757d04" category="paragraph">现在，您可以执行其他任务，例如：</block>
  <block id="ce2c6a300f520205e891fc45009ec4c3" category="inline-link-macro">配置其他后端。</block>
  <block id="642bfa81920103d4177bb3fdf6f9186f" category="list-text"><block ref="642bfa81920103d4177bb3fdf6f9186f" category="inline-link-macro-rx"></block></block>
  <block id="93e8ba41e1ebcadc1338cc7f75109210" category="inline-link-macro">创建其他存储类。</block>
  <block id="daa40449d28fbb16d2bcd8a8434d05e6" category="list-text"><block ref="daa40449d28fbb16d2bcd8a8434d05e6" category="inline-link-macro-rx"></block></block>
  <block id="ccb0658b39bdba7456d6a536d2d07732" category="summary">使用 Trident 的安装程序可以自定义属性。</block>
  <block id="eabcee1fa9f08716f26be6d1b73360fe" category="paragraph">使用 Trident 安装程序可以自定义属性。例如，如果已将 Trident 映像复制到专用存储库，则可以使用 ` -trident 映像` 指定映像名称。如果您已将 Trident 映像以及所需的 CSI sidecar 映像复制到专用存储库，则最好使用 ` -image-regRegistry` 开关指定该存储库的位置，该开关的格式为 ` &lt; 注册表 FQDN&gt;[ ： port]` 。</block>
  <block id="6fdfbf3444ce4e12e3375405bdd10237" category="paragraph">要让 Astra Trident 自动为您配置工作节点，请使用 ` -enable-node-prep` 。有关其工作原理的详细信息，请参见 <block ref="144c3ced0f46507a846b2964eace5739" category="inline-link-macro-rx"></block>。</block>
  <block id="d924f91616fe4accc876113a346ee8ad" category="admonition">自动员工节点准备是一项 * 测试版功能 * ，仅用于非生产环境。</block>
  <block id="8355509d170c8a61d236e927a5fcc6e2" category="paragraph">如果您使用的是 Kubernetes 的分发版本，其中 `kubelet` 将其数据保存在通常的 ` /var/lib/kubelet` 以外的路径上，则可以使用 ` -kubelet-dir` 指定备用路径。</block>
  <block id="47cd697cf3c9dcf916f70a0007956c1d" category="paragraph">如果您需要自定义安装，使其超出安装程序参数的允许范围，则还可以自定义部署文件。使用 ` -generate-custom-yaml` 参数可在安装程序的 `setup` 目录中创建以下 YAML 文件：</block>
  <block id="0858f0ee003d52951161848adffe1b31" category="list-text">`trident — clusterrolebinding 。 yaml`</block>
  <block id="af73689aedfa47bd2a7cf144917b0642" category="list-text">`trident 部署。 yaml`</block>
  <block id="1d53fd876245951bb003eb47849ff39d" category="list-text">`trident — crds.yaml`</block>
  <block id="b17dbe8acaeca82c72d25948de03eefc" category="list-text">`trident 集群角色。 yaml`</block>
  <block id="ecb2b56a094cc1cbd3ac263b23d91f8b" category="list-text">`trident — demonset.yaml`</block>
  <block id="c5e462ae653234d0ea0e98a000e62a97" category="list-text">`trident service.yaml`</block>
  <block id="f1347677de6873f8ddce6d736cba9a63" category="list-text">`trident 命名空间 .yaml`</block>
  <block id="2539c7e25ada2a2cdae0eb4c4633b893" category="list-text">`trident 服务帐户。 yaml`</block>
  <block id="385d099ed91e83dbe20ea05fbed68e22" category="paragraph">生成这些文件后，您可以根据需要对其进行修改，然后使用 ` -use-custom-yaml` 安装自定义部署。</block>
  <block id="237bc513b62b16e8ddd1661150fb7f94" category="summary">您可以使用 Trident 操作员部署 Astra Trident 。您可以手动或使用 Helm 部署 Trident 操作员。</block>
  <block id="cba9c445dab954e3483f9e5bef9f12c5" category="doc">使用 Trident 操作员进行部署</block>
  <block id="4a052772dca278b7be31d54ca9f21831" category="inline-link-macro">基本概念</block>
  <block id="e029dd3737acab556b62bda0be50840c" category="admonition">如果您尚未熟悉 <block ref="0342248ee22d08eaf42465a29ddd67ec" category="inline-link-macro-rx"></block>，现在是一个实现这一目标的好时机。</block>
  <block id="df2aaa5fa27e9bdafcb6bb0a4367b7d6" category="paragraph">要部署 Astra Trident ，应满足以下前提条件：</block>
  <block id="3a1ac050b1160a02cbd3c9ea84228191" category="list-text">您可以访问受支持的 NetApp 存储系统。</block>
  <block id="6a477d2ddba6ea3bc12088f821ce4e64" category="list-text">您可以从所有 Kubernetes 工作节点挂载卷。</block>
  <block id="6d8c90e9c1152c55e27e8166d128b927" category="list-text">您安装了一个安装了 `kubectl` （如果使用的是 OpenShift ，则为 `oc` ）的 Linux 主机，并将其配置为管理要使用的 Kubernetes 集群。</block>
  <block id="c40e5b69838954fb37e4c3a433e341a8" category="list-text">您已将 `KUBECONFIG` 环境变量设置为指向 Kubernetes 集群配置。</block>
  <block id="fe116e93fbfba0aec359f5fde363784c" category="inline-link-macro">Astra Trident 所需的功能门</block>
  <block id="6cb07e07cf0a13978f0d7384acc48f1a" category="list-text">您已启用 <block ref="53fb1a9f15d8db1182d68d20590366cf" category="inline-link-macro-rx"></block>。</block>
  <block id="dd3de2609b612d76ef4c71b97b8d6100" category="inline-link">按照其步骤启用 CLI 访问</block>
  <block id="c585967fa32d82c5e3c24bd63926c6a0" category="list-text">如果您将 Kubernetes 与 Docker Enterprise 结合使用，<block ref="57562caf1c76e1a261b7e2f8c3d113f9" category="inline-link-rx"></block>。</block>
  <block id="b430504ce0f6755a2be91a9a221c144e" category="paragraph">明白了吗？太棒了！让我们开始吧。</block>
  <block id="f9589cad119238efbce2b063d5225fb4" category="section-title">使用 Helm 部署 Trident 操作员</block>
  <block id="8a414e5c564a0c9e7a0f799a3c8cf47c" category="paragraph">执行列出的步骤以使用 Helm 部署 Trident 操作员。</block>
  <block id="dc2d0674739dcd145f5287a7d619ee05" category="paragraph">除了上述前提条件之外，要使用 Helm 部署 Trident 操作员，还需要满足以下条件：</block>
  <block id="8f5e62e2d03d87aeaafa8d4776fb7a79" category="list-text">Kubernetes 1.17 及更高版本</block>
  <block id="2e1b3f44683eee188be985693c4af5e1" category="list-text">Helm 版本 3</block>
  <block id="8a247589aa6f5931b3416e5dd64ba361" category="inline-link">Trident GitHub</block>
  <block id="c8435da18bdd7e5fe967b241d24c9849" category="list-text">从下载安装程序包<block ref="27269fc0a05ad3df94013b630291d22b" category="inline-link-rx"></block> 页面。安装程序包的 ` /helm` 目录中包含 Helm 图表。</block>
  <block id="bfd69e00e956b426c17001fc7ae7afbe" category="list-text">使用 `helm install` 命令并为您的部署指定一个名称。请参见以下示例：</block>
  <block id="e366a20246a41520da551be510c1d658" category="paragraph">在安装期间，可以通过两种方式传递配置数据：</block>
  <block id="a61e25800624ce452a1c4082ce082d9b" category="list-text">` 值` （或 ` f` ）：指定包含覆盖的 YAML 文件。可以多次指定此值，最右侧的文件将优先。</block>
  <block id="7dc8a47a7055ee868486daae4c256916" category="list-text">` -set` ：在命令行上指定覆盖。</block>
  <block id="f64fcf716c27478cdc36b1f36306d5eb" category="paragraph">例如，要更改默认值 `debug` ，请运行以下 ` -set` 命令：</block>
  <block id="24da04b0777d00c6fe43de99895058bd" category="paragraph">Helm 图表中的 `values.yaml` 文件提供了键及其默认值的列表。</block>
  <block id="1294c366742670bd28702f7cafffc981" category="paragraph">`Helm list` 显示有关安装的详细信息，例如名称，命名空间，图表，状态， 应用程序版本，修订版号等。</block>
  <block id="3470548c691fb90c7ea544350c2c7052" category="section-title">手动部署 Trident 操作员</block>
  <block id="8f3f1888bbf317edb14f0f439c7d142f" category="paragraph">执行列出的步骤以手动部署 Trident 操作员。</block>
  <block id="f7fca6c4035d50dff676b2d20fe511ba" category="section-title">第 1 步：确定 Kubernetes 集群的资格</block>
  <block id="ea8cda06a0e70ad34c1b9ab1b7135105" category="inline-link-macro">支持的 Kubernetes 集群</block>
  <block id="619cde7335e798082dc3bfdbe30708a0" category="paragraph">首先，您需要登录到 Linux 主机并验证它是否正在管理 _b工作 _ ， <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 您具有所需权限。</block>
  <block id="e420b75ec3bc014e3f69c43b2383768b" category="admonition">使用 OpenShift 时，在以下所有示例中使用 `oc` 而不是 `kubectl` ，并首先以 * 系统： admin* 的身份运行 `oc login -u system ： admin` 或 `oc login -u Kube-admin` 进行登录。</block>
  <block id="d14fa1adb2805f01b2a616f5ef9d25be" category="paragraph">要查看您是否具有 Kubernetes 集群管理员权限，请运行以下命令：</block>
  <block id="f67b776be47148789a46badee3f77607" category="paragraph">要验证是否可以从 Docker Hub 启动使用映像的 POD 并通过 Pod 网络访问存储系统，请运行以下命令：</block>
  <block id="b51ca564a2763a36e8eff661a1e45814" category="section-title">第 2 步：下载并设置操作员</block>
  <block id="2078c81a90072659fba28be2f6863a52" category="admonition">从 21.01 开始， Trident 操作符的范围为集群范围。使用 Trident 操作符安装 Trident 需要创建 `TridentOrchestrator` Custom Resource Definition （ CRD ）并定义其他资源。在安装 Astra Trident 之前，您应执行以下步骤来设置操作员。</block>
  <block id="76e266ddd09c36b072fda03f840a24df" category="list-text">下载最新版本的<block ref="d4cf8040e05d7d00be7e40a7abf8ee09" category="inline-link-rx"></block> 从 _Downloads_部分 中提取该文件。</block>
  <block id="f3d3e6090d613a233f190256fd5f4fa3" category="list-text">使用适当的 CRD 清单创建 `TridentOrchestrator` CRD 。然后，您可以稍后创建一个 `TridentOrchestrator` Custom Resource ，以通过操作员实例化安装。</block>
  <block id="337d79852891a37d41285c9101c3fff4" category="paragraph">运行以下命令：</block>
  <block id="2fd9409a1ac929d355820ffd5accc531" category="list-text">创建 `TridentOrchestrator` CRD 后，创建操作员部署所需的以下资源：</block>
  <block id="cb410399b5d1d9b73f065ed14123f45d" category="list-text">操作员的 ServiceAccount</block>
  <block id="8078c9a60d1b454fe7572e23c307625e" category="list-text">对 ServiceAccount 执行 ClusterRole 和 ClusterRoleBinding</block>
  <block id="5e5472e17b92112eb99dbbae729e1a4b" category="list-text">专用的 PodSecurityPolicy</block>
  <block id="dbbf8c6ec95775d28c3c6da1878bf8c3" category="list-text">运算符本身</block>
  <block id="3eb35ab5560d306167480f5846c3f66a" category="paragraph">Trident 安装程序包含用于定义这些资源的清单。默认情况下，操作符部署在 `trident` 命名空间中。如果 `trident` 命名空间不存在，请使用以下清单创建一个。</block>
  <block id="9d010a8f9df48de6abe7351f048fe2f7" category="list-text">要在非默认 `trident` 命名空间中部署运算符，您应更新 `serviceaccount.yaml` ， `clusterrolebinding.yaml` 和 `operator.yaml` 清单并生成您的 `bundle.yaml` 。</block>
  <block id="16f1c44dd25afde65aacbc201617651f" category="paragraph">运行以下命令以更新 YAML 清单并使用 `kucstation.yaml` 生成您的 `bundle.yaml` ：</block>
  <block id="05f465d1f3f89d87686947655659abc3" category="paragraph">运行以下命令以创建资源并部署操作员：</block>
  <block id="a0fa1784e85c80577b8b123157bd45da" category="list-text">要在部署后验证操作员的状态，请执行以下操作：</block>
  <block id="1c76f442bb494f18915f305a59518ed1" category="paragraph">操作员部署成功创建了一个在集群中的一个工作节点上运行的 POD 。</block>
  <block id="a770ca95121cc795b602f9af6af024fb" category="admonition">在 Kubernetes 集群中只能有 * 一个操作符实例 * 。请勿创建 Trident 操作员的多个部署。</block>
  <block id="b22134de94bce671f8ac945536b7497c" category="section-title">第 3 步：创建 TridentOrchestrator 并安装 Trident</block>
  <block id="5693b155707eefef50a904b3b1523862" category="paragraph">现在，您可以使用操作员安装 Astra Trident 了！这需要创建 `TridentOrchestrator` 。Trident 安装程序附带了用于创建 `TridentOrchestrator` 的示例定义。这将在 `trident` 命名空间中启动安装。</block>
  <block id="eda3cb9b284c6edd303631dd83beca97" category="inline-link-macro">自定义 Trident 部署</block>
  <block id="df1a9b2505f9a695dab238c459f4c11e" category="paragraph">使用 Trident 操作符，您可以使用 `TridentOrchestrator` 规范中的属性自定义 Astra Trident 的安装方式。请参见 <block ref="5d22c6b05e889509f3b16bf34345783f" category="inline-link-macro-rx"></block>。</block>
  <block id="f463fa7de78b2d3c00a2d47f9fc4ca50" category="paragraph">状态 `TridentOrchestrator` 指示安装是否成功，并显示已安装的 Trident 版本。</block>
  <block id="ec53a8c4f07baed5d8825072c89799be" category="cell">Status</block>
  <block id="2763f33c904a183bd0ef06f9c4fb4403" category="cell">安装</block>
  <block id="64162845794ff7262e665deec58a84f5" category="cell">操作员正在使用此 `TridentOrchestrator` CR 安装 Astra Trident 。</block>
  <block id="98dd43dfae05b11befe1f140e0ec787a" category="cell">已安装</block>
  <block id="2fe2cc0adf9b69a871d33ba220695cd4" category="cell">Astra Trident 已成功安装。</block>
  <block id="c2aaea4dacecce78b34302e41fcef75e" category="cell">正在卸载</block>
  <block id="c27ff0e050a671f2eab32a372c9636bd" category="cell">操作符正在卸载 Astra Trident ，因为 `sPec.uninstall=true` 。</block>
  <block id="b78846123fdd78d5ab62451b855194e3" category="cell">已卸载</block>
  <block id="f8a32612e33c768b5fa0dd033d91ce8d" category="cell">Astra Trident 已卸载。</block>
  <block id="d7c8c85bf79bbe1b7188497c32c3b0ca" category="cell">失败</block>
  <block id="273b9a9e933220f1963cbac7a7a46645" category="cell">操作员无法安装，修补，更新或卸载 Astra Trident ；操作员将自动尝试从此状态恢复。如果此状态仍然存在，则需要进行故障排除。</block>
  <block id="6909beea5b50605780e3411f879fe916" category="cell">正在更新</block>
  <block id="3201d58137fab497dea740d761a9733b" category="cell">操作员正在更新现有安装。</block>
  <block id="902b0d55fddef6f8d651fe1035b7d4bd" category="cell">error</block>
  <block id="efaeca66375c8663b6d1d64f4886f267" category="cell">不使用 `TridentOrchestrator` 。另一个已存在。</block>
  <block id="e09245effc62059e51f926fad603e413" category="inline-link-macro">故障排除</block>
  <block id="06a69b41e25711d4ae5a561ed9518f18" category="paragraph">在安装期间， `TridentOrchestrator` 的状态会从 `Installing` 更改为 `Installed` 。如果您观察到 `failed` 状态，并且操作员无法自行恢复，则应检查操作员的日志。请参见 <block ref="d5a4e07afa9c1e3e2869e1c17ce11b3d" category="inline-link-macro-rx"></block> 部分。</block>
  <block id="a62e37b5d24190e57c50856ed67d1f30" category="paragraph">您可以通过查看已创建的 Pod 来确认 Astra Trident 安装是否已完成：</block>
  <block id="cb61ddc6afc630830f76a754c29c509e" category="paragraph">您也可以使用 `tridentctl` 检查已安装的 Astra Trident 版本。</block>
  <block id="1c3da07a8a73bf0d4070c8c4b10d14c8" category="inline-link-macro">部署后任务</block>
  <block id="017115d0fb78b96eca56297dcaae750a" category="paragraph">现在，您可以继续创建后端。请参见 <block ref="6bfdfe984198635473da869595980b46" category="inline-link-macro-rx"></block>。</block>
  <block id="a03102a9f58cbddc7c8c4a6a8e198bc0" category="admonition">有关在部署期间排除问题的信息，请参见 <block ref="d5a4e07afa9c1e3e2869e1c17ce11b3d" category="inline-link-macro-rx"></block> 部分。</block>
  <block id="732d0805e41f2db48aa120c357324ee4" category="summary">您可以使用 Trident 运算符或使用 `tridentctl` 来部署 Astra Trident 。</block>
  <block id="42f8643eb52a942747937327c72c8361" category="doc">部署概述</block>
  <block id="2a4a70c87489dab5d6f93148a8c11c3d" category="section-title">选择部署方法</block>
  <block id="c41362d320971e4e8dbaa3c6a25fbdf8" category="paragraph">要确定要使用的部署方法，请考虑以下几点：</block>
  <block id="6e43a74295a2af0eedc17051e56d7e1c" category="section-title">为什么要使用 Trident 运算符？</block>
  <block id="4f5dbc74e3448e08fe0e7bfd62876fc8" category="inline-link-macro">Trident 运算符</block>
  <block id="567dcfd6302e5511c1b546a4df21a679" category="inline-link-macro">要求</block>
  <block id="eed9d9604d323a4bec2ced419db3354b" category="paragraph">。 <block ref="78ab30a4c6a9648b8dd64a71e4da2aa2" category="inline-link-macro-rx"></block> 是动态管理 Astra Trident 资源并自动完成设置阶段的绝佳方式。必须满足某些前提条件。请参见 <block ref="746f08a8296c9ad74e67283046d6876c" category="inline-link-macro-rx"></block>。</block>
  <block id="6f5bda8b751f36b2d937ca475d3d67ed" category="paragraph">Trident 运算符提供了以下几项优势。</block>
  <block id="ae2987cb5fe6e18d8d8713ac5616010c" category="section-title">自我修复功能</block>
  <block id="48b572c20004f23dbcac3e03dede686a" category="paragraph">您可以监控 Astra Trident 安装并主动采取措施来解决问题，例如删除部署或意外修改部署的时间。将此操作员设置为部署时，将创建 `trident 操作符 -&lt;generated -id&gt;` Pod 。此 POD 会将 `Trident Orchestrator` CR 与 Astra Trident 安装关联起来，并始终确保只有一个活动的 `TridentOrchestrator` 。换言之，操作员可确保集群中只有一个 Astra Trident 实例并控制其设置，从而确保安装有效。对安装进行更改（例如删除部署或节点取消设置）时，操作员会识别这些更改并逐个修复它们。</block>
  <block id="69ef8379c893c23746ed9a34e42c57c7" category="section-title">轻松更新现有安装</block>
  <block id="0f2d0458d6fc7f6d4317735207021e82" category="paragraph">您可以使用操作员轻松更新现有部署。您只需编辑 `TridentOrchestrator` CR 即可更新安装。例如，请考虑需要启用 Astra Trident 以生成调试日志的情形。</block>
  <block id="9b5a5950e97bab4497fbaaaf8c5fadc8" category="paragraph">为此，请修补您的 `TridentOrchestrator` 以将 `spec.debug` 设置为 `true` ：</block>
  <block id="c9534512c045771d255bf1068862beec" category="paragraph">更新 `TridentOrchestrator` 后，操作员将处理更新并修补现有安装。这可能会触发创建新 Pod 以相应地修改安装。</block>
  <block id="1b77eea7dc5cf10bc0ad9e1c69131aae" category="section-title">自动处理 Kubernetes 升级</block>
  <block id="f456a413d0506028374e871768a5f176" category="paragraph">当集群的 Kubernetes 版本升级到受支持的版本时，操作员会自动更新现有的 Astra Trident 安装并进行更改，以确保其满足 Kubernetes 版本的要求。</block>
  <block id="d1aae6ea63eb5e7fe6a9fcea5f671406" category="admonition">如果集群升级到不受支持的版本，则操作员会阻止安装 Astra Trident 。如果已随操作员安装了 Astra Trident ，则会显示一条警告，指示 Astra Trident 安装在不受支持的 Kubernetes 版本上。</block>
  <block id="fc6b134742229ab95b893ec9c711b3f2" category="section-title">为什么要使用 Helm ？</block>
  <block id="9326f3d9245c1501e5438ffa40011972" category="paragraph">如果您还有其他要使用 Helm 管理的应用程序，从 Astra Trident 21.01 开始，您也可以使用 Helm 管理您的部署。</block>
  <block id="0f22c891238a7408704280567046b005" category="section-title">何时应使用 tridenctl ？</block>
  <block id="c67fd1b99934afa248dfeb285a9a4191" category="inline-link-macro">Tridentctl</block>
  <block id="5e8800ee18d9ba2737f70cf6fea5358c" category="paragraph">如果您的现有部署必须升级到，或者您希望对部署进行高度自定义，则应查看使用 <block ref="bbba36f756eac01f0bd418bf08e6f580" category="inline-link-macro-rx"></block>。这是部署 Astra Trident 的传统方法。</block>
  <block id="992d57abd493d38bda22d9ebcaaee856" category="section-title">在部署方法之间移动时的注意事项</block>
  <block id="4f4cd969ebbb49473d74a80bfd59025e" category="paragraph">不难想象需要在部署方法之间移动的情形。在尝试从 `tridentctl` 部署迁移到基于操作员的部署之前，应考虑以下事项，反之亦然：</block>
  <block id="62f2d30ac579a0d9c48f7e9af4709419" category="list-text">卸载 Astra Trident 时，请始终使用相同的方法。如果已使用 `tridentctl` 进行部署，则应使用适当版本的 `tridentctl` 二进制文件卸载 Astra Trident 。同样，如果要使用操作员进行部署，则应编辑 `TridentOrchestrator` CR 并设置 `sPec.uninstall=true` 以卸载 Astra Trident 。</block>
  <block id="6c85b80ffcdbeb3004a53881f1c1517d" category="list-text">如果您要删除基于操作员的部署并使用 `tridentctl` 来部署 Astra Trident ，则应先编辑 `TridentOrchestrator` 并设置 `sPec.uninstall=true` 以卸载 Astra Trident 。然后删除 `TridentOrchestrator` 和操作员部署。然后，您可以使用 `tridentctl` 进行安装。</block>
  <block id="67ccf99745298db9f1f4f60c814a2b14" category="list-text">如果您使用的是基于操作员的手动部署，并且要使用基于 Helm 的 Trident 操作员部署，则应先手动卸载此操作员，然后再执行 Helm 安装。这样， Helm 就可以使用所需的标签和标注来部署 Trident 操作员。如果不执行此操作，则基于 Helm 的 Trident 操作员部署将失败，并显示标签验证错误和标注验证错误。如果您使用的是基于 `tridentctl` 的部署，则可以使用基于 Helm 的部署，而不会出现问题。</block>
  <block id="30c8006f6e30b48cb471941d09dc21cc" category="section-title">了解部署模式</block>
  <block id="47bd3e1ef636594512d55b147acaaff7" category="paragraph">部署 Astra Trident 的方法有三种。</block>
  <block id="e9ae623c81f6793165935a11caf208d7" category="section-title">标准部署</block>
  <block id="1c116faa754a12fc9d2268596b076e8e" category="paragraph">在 Kubernetes 集群上部署 Trident 会导致 Astra Trident 安装程序执行以下两项操作：</block>
  <block id="2344f699f8a17dcc73e51dd0cebc6f44" category="list-text">通过 Internet 提取容器映像</block>
  <block id="3571f2c25b314afef195d39c88bd9f51" category="list-text">创建部署和 / 或节点取消设置，以便在 Kubernetes 集群中所有符合条件的节点上启动 Astra Trident Pod 。</block>
  <block id="7c3f361ece5e08ed30d45bef79680ec2" category="paragraph">此类标准部署可以通过两种不同的方式执行：</block>
  <block id="3ee6b5e142a466872153196fc7ef6dcc" category="list-text">使用 `tridentctl install`</block>
  <block id="80bede3741fe5e63f3218cf6d74c7a18" category="list-text">使用 Trident 运算符。您可以手动或使用 Helm 部署 Trident 操作员。</block>
  <block id="33515d7582595afb015b366316a74170" category="paragraph">此安装模式是安装 Astra Trident 的最简单方法，适用于大多数不会实施网络限制的环境。</block>
  <block id="2b4393c0483ca76851a031e3e29fa399" category="section-title">脱机部署</block>
  <block id="8b115025dda49a5d962758844e90a452" category="inline-link">Trident 映像</block>
  <block id="72df3b7d5f8e79581be68db816189e82" category="inline-link">Trident AutoSupport 映像</block>
  <block id="bce707f4572096decf6c60bb5636eefb" category="paragraph">要执行空映射部署，您可以在调用 `tridentctl install` 时使用 ` -image-regRegistry` 标志来指向私有映像注册表。如果使用 Trident 操作符进行部署，则也可以在 `TridentOrchestrator` 中指定 `sPec.imageRegistry` 。此注册表应包含<block ref="2352a006645179366e38df69d0f9f618" category="inline-link-rx"></block>，<block ref="7bacde8b4a2cd45903f29d77cc1c5e5e" category="inline-link-rx"></block>和 Kubernetes 版本所需的 CSI sidecar 映像。</block>
  <block id="91255a4adf69521acddc8c1d55903014" category="paragraph">要自定义部署，您可以使用 `tridentctl` 为 Trident 的资源生成清单。其中包括 Astra Trident 在安装过程中创建的部署，取消设置，服务帐户和集群角色。</block>
  <block id="4c774e8a2d80dbc16b0bf55be6c7b358" category="paragraph">有关自定义部署的详细信息，请参见以下链接：</block>
  <block id="711011f15ff69da45006043e93ed8981" category="inline-link-macro">自定义基于操作员的部署</block>
  <block id="8f863c0ccd38c8782b36eedbea08fc5b" category="list-text"><block ref="8f863c0ccd38c8782b36eedbea08fc5b" category="inline-link-macro-rx"></block></block>
  <block id="85cda507040c129ee606d4d8df583b90" category="inline-link-macro">自定义基于 `tridentctl` 的部署</block>
  <block id="16486d6f9e6411719306bdb76f0b34fa" category="list-text"><block ref="16486d6f9e6411719306bdb76f0b34fa" category="inline-link-macro-rx"></block></block>
  <block id="d18dc7a4e8caf207dc9c1b49eda35b70" category="admonition">如果您使用的是私有映像存储库，则应在专用注册表 URL 的末尾添加 ` /k8scsi` （对于 1.17 之前的 Kubernetes 版本）或 ` /SIG-storage` （对于 1.17 之后的 Kubernetes 版本）。在使用私有注册表进行 `tridentctl` 部署时，应将 ` -trident 映像` 和 ` -autosupport-image` 与 ` -image-regRegistry` 结合使用。如果要使用 Trident 操作符部署 Astra Trident ，请确保 Orchestrator CR 在安装参数中包含 `tridentImage` 和 `autosupportImage` 。</block>
  <block id="47c0166da57a75ed65ddb766c838a91c" category="section-title">远程部署</block>
  <block id="761bf14d8b8339a8f345e63dc12c36bb" category="paragraph">下面简要概述了远程部署过程：</block>
  <block id="37dbca6cb8ca55a471ebc072575c0a46" category="list-text">在要部署 Astra Trident 的远程计算机上部署适当版本的 `kubectl` 。</block>
  <block id="02ed10abbc71334918b1acb54df6e3f3" category="list-text">从 Kubernetes 集群复制配置文件，并在远程计算机上设置 `KUBECONFIG` 环境变量。</block>
  <block id="da693b77cde91654c6296abe8f901988" category="list-text">启动 `kubectl get nodes` 命令，验证您是否可以连接到所需的 Kubernetes 集群。</block>
  <block id="df65ec31c6f96e95301e3c6ff8863335" category="list-text">使用标准安装步骤从远程计算机完成部署。</block>
  <block id="13c852fce58f7c6981fa0a952dcd76af" category="summary">使用 Trident 操作符，您可以使用 `TridentOrchestrator` 规范中的属性自定义 Astra Trident 的安装方式。</block>
  <block id="b9d69225e5cf4da0389ed6b1f6b66a10" category="doc">自定义 Trident 操作员部署</block>
  <block id="541de2d8e93ee6c623dfc11938d0e83a" category="paragraph">通过 Trident 操作符，您可以使用 `TridentOrchestrator` 规范中的属性自定义 Astra Trident 的安装方式。</block>
  <block id="02e0835b3015839cde731027c217d70b" category="paragraph">有关属性列表，请参见下表：</block>
  <block id="83f499a540b1323009c200d6f8cc9396" category="cell">参数</block>
  <block id="7a1920d61156abc05a60135aefe8bc67" category="cell">Default</block>
  <block id="f3f30d479f6e3b393d917a3b2f88c770" category="cell">`命名空间`</block>
  <block id="c9db68ea6cff44f42ac5acbbfccec399" category="cell">用于安装 Astra Trident 的命名空间</block>
  <block id="9aa82da0cffe247b84587c1cc8e32746" category="cell">default</block>
  <block id="a67cf6b087ff88dbfacec8375928995c" category="cell">`debug`</block>
  <block id="4f72bc786a1a01d5a1a8bc09d33334cc" category="cell">为 Astra Trident 启用调试</block>
  <block id="68934a3e9455fa72420237eb05902327" category="cell">false</block>
  <block id="16e20a5ba5cd6442f3cdd49b16e8a5f3" category="cell">`使用 IPv6`</block>
  <block id="3dd791c4864e77ae6cf11572e2d7b374" category="cell">安装基于 IPv6 的 Astra Trident</block>
  <block id="077e99fe42ced522b462656cffffe09c" category="cell">`k8sTimeout`</block>
  <block id="4448b73eac083e33b7142f0e5790fac5" category="cell">Kubernetes 操作超时</block>
  <block id="e4d71bf2abad047425f4463e27bb83b0" category="cell">30 秒</block>
  <block id="42cf123e93ecc5c0297652edbc547fc0" category="cell">`sileAutoSupport`</block>
  <block id="4a213b7c3b997ffb0794b25909381d16" category="cell">不要自动向 NetApp 发送 AutoSupport 捆绑包</block>
  <block id="34d0f4a447cd1d7f59000d3be2c39320" category="cell">`enableNodePrep`</block>
  <block id="2472256a6487b0917d32f6a044a4e0ac" category="cell">自动管理工作节点依赖关系（ * 测试版 * ）</block>
  <block id="2bccac20e55391730a985f9819e1cc41" category="cell">`autosupport 映像`</block>
  <block id="84448c234dfdfd2a7367341fd4b56a80" category="cell">AutoSupport 遥测的容器映像</block>
  <block id="deb59c9b1f7c5aab7803950edd48fbdb" category="cell">"NetApp/trident autosupport ： 21.04.0"</block>
  <block id="f4a6821b04b9ce6b90148068341347b6" category="cell">`autosupport 代理`</block>
  <block id="7f54ca385f028308d19e228ce0534a47" category="cell">用于发送 AutoSupport 遥测的代理的地址 / 端口</block>
  <block id="256acfe307251e7444859851d87d5735" category="cell"><block ref="256acfe307251e7444859851d87d5735" category="inline-link-rx"></block></block>
  <block id="e9f06180af644cfa6e5d20bd67c03bc5" category="cell">`卸载`</block>
  <block id="076bc379a24183ce77834bac007ca852" category="cell">用于卸载 Astra Trident 的标志</block>
  <block id="cad060d2f14dbf08315c20014ed31daa" category="cell">`logFormat`</block>
  <block id="acfc4a8e6d53bad27d4e2d393bfff61e" category="cell">要使用的 Astra Trident 日志记录格式 [text ， json]</block>
  <block id="20cd815523e5806aec29a57282b0d49f" category="cell">文本</block>
  <block id="7610c5cc7910022402c4fbd450d889ce" category="cell">`TridentImage`</block>
  <block id="20f408a3276af1f7f1bf02ba374786ca" category="cell">要安装的 Astra Trident 映像</block>
  <block id="896185b87765c519346253a5f54ecbe4" category="cell">"NetApp/Trident ： 21.04"</block>
  <block id="8088435dc0e1c8b85217d850d3e7a602" category="cell">`imageRegistry`</block>
  <block id="4f25f4cca5c1939f4a728d2678e719f7" category="cell">内部注册表的路径，格式为 ` &lt; 注册表 FQDN&gt;[ ：端口 ]/subpath]`</block>
  <block id="1f147978ca8c4561ff70857129f3fa13" category="cell">"K8s.gcr.io/SIG-storage （ K8s 1.17+ ）或 quay.io/k8scsi "</block>
  <block id="e6b96cbb467923e86672bb25db5ecebb" category="cell">`kubeletDir`</block>
  <block id="31aad37dce0c28e12908582a0d63736a" category="cell">主机上的 kubelet 目录的路径</block>
  <block id="5b9febd4bd647dae5abfddaf99b9c540" category="cell">"/var/lib/kubelet"</block>
  <block id="b6e0e2c4168573f0ed61c842470342ba" category="cell">`wipeout`</block>
  <block id="4e33345575b5a443dec89767624a1ee8" category="cell">要删除以执行 Astra Trident 完全删除的资源列表</block>
  <block id="2d30d1348c4d2533a165827a22516caa" category="cell">`imagePullSecs`</block>
  <block id="f73bb4a0bc9913e7fc6db5f9e5f2afeb" category="cell">从内部注册表中提取映像的机密信息</block>
  <block id="d4d1a6713550b631ed2a47905a5ac4fa" category="admonition">在 `TridentOrchestrator` 中指定 `spec.namespace` ，以表示安装了哪个命名空间 Astra Trident 。此参数 * 安装 Astra Trident 后无法更新 * 。尝试执行此操作会导致 `TridentOrchestrator` 的状态更改为 `Failed` 。Astra Trident 不适用于跨命名空间迁移。</block>
  <block id="c1aa6523e4a912445f9d4b8b9fb560be" category="admonition">自动员工节点准备是一项 * 测试版功能 * ，仅用于非生产环境。</block>
  <block id="0b3c55a2173aa8e730bca967a8dd7cf5" category="paragraph">在定义 `TridentOrchestrator` 时，您可以使用上述属性自定义安装。以下是一个示例：</block>
  <block id="27421a0c5ebcff7855c7c87dc579b371" category="paragraph">如果您希望自定义安装超出 `TridentOrchestrator` 参数的允许范围，则应考虑使用 `tridentctl` 生成自定义 YAML 清单，以便您可以根据需要进行修改。</block>
  <block id="b9966b5f76510c4c81d397b732dc0ced" category="summary">首先查看支持的前端，后端和主机配置。</block>
  <block id="5a2ebfb8baa378cfcfcba58bbb1380c2" category="doc">要求</block>
  <block id="0582c93c9857a8b6d0380be79128eefc" category="admonition">要了解 Astra Trident 使用的端口，请参见 <block ref="c6b87a878d50568ac1e654ad3964af7b" category="inline-link-macro-rx"></block>。</block>
  <block id="c777be7f669397b0a376fe32ca5cd9c3" category="section-title">支持的前端（编排程序）</block>
  <block id="74aefc05d193afd5c50a0df882997656" category="paragraph">Astra Trident 支持多个容器引擎和流程编排程序，其中包括：</block>
  <block id="13ab6ee12e5d62b771a28d7c3a8de9fc" category="list-text">Kubernetes 1.17 或更高版本（最新版本： 1.22 ）</block>
  <block id="37696641960d6c73a7dadab603c1877e" category="list-text">Mirantis Kubernetes Engine 3.4</block>
  <block id="201eb37826a33e35adff9119f25946bd" category="paragraph">以下版本支持 Trident 操作符：</block>
  <block id="5596419ed8318cabbcb138ef27fd3035" category="inline-link">错误修复公告</block>
  <block id="3943a2e0490c50c43f31a486978ea80b" category="paragraph">Astra Trident 还可与其他许多完全托管和自我管理的 Kubernetes 产品结合使用，包括 Google Cloud 的 Google Kubernetes Engine （ GKS ）， AWS 的 Elastic Kubernetes Services （ EKS ）， Azure 的 Azure Kubernetes Service （ AKS ）和 Rancher 。</block>
  <block id="f787cd4b6963b13f12fa53131f58ef6c" category="section-title">支持的后端（存储）</block>
  <block id="843e2f0c722d25903a6010b62ac4f13b" category="paragraph">要使用 Astra Trident ，您需要以下一个或多个受支持的后端：</block>
  <block id="a3c559e0541e9bb860178ce6fe414224" category="list-text">适用于 GCP 的 Cloud Volumes Service</block>
  <block id="ff617c70912e62b6adb0266e42f9d4f5" category="list-text">FAS/AFF/ 选择 9.3 或更高版本</block>
  <block id="1d3d126b8a5bad69c46ed03734beed47" category="list-text">NetApp 全 SAN 阵列（ ASA ）</block>
  <block id="74b7fad26c712d18ff25fc7d7ae5a7a1" category="list-text">NetApp HCI/Element 软件 8 或更高版本</block>
  <block id="c7c7a6a5641f33e348244f9c43010e16" category="section-title">功能要求</block>
  <block id="8c67111ad59dd108156a3e7c9a32b63c" category="paragraph">下表总结了此版本的 Astra Trident 及其支持的 Kubernetes 版本提供的功能。</block>
  <block id="21021ea0e52be8e9c599f4dff41e5be0" category="cell">功能</block>
  <block id="80afba45eb055fc9bdc48c90d1debd06" category="cell">Kubernetes 版本</block>
  <block id="10f295a61d2a793ac8936a69cf458654" category="cell">是否需要功能安全门？</block>
  <block id="f336592ca417cff322b935bc0eeaff8f" category="cell">CSI Trident</block>
  <block id="51c52843a7958626357cfc8e1ef94e50" category="paragraph">1.17 及更高版本</block>
  <block id="e830b7e4d1fb7f84600876af87cb4381" category="cell">卷快照</block>
  <block id="ea8ed249117e76cb53766e218fe2b7c7" category="cell">卷快照中的 PVC</block>
  <block id="28dcded20f550dcad1bd9bb03a5bbe73" category="cell">iSCSI PV 调整大小</block>
  <block id="1673543ed032e46f3572ba65bc070693" category="cell">ONTAP 双向 CHAP</block>
  <block id="176e16df4faab1a1e06e9585c813d5fe" category="cell">动态导出策略</block>
  <block id="1f7219b07d5bce7feec002a9f4dc2201" category="cell">Trident 运算符</block>
  <block id="bf0d42cfb33347700a1060d7b0cf07c1" category="cell">自动工作节点准备（测试版）</block>
  <block id="443432948b68bb63d707ce7ecc4a021a" category="cell">CSI 拓扑</block>
  <block id="10ba4d981cc0f1ae131e16a64d3c2687" category="list-text">RedHat CoreOS 4.2 和 4.3</block>
  <block id="4fa506be8cc1c8c936a3eff8a374fe26" category="list-text">RHEL 或 CentOS 7.4 或更高版本</block>
  <block id="2d736ed9cdbf58b500e9715daeb267e6" category="list-text">Ubuntu 18.04 或更高版本</block>
  <block id="11ea58814ce429c3e3254a63f8cde7a4" category="paragraph">`tridentctl` 实用程序也可在 Linux 的任何这些分发版上运行。</block>
  <block id="13d80777c8fd43e555c1f5b1b72d7ef0" category="section-title">主机配置</block>
  <block id="62df396fbf0c4fd30e1e851335e8b26b" category="paragraph">根据所使用的后端，应在集群中的所有工作人员上安装 NFS 和 / 或 iSCSI 实用程序。请参见 <block ref="8e0b40cac942de59585b1131f9197d7b" category="inline-link-macro-rx"></block> 有关详细信息 ...</block>
  <block id="2139fe384d5ae165545994dff01961d9" category="section-title">存储系统配置：</block>
  <block id="923680056b0f0258907f498670b4ead1" category="section-title">容器映像以及相应的 Kubernetes 版本</block>
  <block id="a6595e492ec094375a673911109a32f2" category="paragraph">对于带气的安装，请参见以下列表，了解安装 Astra Trident 需要哪些容器映像：</block>
  <block id="aa92c4c233bc01609d957e469736b699" category="cell">容器映像</block>
  <block id="3b29886980a3307188a882bdc7cad63b" category="cell">v1.17.0</block>
  <block id="ca2e728c8f17fef48811518aaed4de43" category="list-text">K8s.gcr.io/SIG-storage/CsI-snapshotter ： v3.0.3</block>
  <block id="b8f1a143b913482d06bc0abdd94e9fc7" category="cell">v1.18.0</block>
  <block id="79f59ba516b478a970a428a795414034" category="cell">v1.19.0</block>
  <block id="4b977ef7367155e20f954fe7b0a00c4f" category="cell">v1.20.0</block>
  <block id="6f0b081bef5e745ef2429ef74472d9bd" category="cell">v1.21.0</block>
  <block id="721d66fc3896f0caf2122a92b3f1c017" category="admonition">在 Kubernetes 1.20 及更高版本上，只有当 `v1` 版本提供了 `volumesnapshots.snapshot.storage.k8s.io` CRD 时，才使用经过验证的 `K8s.gcr.io/SIG-storage/CsI-snapshotter ： v4.x` image 。如果 `v1bea1` 版本在使用 / 不使用 `v1` 版本的情况下为 CRD 提供服务，请使用经验证的 `K8s.gcr.io/SIG-storage/CsI-snapshotter ： v3.x` 映像。</block>
  <block id="a60c2f57df655a9ac5fcaa0750886195" category="summary">如果您刚刚开始使用 Kubernetes ，请按照说明安装 Kubernetes 以进行尝试。这些说明提供了一个裸机单节点集群， Trident 可以与此集群集成以供演示。</block>
  <block id="62bdbe048d174b559cb770f9ebaf0895" category="doc">试用</block>
  <block id="e8dadc588901af436e2c6036acf23973" category="inline-link-macro">NetApp 试用</block>
  <block id="476652843c9581434ab31739d97c955a" category="paragraph">NetApp 提供了一个可随时使用的实验室映像，您可以通过该映像进行请求 <block ref="eb9c34df0ed196dd801ef85207c8bf2c" category="inline-link-macro-rx"></block>。此测试驱动器为您提供了一个沙盒环境，该环境附带安装和配置了三节点 Kubernetes 集群和 Astra Trident 。这是熟悉 Astra Trident 并了解其功能的好方法。</block>
  <block id="8685ac2061f9dca7ab48f41e0871f7af" category="inline-link-macro">《 kubeadm 安装指南》</block>
  <block id="37bdb0f602c1d2a2a6f285533e4ce5c8" category="paragraph">另一个选项是查看 <block ref="c7dbb75618a5e106a360075f923cb87f" category="inline-link-macro-rx"></block> 由 Kubernetes 提供。</block>
  <block id="2cf0c4e99dd3c0b2e7e0f63af3531622" category="admonition">您不应在生产环境中使用使用这些说明构建的 Kubernetes 集群。使用您的分发版提供的生产部署指南创建可随时投入生产的集群。</block>
  <block id="e3ecede511471cf67c294e427e2f012e" category="paragraph">如果这是您第一次使用 Kubernetes ，请熟悉相关概念和工具 <block ref="22f850f308b2d2016502017a1dcd1044" category="inline-link-macro-rx"></block>。</block>
  <block id="aa452927f1dec9709a523a0de496d6c5" category="summary">您可以使用 `tridentctl` 来部署 Astra Trident 。</block>
  <block id="be932f6f71d4b0b1a7f80c2e5b584b34" category="admonition">要自定义部署，请参见 <block ref="b336c95c8f5c7bbe82e004b1378c2302" category="inline-link-macro-rx"></block>。</block>
  <block id="6a64bc5a34f75dde015dc7dd8ece8c61" category="list-text">您对受支持的 Kubernetes 集群具有完全权限。</block>
  <block id="ed000d2029e135f34f854fa4e820940b" category="admonition">有关自定义部署的信息，请参见 <block ref="b336c95c8f5c7bbe82e004b1378c2302" category="inline-link-macro-rx"></block>。</block>
  <block id="665cf0ff23392f7e380041a2b34a5f5a" category="paragraph">首先，您需要登录到 Linux 主机并验证它是否正在管理 _b工作 _ ， <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 您具有所需权限。</block>
  <block id="8a0f5f61d4ea2fb3a2f0ee6de4b7cf40" category="admonition">使用 OpenShift 时，您可以在以下所有示例中使用 `oc` 而不是 `kubectl` ，并且应首先以 * 系统： admin* 的身份登录，方法是运行 `oc login -u system ： admin` 或 `oc login -u Kube-admin` 。</block>
  <block id="09ea6b05f579a1e9903c54dfcd6a0dc9" category="paragraph">要检查 Kubernetes 版本，请运行以下命令：</block>
  <block id="b80293f6b9048d95e7f975e831ef4da6" category="paragraph">确定 Kubernetes 服务器版本。您将在安装 Astra Trident 时使用它。</block>
  <block id="57786106edaa9a7d85847431f0aa5559" category="section-title">第 2 步：下载并提取安装程序</block>
  <block id="f838f032d9e83a6229936c3a7784f752" category="admonition">Trident 安装程序将创建 Trident Pod ，配置用于保持其状态的 CRD 对象，并初始化执行配置卷和将卷附加到集群主机等操作的 CSI sidecars 。</block>
  <block id="92c4cf66727cb67866ebf0c3ec416382" category="paragraph">您可以下载最新版本的<block ref="e796e94083ba305bee55a53ec1dc755d" category="inline-link-rx"></block> 从 _Downloads_部分 中提取该文件。</block>
  <block id="31dfa917b0ab09bc8fa9aa62c5b68b9b" category="paragraph">例如，如果最新版本为 21.07.1 ：</block>
  <block id="9b7632bed019c72ffa74193e1808fd78" category="section-title">第 3 步：安装 Astra Trident</block>
  <block id="326f6498f188018e71d4ea9c3a240042" category="paragraph">执行 `tridentctl install` 命令，在所需命名空间中安装 Astra Trident 。</block>
  <block id="ed1112be79a7a22fdbf9b294f3ed718b" category="paragraph">安装程序完成后，其外观将会如此。根据 Kubernetes 集群中的节点数，您可能会发现更多 Pod ：</block>
  <block id="e3828f7a456f3c91d25ec19bbf457e6d" category="paragraph">如果您看到与上述示例类似的输出，则表示您已完成此步骤，但尚未完全配置 Astra Trident 。请继续执行下一步。请参见 <block ref="6bfdfe984198635473da869595980b46" category="inline-link-macro-rx"></block>。</block>
  <block id="a0015d3671af62700240db94388892fb" category="paragraph">但是，如果安装程序未成功完成或您未看到 * 正在运行 * `trident CSI -` ，则表示未安装此平台。</block>
  <block id="b928e0aee19c1e2cc91c85e8a0856936" category="summary">使用此处提供的指针排除安装和使用 Astra Trident 时可能遇到的问题。</block>
  <block id="231cf4c70d866b616c21baddaeed0696" category="doc">故障排除</block>
  <block id="8ef0ab9bbedaa7608c9abed7c7213218" category="admonition">要获得有关 Astra Trident 的帮助，请使用 `tridentctl logs -a -n trident` 创建支持包，并将其发送到 `NetApp 支持 &lt; 获取帮助 &gt;` 。</block>
  <block id="40e41fb2db11266b8f751c0d5c67cba0" category="inline-link">NetApp 知识库（需要登录）</block>
  <block id="01005ecf4349194d1ec13d0ba516c9e5" category="admonition">有关故障排除文章的完整列表，请参见<block ref="57f5c759ada931c6a2051314ca6ee99e" category="inline-link-rx"></block>。您还可以找到有关排除与 Astra 相关的问题的信息<block ref="695f48b1d8b7348c0e2828947d24161e" category="inline-link-rx"></block>。</block>
  <block id="163fb9eb00818e2c7109900db1a3cc82" category="section-title">常规故障排除</block>
  <block id="f504c27d1ad305a988958b64f34468cb" category="list-text">如果 Trident Pod 无法正常启动（例如，当 Trident Pod 停留在 `ContainerCreating` 阶段且已准备好的容器少于两个时），则运行 `kubectl -n trident describe deployment trident` and `kubectl -n trident describe pod trident -%%.%.%.* -***` 可以提供更多见解。获取 kubelet 日志（例如，通过 `jlogalctl -xeu kubelet` ）也会很有帮助。</block>
  <block id="87248f7afe198418bdbedd919695631e" category="list-text">您还可以通过在后端定义中包含 `debugTraceFlags` 来获取每个后端的调试日志。例如，包括 `debugTraceFlags ： ｛ "api" ： true ， "method " ： true ， ｝` 以获取 Trident 日志中的 API 调用和方法遍历。现有后端可以已配置 `debugTraceFlags` 并配置 `tridentctl 后端更新` 。</block>
  <block id="6cc37a0664d7f97f87d34eadef23dbad" category="list-text">使用 RedHat CoreOS 时，请确保在工作节点上启用了 `iscsid` 并默认启动。可以使用 OpenShift MachineConfigs 或修改点燃模板来完成此操作。</block>
  <block id="4582245538a41243a95713a7d0c21b64" category="list-text">使用 Trident 时可能会遇到的一个常见问题<block ref="4568986ef6397d7c901269fc0e190ede" category="inline-link-rx"></block> 租户和客户端密码来自权限不足的应用程序注册。有关 Trident 要求的完整列表，请参见 <block ref="c09112d17e34405b7a5c3d246f91583f" category="inline-link-macro-rx"></block> Configuration</block>
  <block id="7f0ecdfa510b31b01d331c2760643b83" category="list-text">如果在将 PV 挂载到容器时出现问题，请确保 `rpcbind` 已安装并正在运行。对主机操作系统使用所需的软件包管理器，并检查 `rpcbind` 是否正在运行。您可以通过运行 `systemctl status rpcbind` 或其等效项来检查 `rpcbind` 服务的状态。</block>
  <block id="78aeadc89feb4cf244398a7d35a0d656" category="list-text">如果 Trident 后端报告其处于 `Failed` 状态，尽管之前已正常工作，但这可能是由于更改了与后端关联的 SVM/ 管理员凭据所致。使用 `tridentctl update backend` 更新后端信息或放弃 Trident Pod 将修复此问题描述。</block>
  <block id="dd5955dd3991dcacca2b395215df8ecd" category="list-text">如果要升级 Kubernetes 集群和 / 或 Trident 以使用测试版卷快照，请确保已完全删除所有现有的 alpha Snapshot CRS 。然后，您可以使用 `tridentctl obviate alpha-snapshot-crd` 命令删除 alpha snapshot CRD 。请参见<block ref="f3109660248c628e79ddf256944df58b" category="inline-link-rx"></block> 了解迁移 alpha 快照所涉及的步骤。</block>
  <block id="b851cfc28cd6e5cb9aaf87bdb59a68aa" category="list-text">如果在容器运行时安装 Trident 时遇到权限问题，请使用 ` -in cluster=false` 标志尝试安装 Trident 。这不会使用安装程序 POD ，并可避免因 `trident 安装程序` 用户而出现权限问题。</block>
  <block id="6f7d49547ff47cfaf1fd93d134b603be" category="list-text">使用 `uninstall 参数 &lt;Uninstalling Trident &gt;` 在运行失败后进行清理。默认情况下，该脚本不会删除 Trident 创建的 CRD ，因此即使在正在运行的部署中，也可以安全地卸载并重新安装。</block>
  <block id="f1112223b41fddc71fd6a626582dfb78" category="inline-link">Trident 版本</block>
  <block id="c731d984dfa8e536efa9efa455347faa" category="list-text">如果要降级到早期版本的 Trident ，请先运行 `tridenctl uninstall` 命令以删除 Trident 。下载所需的<block ref="f3d78353f8dac3e49bbefeb5f6a2383b" category="inline-link-rx"></block> 并使用 `tridentctl install` 命令进行安装。只有在未创建新 PV 且未对现有 PV/ 后端 / 存储类进行更改的情况下，才考虑降级。由于 Trident 现在使用 CRD 来保持状态，因此创建的所有存储实体（后端，存储类， PV 和卷快照）都具有 `关联的 CRD 对象 &lt;Kubernetes CustomResourceDefinition Objects&gt;` ，而不是写入 PV 的数据，而 PV 中的数据是先前安装的 Trident 版本所使用的。* 新创建的 PV 在移回早期版本时不可用。 * 降级后， Trident 将无法看到对后端， PV ，存储类和卷快照（已创建 / 更新 / 删除）等对象所做的更改 * 。先前安装的 Trident 版本所使用的 PV 仍可供 Trident 查看。如果返回到早期版本，则不会中断对已使用旧版本创建的 PV 的访问，除非已对其进行升级。</block>
  <block id="7dc9f8824c461c84d9bb1563a0615526" category="list-text">要完全删除 Trident ，请运行 `tridentctl obviate crd` 命令。此操作将删除所有 CRD 对象并取消定义 CRD 。Trident 将不再管理其已配置的任何 PV 。</block>
  <block id="e7fc3eac0c0cea530e0f52e3ddf37079" category="admonition">之后，需要从头开始重新配置 Trident 。</block>
  <block id="51748ba3d16ecfd8c45c7ebf2043b738" category="list-text">成功安装后，如果 PVC 停留在 `Pending` 阶段，则运行 `kubectl describe PVC` 可以提供追加信息，说明 Trident 为何无法为此 PVC 配置 PV 。</block>
  <block id="a900bd1dbd5690f78a30ca74d138d0b7" category="section-title">使用操作员对未成功的 Trident 部署进行故障排除</block>
  <block id="0e89989064bf4afdc37fd5a7be4f607d" category="paragraph">如果使用操作员部署 Trident ，则 `TridentOrchestrator` 的状态将从 `Installing` 更改为 `Installed` 。如果您观察到 `failed` 状态，并且操作员无法自行恢复，则应运行以下命令来检查操作员的日志：</block>
  <block id="df9771dbb13da45493e576499910c0b4" category="paragraph">跟踪 trident 操作器容器的日志可能会指向问题所在。例如，其中一个问题描述可能是无法从运行良好的环境中的上游注册表中提取所需的容器映像。</block>
  <block id="0fd4c6187c561958bc76052df7774593" category="paragraph">要了解 Trident 安装失败的原因，您应查看 `TridentOrchestrator` 的状态。</block>
  <block id="1e054f4c292a5388d6318461fe73d749" category="paragraph">此错误表示已存在用于安装 Trident 的 `TridentOrchestrator` 。由于每个 Kubernetes 集群只能有一个 Trident 实例，因此操作员可确保在任意给定时间只存在一个可创建的活动 `TridentOrchestrator` 。</block>
  <block id="568fcf9beb0dbd37c57dff251a3164ed" category="paragraph">此外，观察 Trident Pod 的状态通常可以指示情况是否不正确。</block>
  <block id="f89c17ddb9f8bdaf5c95a466d5f6a500" category="paragraph">您可以清楚地看到，由于未提取一个或多个容器映像， Pod 无法完全初始化。</block>
  <block id="d57d1a6de03b2ddf3ee54f680152e2b6" category="paragraph">要解决此问题，您应编辑 `TridentOrchestrator` CR 。或者，您也可以删除 `TridentOrchestrator` ，并使用修改后的准确定义创建一个新的。</block>
  <block id="a8ee4098038ba3eb2d8c3093ddfe6536" category="section-title">使用 tridentctl 对未成功的 Trident 部署进行故障排除</block>
  <block id="021e9ae5361eb14975bf9a30f99770f5" category="paragraph">为了帮助您找出出现问题的原因，您可以使用 `` -d`` 参数再次运行安装程序，该参数将打开调试模式并帮助您了解问题所在：</block>
  <block id="01539f4f1fd20792cbbae6bb0506cc20" category="paragraph">解决此问题后，您可以按如下所示清理安装，然后再次运行 `tridentctl install` 命令：</block>
  <block id="c109878131f34375d85b7eff9721dcde" category="summary">了解如何在 Astra Trident 安装中创建和使用 Element 后端。</block>
  <block id="f2733a323df72dea4b230205225bdc13" category="doc">配置 NetApp HCI 或 SolidFire 后端</block>
  <block id="a711863513c11f3a6d86294acc7be0ba" category="list-title">您需要什么？ #8217 ；将需要什么</block>
  <block id="d1d184cecc23825cff20fabf3cdfb862" category="list-text">运行 Element 软件的受支持存储系统。</block>
  <block id="4055116469942da7f6ed83abcf57d0a4" category="list-text">NetApp HCI/SolidFire 集群管理员或租户用户的凭据，可用于管理卷。</block>
  <block id="d5fa5f22855b065d96647dfb0c06d685" category="inline-link-macro">工作节点准备信息</block>
  <block id="fa81a6b0253aea3dd9eccc6f72c94371" category="list-text">所有 Kubernetes 工作节点都应安装适当的 iSCSI 工具。请参见 <block ref="33b3e91de73abed89a447676724b5cce" category="inline-link-macro-rx"></block>。</block>
  <block id="c443982ebc2d61b1fdf8348209939f8b" category="paragraph">`solidfire-san` 存储驱动程序支持两种卷模式： file 和 block 。对于 `filesystem` volumemode ， Astra Trident 将创建一个卷并创建一个文件系统。文件系统类型由 StorageClass 指定。</block>
  <block id="02017e70674a0c740b2b95fbb0cc2aa1" category="paragraph">无文件系统。原始块设备。</block>
  <block id="e1f3ce04f7f587f86c154146eace2807" category="admonition">Astra Trident 在用作增强型 CSI 配置程序时使用 CHAP 。如果您使用的是 CHAP （这是 CSI 的默认设置），则无需进行进一步准备。建议明确设置 `UseCHAP` 选项，以便对非 CSI Trident 使用 CHAP 。否则，请参见 <block ref="195a24f2e3cd9264b9f38d5f581c56cd" category="inline-link-macro-rx"></block>。</block>
  <block id="156ef6dbbdc5c1984194012f4d3505a5" category="admonition">只有适用于 Astra Trident 的传统非 CSI 框架才支持卷访问组。如果配置为在 CSI 模式下运行，则 Astra Trident 将使用 CHAP 。</block>
  <block id="03362d64938adda17736eff8a3b091cc" category="paragraph">如果未设置 `AccessGroups` 或 `UseCHAP` ，则适用以下规则之一：</block>
  <block id="44b5e5595eea45ebf8e49f88409afdaa" category="list-text">如果检测到默认的 `trident` 访问组，则会使用访问组。</block>
  <block id="f3bf91f3dbbbaec039ad830cc87a1013" category="list-text">如果未检测到访问组，并且 Kubernetes 版本为 1.7 或更高版本，则会使用 CHAP 。</block>
  <block id="15b7c7ffe264d7b8c61915ff2a6ef96c" category="section-title">后端配置选项</block>
  <block id="9d370350f8d0178b5dfbec9def10d13a" category="paragraph">有关后端配置选项，请参见下表：</block>
  <block id="7877022c956918624cc0373ff564cad4" category="cell">`ve版本`</block>
  <block id="40e27006e7b709772172391a3d17b331" category="cell">始终为 1</block>
  <block id="868dff7060d78b6417dc8e065eca8374" category="cell">`storageDriverName`</block>
  <block id="5aae2c40b50d296edbd4ba9cfb462b49" category="cell">存储驱动程序的名称</block>
  <block id="2353a0a3a06283f07550efc7bad8a90e" category="cell">始终为 "solidfire-san"</block>
  <block id="f5b55596d3f53b1857a4980dac9db979" category="cell">`backendName`</block>
  <block id="5afd6479855e8d63f324b6ec2fa787b4" category="cell">自定义名称或存储后端</block>
  <block id="f4210b28f3cf7c1f7e6e328bb42c6060" category="cell">SolidFire + 存储（ iSCSI ） IP 地址</block>
  <block id="06981b2729b4b522b21d903c7738a2ca" category="cell">`端点`</block>
  <block id="41eba2d95ecaf35c8bd3a972c263ffe4" category="cell">使用租户凭据的 SolidFire 集群的 MVIP</block>
  <block id="955f5caa2495689258902533d1a6cd44" category="cell">`sVIP`</block>
  <block id="b07ca7de83de58a699966c9bc9003020" category="cell">存储（ iSCSI ） IP 地址和端口</block>
  <block id="eea443d4fcc24d4cd2cab08c2a6c062f" category="cell">`标签`</block>
  <block id="749df53d02481e75dd919dddf42fbbef" category="cell">要应用于卷的一组任意 JSON 格式的标签。</block>
  <block id="1d76382e861d2df96647216b26d38948" category="cell">"</block>
  <block id="4e25fe4a614b527d9b3d89ee6abe5d35" category="cell">`租户名称`</block>
  <block id="251f1fc42c38ca55f30e5e9d11dac168" category="cell">要使用的租户名称（如果未找到，则创建）</block>
  <block id="f016e2c01f2bafa45e6b537d49f0f9da" category="cell">`InitiatorIFace`</block>
  <block id="4381b3c378885de93e2166f240096338" category="cell">将 iSCSI 流量限制为特定主机接口</block>
  <block id="6522432847a0e6902318a976e5533f62" category="cell">default</block>
  <block id="5ff567e0863a47346f44f87ed793f508" category="cell">`UseCHAP`</block>
  <block id="d390e6782f0a0af41ea0397e46b5368e" category="cell">使用 CHAP 对 iSCSI 进行身份验证</block>
  <block id="2d1474e8b52ef42851337fb3fef4e1a1" category="cell">"nfsvers=3"</block>
  <block id="32738663b16444872e4e5721c7c37660" category="cell">`访问组`</block>
  <block id="c4ca01925aae0c37398f0b30a4ce1273" category="cell">要使用的访问组 ID 列表</block>
  <block id="e64099a24f6ef8bbbdb23c2a803cd065" category="cell">查找名为 "trident " 的访问组的 ID</block>
  <block id="26194deaf50c44db6eb5983237bdaf25" category="cell">`类型`</block>
  <block id="ee1aea1de97320ad8e98436f68b01b4a" category="cell">QoS 规范</block>
  <block id="91590ee78f1b4751284f4f9ea80cfe86" category="cell">`limitVolumeSize`</block>
  <block id="18320b2a705a7bed37a6bc0af4aee093" category="cell">如果请求的卷大小超过此值，则配置失败</block>
  <block id="7962423206a6704e20fa94085d19b517" category="cell">" （默认情况下不强制实施）</block>
  <block id="f2f2c7c3c767da610bd95934104674f6" category="cell">`debugTraceFlags`</block>
  <block id="ae0784115c8f815d4a2ca170c59f3c99" category="cell">故障排除时要使用的调试标志。示例 ｛ "api" ： false ， "method " ： true ｝</block>
  <block id="37a6259cc0c1dae299a7866489dff0bd" category="cell">空</block>
  <block id="88dce60232453383ab0d1c3c59cc931d" category="admonition">请勿使用 `debugTraceFlags` ，除非您正在进行故障排除并需要详细的日志转储。</block>
  <block id="fcca02e29a08e37c6faf37a418b8d5c8" category="admonition">对于创建的所有卷， Astra Trident 会在配置存储池时将存储池上的所有标签复制到备用存储 LUN 。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="a52b8d71eedc2812fe762b3ec88bfc2e" category="section-title">示例 1 ：具有三种卷类型的 solidfire-san 驱动程序的后端配置</block>
  <block id="3185240fb49cba19667fbdf639f3271e" category="paragraph">此示例显示了一个后端文件，该文件使用 CHAP 身份验证并使用特定 QoS 保证对三种卷类型进行建模。然后，您很可能会使用 `IOPS` storage class 参数定义存储类以使用其中的每种类型。</block>
  <block id="d030a0e9c177498f4267bf1a6a4eab28" category="section-title">示例 2 ：具有虚拟存储池的 solidfire-san 驱动程序的后端和存储类配置</block>
  <block id="fe8fbdb035f6bebecaf9a52e36d8a595" category="paragraph">此示例显示了使用虚拟存储池配置的后端定义文件以及引用这些池的 StorageClasses 。</block>
  <block id="87af0508250ed6f900914914280a5eaf" category="paragraph">在下面所示的示例后端定义文件中，为所有存储池设置了特定的默认值，即将 `type` 设置为 Silver 。虚拟存储池在 `s存储` 部分中进行定义。在此示例中，某些存储池设置了自己的类型，而某些池将覆盖上述默认值。</block>
  <block id="dc4edcc28563e022c1d21dec9d28dcca" category="paragraph">以下 StorageClass 定义引用了上述虚拟存储池。使用 `parameters.selector` 字段，每个 StorageClass 都会调用可用于托管卷的虚拟池。卷将在选定虚拟池中定义各个方面。</block>
  <block id="e4af8ad03936f6a7724e17f6e83c09c8" category="paragraph">第一个 StorageClass （ `solidfire-gold-四` ）将映射到第一个虚拟存储池。这是唯一一个性能卓越的池，其 `卷类型 QoS` 值为金牌。最后一个 StorageClass （ `solidfire-silver` ）调用可提供银牌性能的任何存储池。Astra Trident 将决定选择哪个虚拟存储池，并确保满足存储要求。</block>
  <block id="4d0d37d727675761e4c0e324eb57ca2f" category="list-text"><block ref="4d0d37d727675761e4c0e324eb57ca2f" category="inline-link-macro-rx"></block></block>
  <block id="ac8d6c792ab9df0b15a26713390895f1" category="summary">了解如何使用提供的示例配置将 Cloud Volumes Service for Google Cloud 配置为 Astra Trident 安装的后端。</block>
  <block id="fd1248bc6e4583a3f250f8e575cd59fe" category="doc">为 GCP 后端配置 CVS</block>
  <block id="2562e7447cd588d1768109da5ba66ef1" category="paragraph">了解如何使用提供的示例配置将适用于 Google 云平台（ GCP ）的 NetApp Cloud Volumes Service （ CVS ）配置为 Astra Trident 安装的后端。</block>
  <block id="b85237ff884eb3aa5c20d9ffcdabbeac" category="admonition">NetApp Cloud Volumes Service for Google Cloud 不支持大小小于 100 GiB 的 CVS-Performance 卷或小于 300 GiB 的 CVS 卷。如果请求的卷小于最小大小，则 Astra Trident 会自动创建最小大小的卷。</block>
  <block id="da195e41c537042ae77405110c4512ff" category="paragraph">以配置和使用<block ref="5129d3f1116e9c5221bfcf965a1ede35" category="inline-link-rx"></block> 后端，您需要满足以下要求：</block>
  <block id="6801d56ba08d1acc2876c196223d531a" category="list-text">配置了 NetApp CVS 的 Google Cloud 帐户</block>
  <block id="2c00ff9c7700dc3529c57f0a5281bbe2" category="list-text">Google Cloud 帐户的项目编号</block>
  <block id="43752d169c5729fffa3a6557a0978cb8" category="list-text">具有 `netappcloudvolumes.admin` 角色的 Google Cloud 服务帐户</block>
  <block id="5d6ade9bdfebc79abf4c55e55a2c9941" category="list-text">CVS 服务帐户的 API 密钥文件</block>
  <block id="7d0ee86ffc673e47ce20265e1e21317f" category="inline-link">GCP 上的 CVS 服务类型</block>
  <block id="1f57356f89e79e6730290eddcf7b84ee" category="paragraph">Astra Trident 现在支持使用默认值的较小卷<block ref="fc2935a8a76e337f6e814f65964a47b6" category="inline-link-rx"></block>。对于使用 `storageClass=software` 创建的后端，卷的最小配置大小将为 300 GiB 。CVS 目前在 " 受控可用性 " 下提供此功能，不提供技术支持。用户必须注册才能访问低于 1TiB 的卷<block ref="daab940ca038632df7b3bcdb2ce67b4b" category="inline-link-rx"></block>。NetApp 建议客户对非生产工作负载使用 1 TiB 以下的卷。</block>
  <block id="adf38902d2794fb5eb0ede6324a90db7" category="admonition">使用默认 CVS 服务类型（ `storageClass=software` ）部署后端时，用户必须获得 GCP 上有关项目编号和项目 ID 的 1 TiB 卷功能的访问权限。这对于 Astra Trident 配置低于 1TiB 的卷是必需的。否则，对于小于 600 GiB 的 PVC ，卷创建将失败。使用访问低于 1TiB 的卷<block ref="d5347d47b24e3303f1c7b0ae61e08dc7" category="inline-link-rx"></block>。</block>
  <block id="3e6d0b5d82e6a07b21f37953b4f07f2b" category="paragraph">由 Astra Trident 为默认 CVS 服务级别创建的卷将按以下方式进行配置：</block>
  <block id="b0f9c06798383f1aa62530b497a530f7" category="list-text">小于 300 GiB 的 PVC 将导致 Astra Trident 创建 300 GiB CVS 卷。</block>
  <block id="f8d45755378c123e72db60a65c99c9eb" category="list-text">如果 PVC 介于 300 GiB 到 600 GiB 之间，则 Astra Trident 将创建请求大小的 CVS 卷。</block>
  <block id="60f847f16dcff8ca2ff2ce3434bcb4c9" category="list-text">介于 600 GiB 和 1 TiB 之间的 PVC 将导致 Astra Trident 创建 1 TiB CVS 卷。</block>
  <block id="96ca04bda01b9542611aa702d16b37ee" category="list-text">如果 PVC 大于 1 TiB ，则 Astra Trident 将创建请求大小的 CVS 卷。</block>
  <block id="07cc9934740ba3dd46a0d7d2c9502d39" category="cell">"GCP-CVS"</block>
  <block id="f476273c71e20fc5a845a5345a620117" category="cell">驱动程序名称 + "_" + API 密钥的一部分</block>
  <block id="6eb82a822b962404b9694b93f2967679" category="cell">`s存储类`</block>
  <block id="f26f4f79d1de66f6ce1a2d9a1663dc5e" category="cell">存储类型可选择 `硬件` （性能优化）或 `s软件` （ CVS 服务类型）</block>
  <block id="c96383270cbab23de47b4f0961f64929" category="cell">`projectNumber`</block>
  <block id="6a9b4c6a3586ab6a85d6c78e7dda0570" category="cell">Google Cloud 帐户项目编号。该值可在 Google Cloud 门户的主页页面上找到。</block>
  <block id="2086191016950a784040f7d22ab27f60" category="cell">`区域`</block>
  <block id="c785bbb8190e6c0c816762918e34a0d7" category="cell">CVS 帐户区域。后端将在该区域配置卷。</block>
  <block id="a34d72a685d5e27eb6bc18f54a7bab1d" category="cell">`apiKey`</block>
  <block id="3e4dad689bfe319e0980748c1c2175a7" category="cell">具有 `netappcloudvolumes.admin` 角色的 Google Cloud 服务帐户的 API 密钥。它包括 Google Cloud 服务帐户专用密钥文件的 JSON 格式的内容（逐字复制到后端配置文件）。</block>
  <block id="af18429250667f805769a7755a008c1f" category="cell">`代理 URL`</block>
  <block id="99d5bed813f066a1a1551b1bdab48e21" category="cell">代理服务器需要连接到 CVS 帐户时的代理 URL 。代理服务器可以是 HTTP 代理，也可以是 HTTPS 代理。对于 HTTPS 代理，将跳过证书验证，以允许在代理服务器中使用自签名证书。不支持启用了身份验证的代理服务器。</block>
  <block id="2b45af5c768d7b2495ef631c991ecd78" category="cell">`nfsMountOptions`</block>
  <block id="b9cc8276829a756e7a22476617204267" category="cell">精细控制 NFS 挂载选项。</block>
  <block id="2288620b3dc019c6359bcc7f50b72ab3" category="cell">如果请求的卷大小超过此值，则配置失败</block>
  <block id="567c7f0eca746ed7513764be5ecf6d03" category="cell">"" （默认情况下不强制实施）</block>
  <block id="0322003a3502f221fdb74b059dfff46e" category="cell">`s服务级别`</block>
  <block id="5a5b2759e0577a3e22002ed8430f2b4f" category="cell">新卷的 CVS 服务级别。这些值包括 "standard" ， "premer" 和 "Extreme " 。</block>
  <block id="e472abc54914c303a14c29f7e853a28a" category="cell">标准</block>
  <block id="e39a04a98487bb1fd113f63d47331565" category="cell">故障排除时要使用的调试标志。示例， ` \ ｛ "api" ： false ， "method ： true" ｝` 。除非您正在进行故障排除并需要详细的日志转储，否则请勿使用此功能。</block>
  <block id="e96ca96c25a07de5f03e2535b0c2f7fc" category="paragraph">如果使用共享 VPC 网络，则必须同时指定 `projectNumber` 和 `hostProjectNumber` 。在这种情况下， `projectNumber` 是服务项目，而 `hostProjectNumber` 是主机项目。</block>
  <block id="34c1edfb4ac8581528c3791be680aeb3" category="inline-link">CVS 服务类型</block>
  <block id="457c2f1fead29343fe617ea61b06aaff" category="admonition">`storageClass` 是一个可选参数，您可以使用该参数选择所需的<block ref="46dc1bdb584c5005116d9d2a4d889e1d" category="inline-link-rx"></block>。您可以从基本 CVS 服务类型（ `storageClass=software` ）或 CVS-Performance 服务类型（ `storageClass=hardware` ）中进行选择， Trident 默认使用此服务类型。请 `指定一个 "apiRegion"` ，用于在后端定义中提供相应的 CVS `storageClass` 。</block>
  <block id="8ae8f69dea7cff0617560bc62f9c8c21" category="admonition">Astra Trident 与 Google Cloud 上的基本 CVS 服务类型集成是一项 * 测试版功能 * ，不适用于生产工作负载。在 CVS-Performance 服务类型中， Trident 是 "* 完全支持 "* ，默认情况下会使用它。</block>
  <block id="4dd7128ceae058946c44bbbb0985ec6f" category="paragraph">每个后端都会在一个 Google Cloud 区域中配置卷。要在其他区域创建卷，您可以定义其他后端。</block>
  <block id="5477b38834c7f5d99403326a17f0bf55" category="paragraph">您可以通过在配置文件的特殊部分中指定以下选项来控制默认配置每个卷的方式。请参见以下配置示例。</block>
  <block id="9c64942fe493cb70c474ff447429d8a4" category="cell">`exportRule`</block>
  <block id="4e69ff68e3ee9207d53a76748485f3d8" category="cell">新卷的导出规则</block>
  <block id="1274e36c193ec0ce8b5c49d5e78ffd7b" category="cell">"0.0.0.0/0</block>
  <block id="ce8f82152151ae2aadaec166eca744a9" category="cell">`snapshotDir`</block>
  <block id="51b2015e6da8653f4041b71312ad43fe" category="cell">访问 ` .snapshot` 目录</block>
  <block id="c07fbc0b2a1a865fe9e3a55c05b4f690" category="cell">false</block>
  <block id="7556d5a1b0c5f68b7cb5aedaa3156008" category="cell">`sSnapshot 预留`</block>
  <block id="31ed61cc3c85d0bb697cd12b77f37fd1" category="cell">为快照预留的卷百分比</block>
  <block id="e76dcf1d6497658a2994b5f1f65b7a83" category="cell">"" （接受 CVS 默认值为 0 ）</block>
  <block id="a48a8458539e489328f4d6d3fc0ee288" category="cell">`s大小`</block>
  <block id="dc78a90de250a0f2ca8ad52ee0c5d21b" category="cell">新卷的大小</block>
  <block id="33b57ed56f35d9bd9c44a151d47870c5" category="cell">"100Gi"</block>
  <block id="b2a2a92e6239fca01cafbcfd41760043" category="paragraph">`exportRule` 值必须是以 CIDR 表示法表示的 IPv4 地址或 IPv4 子网任意组合的逗号分隔列表。</block>
  <block id="24ee58a4f143adf08af9c1d30049aab9" category="admonition">对于在 CVS Google Cloud 后端创建的所有卷， Trident 会在配置存储池时将其上的所有标签复制到该存储卷。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="25f4894ddaab3c1182f12732d3bcf889" category="section-title">示例 1 ：最低配置</block>
  <block id="9fe036cdf8651713d44464a40094dc62" category="paragraph">这是绝对的最低后端配置。</block>
  <block id="db7f67d90a618d3698e7aab6ddef7169" category="section-title">示例 2 ：基本 CVS 服务类型配置</block>
  <block id="22765d2acb079f52fa8f5b179e9a74fc" category="paragraph">此示例显示了使用基本 CVS 服务类型的后端定义，该服务类型适用于通用工作负载，可提供轻 / 中性能以及高区域可用性。</block>
  <block id="32c780bbc74d6c4f4c9ff8d54332fef9" category="section-title">示例 3 ：单服务级别配置</block>
  <block id="3862c5daf26e4fabfbac9261779b440a" category="paragraph">此示例显示了一个后端文件，该文件对 Google Cloud us-west2 区域中由 Astra Trident 创建的所有存储应用相同的方面。此示例还显示了后端配置文件中使用的 `proxyURL` 。</block>
  <block id="3a050f4cfb1985247f813dd3432ed5e6" category="section-title">示例 4 ：虚拟存储池配置</block>
  <block id="59e397d220ba994003ab3439526d48d1" category="paragraph">此示例显示了使用虚拟存储池配置的后端定义文件以及引用这些池的 `StorageClasses` 。</block>
  <block id="a1306d5e7389ac9f3740a973a3175a2c" category="paragraph">在下面显示的示例后端定义文件中，为所有存储池设置了特定的默认值，这些默认值会将 `snapshotReserve` 设置为 5% ，并将 `exportRule` 设置为 0.0.0.0/0 。虚拟存储池在 `s存储` 部分中进行定义。在此示例中，每个存储池都会设置自己的 `serviceLevel` ，而某些池会覆盖默认值。</block>
  <block id="7229192fbc3d9420b90f84958fee3b0d" category="paragraph">以下 StorageClass 定义引用了上述存储池。通过使用 `parameters.selector` 字段，您可以为每个 StorageClass 指定用于托管卷的虚拟池。卷将在选定池中定义各个方面。</block>
  <block id="b60daecbb1685b08e94947d4137aa916" category="paragraph">第一个 StorageClass （`cvs-ext-protection` ）映射到第一个虚拟存储池。这是唯一一个可提供极高性能且 Snapshot 预留为 10% 的池。最后一个 StorageClass （`cvs-extra protection` ）调用提供 10% 快照预留的任何存储池。Astra Trident 决定选择哪个虚拟存储池，并确保满足快照预留要求。</block>
  <block id="3f297ef15cde0668e93b35f2752fd4fd" category="section-title">下一步是什么？</block>
  <block id="3ad256eea0abb551eaab63c84aa3d1f9" category="paragraph">创建后端配置文件后，运行以下命令：</block>
  <block id="a61ed3c1ecae587dbee1f2c0ace81e3b" category="paragraph">如果后端创建失败，则后端配置出现问题。您可以运行以下命令来查看日志以确定发生原因：</block>
  <block id="8427b84145b88f048d5caa532324cd11" category="paragraph">确定并更正配置文件中的问题后，您可以再次运行 create 命令。</block>
  <block id="fe328cbae90d1a295c7e45733450d711" category="summary">Astra Trident 可以在 Kubernetes 集群中的节点上自动安装所需的 NFS 和 iSCSI 工具。</block>
  <block id="878a6c37d04e0b8f6746f8b1caf14789" category="doc">自动工作节点准备</block>
  <block id="360deb71f11973ab55dca824207c8594" category="paragraph">Astra Trident 可以在 Kubernetes 集群中的节点上自动安装所需的 `NFS` 和 `iSCSI` 工具。这是一项 * 测试版功能 * ， * 不适用于 * 生产集群。目前，该功能可用于运行 * CentOS ， RHEL 和 Ubuntu * 的节点。</block>
  <block id="c105a7b612eafd056a1525c7dea9ddda" category="paragraph">对于此功能， Astra Trident 提供了一个新的安装标志： ` -enable-node-prep` for installations deployed with `tridentctl` 。对于使用 Trident 运算符的部署，请使用布尔选项 `enableNodePrep` 。</block>
  <block id="f6aec0bd36e5ab01303aa37ab52ec8d8" category="admonition">` -enable-node-prep` 安装选项指示 Astra Trident 安装并确保在工作节点上挂载卷时 NFS 和 iSCSI 软件包和 / 或服务正在运行。这是一项 * 测试版功能 * ，用于 * 不符合生产条件 * 的开发 / 测试环境。</block>
  <block id="f587ac26702eec76a28d335e634449b1" category="paragraph">如果使用 `tridentctl` 部署的 Astra Trident 安装包含 ` -enable-node-prep` 标志，则会发生以下情况：</block>
  <block id="7a63850885709e4125994faba4bd1667" category="list-text">在安装过程中， Astra Trident 会注册其运行所在的节点。</block>
  <block id="c1ebfd51cbff72f2afbe7f30f827eda5" category="list-text">发出永久性卷请求（ PVC ）请求后， Astra Trident 会从其管理的后端创建 PV 。</block>
  <block id="5b70ed42b3c8f8528cef50ad01425fb3" category="list-text">在 Pod 中使用 PVC 需要使用 Astra Trident 在 Pod 运行的节点上挂载卷。Astra Trident 会尝试安装所需的 NFS/iSCSI 客户端实用程序，并确保所需服务处于活动状态。此操作会在挂载卷之前完成。</block>
  <block id="ac5aafb0e9591a4bede4be4f37f141cf" category="paragraph">在首次尝试挂载卷时，只会对工作节点进行一次准备。只要 Astra Trident 之外的任何更改均未触及 `nfs` 和 `iscsi` 实用程序，所有后续卷挂载都应成功。</block>
  <block id="bf3c2b9140b25189d7032529446cfaf4" category="paragraph">通过这种方式， Astra Trident 可以确保 Kubernetes 集群中的所有节点都具有挂载和连接卷所需的实用程序。对于 NFS 卷，导出策略还应允许挂载该卷。Trident 可以自动管理每个后端的导出策略；用户也可以管理带外导出策略。</block>
  <block id="8f828c7344e7fe65d66237a25193068b" category="summary">了解如何准备使用 ONTAP SAN 驱动程序配置 ONTAP 后端。</block>
  <block id="9a5f09cf66e692efdae493ce4c9aa64f" category="doc">准备</block>
  <block id="b5c795328aa98beaf5bdc15b54a533c1" category="paragraph">了解如何准备使用 ONTAP SAN 驱动程序配置 ONTAP 后端。对于所有 ONTAP 后端， Astra Trident 需要至少为 SVM 分配一个聚合。</block>
  <block id="5475028f502d04bc17cdfdf613d28cbf" category="paragraph">请记住，您还可以运行多个驱动程序，并创建指向其中一个驱动程序的存储类。例如，您可以配置使用 `ontap-san` 驱动程序的 `san-dev` 类和使用 `ontap-san-economy-one` 的 `san-default` 类。</block>
  <block id="3b40a8d4978192509495ce411fe8db8c" category="paragraph">所有 Kubernetes 工作节点都必须安装适当的 iSCSI 工具。请参见 <block ref="9ec363a49b52db56773849151c5853d4" category="inline-link-macro-rx"></block> 有关详细信息：</block>
  <block id="c75f7811d70d17dbcd88e9d03752cbed" category="section-title">身份验证</block>
  <block id="51e35cec1e001fb8abfbe474a18dd282" category="paragraph">Astra Trident 提供了两种对 ONTAP 后端进行身份验证的模式。</block>
  <block id="00cbc0e7ed0014813b07fc8452f60df1" category="list-text">Credential Based ：具有所需权限的 ONTAP 用户的用户名和密码。建议使用 `admin` 或 `vsadmin` 等预定义的安全登录角色，以确保与 ONTAP 版本的最大兼容性。</block>
  <block id="e2cd9c84c3ebf14f3c81be4692848e5b" category="list-text">基于证书： Astra Trident 还可以使用后端安装的证书与 ONTAP 集群进行通信。此处，后端定义必须包含客户端证书，密钥和可信 CA 证书的 Base64 编码值（如果使用）（建议）。</block>
  <block id="f3a85dfc22761b09346aa0134d77d4f9" category="paragraph">用户还可以选择更新现有后端，选择从基于凭据迁移到基于证书，反之亦然。如果 * 同时提供了凭据和证书 * ，则 Astra Trident 将在发出警告以从后端定义中删除凭据时默认使用证书。</block>
  <block id="a2f8f419bf420960ef8cca73e1999e09" category="section-title">启用基于凭据的身份验证</block>
  <block id="ceae351bc6b26100a9b1685a5d477c0a" category="paragraph">Astra Trident 需要 SVM 范围 / 集群范围的管理员的凭据才能与 ONTAP 后端进行通信。建议使用标准的预定义角色，例如 `admin` 或 `vsadmin` 。这样可以确保与未来的 ONTAP 版本向前兼容，这些版本可能会使功能 API 公开供未来的 Astra Trident 版本使用。可以创建自定义安全登录角色并将其用于 Astra Trident ，但不建议使用。</block>
  <block id="2312b8f77f99c346269b67308afc3649" category="paragraph">后端定义示例如下所示：</block>
  <block id="2a2ef6dcf08a8789a55301af5f71304c" category="paragraph">请注意，后端定义是凭据以纯文本格式存储的唯一位置。创建后端后，用户名 / 密码将使用 Base64 进行编码并存储为 Kubernetes 密钥。创建 / 更新后端是唯一需要了解凭据的步骤。因此，这是一项仅由管理员执行的操作，由 Kubernetes 或存储管理员执行。</block>
  <block id="052f76b486189a7b01340d5134eb7985" category="section-title">启用基于证书的身份验证</block>
  <block id="0778b06c5ea9fded4fd7b586b248dd86" category="paragraph">新的和现有的后端可以使用证书并与 ONTAP 后端进行通信。后端定义需要三个参数。</block>
  <block id="d5b9c9db262b1927d7914504f3587adb" category="list-text">clientCertificate ：客户端证书的 Base64 编码值。</block>
  <block id="8f2b750dd6a57864f0e36828c248ddfc" category="list-text">clientPrivateKey ：关联私钥的 Base64 编码值。</block>
  <block id="200c2d2a44dec6455fa1c947f9c1f534" category="list-text">trustedCACertifate ：受信任 CA 证书的 Base64 编码值。如果使用可信 CA ，则必须提供此参数。如果不使用可信 CA ，则可以忽略此设置。</block>
  <block id="6b634823c19ebc37c9e4fdbf08de1fff" category="paragraph">典型的工作流包括以下步骤。</block>
  <block id="c92e58d7dd251e6e6cdb16291a6dec90" category="list-text">生成客户端证书和密钥。生成时，将公用名（ Common Name ， CN ）设置为要作为身份验证的 ONTAP 用户。</block>
  <block id="69b521cddbc52a2d14539e349e2930f0" category="list-text">将可信 CA 证书添加到 ONTAP 集群。此问题可能已由存储管理员处理。如果未使用可信 CA ，则忽略。</block>
  <block id="2f3945695e5ca88abb46af80d87c6972" category="list-text">在 ONTAP 集群上安装客户端证书和密钥（从步骤 1 开始）。</block>
  <block id="e81810c4035ad015ad3f0d8c4f2c6454" category="list-text">确认 ONTAP 安全登录角色支持 `cert` 身份验证方法。</block>
  <block id="ea3bf76b270384627e7bcfb197ddb17b" category="list-text">使用生成的证书测试身份验证。将 &lt;SVM 管理 LIF&gt; 和 &lt;SVM 名称 &gt; 替换为管理 LIF IP 和 ONTAP 名称。</block>
  <block id="83f2adf143dc8f5fbbb9d924f840c1ce" category="list-text">使用 Base64 对证书，密钥和可信 CA 证书进行编码。</block>
  <block id="8d36e570f1edac5ae19e6733e3fbb4d5" category="list-text">使用从上一步获得的值创建后端。</block>
  <block id="2ab8ad0fce083cd02635b9126cf4353c" category="section-title">更新身份验证方法或轮换凭据</block>
  <block id="85a73bd1a3fad449b226a7eecb546c6b" category="paragraph">您可以更新现有后端以使用其他身份验证方法或轮换其凭据。这两种方式都适用：使用用户名 / 密码的后端可以更新为使用证书；使用证书的后端可以更新为基于用户名 / 密码的后端。为此，请使用更新后的 `backend.json` 文件，该文件包含执行 `tridentctl 后端更新` 所需的参数。</block>
  <block id="5e36c3d66bd47ae551071244dc48df17" category="admonition">轮换密码时，存储管理员必须先在 ONTAP 上更新用户的密码。然后进行后端更新。轮换证书时，可以向用户添加多个证书。之后，后端将更新以使用新证书，然后可以从 ONTAP 集群中删除旧证书。</block>
  <block id="6819218365fe3a3d66752f663feecddb" category="paragraph">更新后端不会中断对已创建卷的访问，也不会影响在之后建立的卷连接。成功的后端更新表明， Astra Trident 可以与 ONTAP 后端进行通信并处理未来的卷操作。</block>
  <block id="93a4f17ec735c794a2d38eb0d9dc736b" category="section-title">指定 igroup</block>
  <block id="f66329c2f28d3aade033dade4fa02359" category="paragraph">Astra Trident 使用 igroup 来控制对其配置的卷（ LUN ）的访问。在为后端指定 igroup 时，管理员有两种选择：</block>
  <block id="caf7ba3262c90c77b09b7d53946b7be4" category="list-text">Astra Trident 可以自动为每个后端创建和管理 igroup 。如果后端定义中未包含 `igroupName` ，则 Astra Trident 会在 SVM 上创建一个名为 `trident -&lt;backender-UUUUUID&gt;` 的 igroup 。这将确保每个后端都有一个专用的 igroup ，并处理 Kubernetes 节点 IQN 的自动添加 / 删除。</block>
  <block id="b325b5680680ba28771d11978100bf3a" category="list-text">或者，也可以在后端定义中提供预先创建的 igroup 。可以使用 `igroupName` config 参数来执行此操作。Astra Trident 会将 Kubernetes 节点 IQN 添加 / 删除到已有的 igroup 中。</block>
  <block id="ccdb9f53393401f058dcfc9c1de74547" category="paragraph">对于已定义 `igroupName` 的后端，可以使用 `tridentctl 后端更新` 删除 `igroupName` ，以使 Astra Trident 自动处理 igroup 。这样不会中断对已连接到工作负载的卷的访问。未来的连接将使用创建的 igroup Astra Trident 进行处理。</block>
  <block id="8841675f2e0dbba5719034b41ac52435" category="admonition">为 Astra Trident 的每个唯一实例指定一个 igroup 是一个最佳实践，对 Kubernetes 管理员和存储管理员都很有用。CSI Trident 可自动向 igroup 添加和删除集群节点 IQN ，从而极大地简化了其管理。在 Kubernetes 环境（以及 Astra Trident 安装）中使用相同的 SVM 时，使用专用的 igroup 可确保对一个 Kubernetes 集群所做的更改不会影响与另一个 Kubernetes 集群关联的 igroup 。此外，还必须确保 Kubernetes 集群中的每个节点都具有唯一的 IQN 。如上所述， Astra Trident 会自动处理 IQN 的添加和删除。在多个主机之间重复使用 IQN 可能会导致出现主机相互错误并拒绝访问 LUN 的不希望出现的情况。</block>
  <block id="a3a4bece92a1c7bb017b9bc2681621f7" category="paragraph">如果将 Astra Trident 配置为充当 CSI 配置程序，则 Kubernetes 节点 IQN 会自动添加到 igroup 中或从 igroup 中删除。将节点添加到 Kubernetes 集群后， `trident — CSI` DemonSet 会在新添加的节点上部署一个 Pod （`trident — CSI — xxxxx` ），并注册可将卷连接到的新节点。节点 IQN 也会添加到后端的 igroup 中。在对节点进行隔离，清空并从 Kubernetes 中删除时，可以执行一组类似的步骤来删除 IQN 。</block>
  <block id="3882232e20d620974a87db190a124fe7" category="paragraph">如果 Astra Trident 未作为 CSI 配置程序运行，则必须手动更新 igroup ，以包含 Kubernetes 集群中每个工作节点的 iSCSI IQN 。需要将加入 Kubernetes 集群的节点的 IQN 添加到 igroup 中。同样，必须从 igroup 中删除从 Kubernetes 集群中删除的节点的 IQN 。</block>
  <block id="42f93278b0d15c8d0f6613813bf586d5" category="section-title">使用双向 CHAP 对连接进行身份验证</block>
  <block id="5d34ca21e19aa85f2e3cbc5bc90702fb" category="paragraph">Astra Trident 可以使用双向 CHAP 对 `ontap-san` 和 `ontap-san-economy-sn` 驱动程序的 iSCSI 会话进行身份验证。这需要在后端定义中启用 `useCHAP` 选项。如果设置为 `true` ，则 Astra Trident 会将 SVM 的默认启动程序安全性配置为双向 CHAP ，并从后端文件设置用户名和密码。NetApp 建议使用双向 CHAP 对连接进行身份验证。请参见以下配置示例：</block>
  <block id="12dd7bfa072b5a1eecf975f6a5a6eaa7" category="admonition">`useCHAP` 参数是一个布尔选项，只能配置一次。默认情况下，此参数设置为 false 。将其设置为 true 后，无法将其设置为 false 。</block>
  <block id="bc601528678aeeb582101ed205a054bc" category="paragraph">除了 `useCHAP=true` 之外，后端定义还必须包括 `chapInitiatorSecret` ， `chapTargetInitiatorSecret` ， `chapTargetUsername` 和 `chapUsername` 字段。通过运行 `tridentctl update` 创建后端，可以更改这些密钥。</block>
  <block id="9ffdb95250e26c7a6b468126ac7c75b0" category="section-title">工作原理</block>
  <block id="adbaa30840aebfe537058f72e0989326" category="paragraph">通过将 `useCHAP` 设置为 true ，存储管理员指示 Astra Trident 在存储后端配置 CHAP 。其中包括：</block>
  <block id="29b4db879e4cc96a6b71bc763367624b" category="list-text">在 SVM 上设置 CHAP ：</block>
  <block id="951e8b45bc49a5475337a1b55e3e3dc4" category="list-text">如果 SVM 的默认启动程序安全类型为 none （默认设置） * 和 * 卷中没有已存在的 LUN ，则 Astra Trident 会将默认安全类型设置为 `CHAP` ，然后继续配置 CHAP 启动程序以及目标用户名和密码。</block>
  <block id="313818ab0cd3579429d5bd6e5faab8ff" category="list-text">如果 SVM 包含 LUN ，则 Astra Trident 不会在 SVM 上启用 CHAP 。这样可以确保对 SVM 上已存在的 LUN 的访问不受限制。</block>
  <block id="13e0c564d5e1fbd33279fb276166653d" category="list-text">配置 CHAP 启动程序以及目标用户名和密码；必须在后端配置中指定这些选项（如上所示）。</block>
  <block id="9154c9db577ccbf466ca622a07931896" category="list-text">管理向后端提供的 `igroupName` 添加启动程序的操作。如果未指定，则默认为 `trident` 。</block>
  <block id="2c7856e86a0cd46cb4fb48fa0886745e" category="paragraph">创建后端后， Astra Trident 会创建相应的 `tridentbackend` CRD ，并将 CHAP 密码和用户名存储为 Kubernetes 密码。此后端由 Astra Trident 创建的所有 PV 都将通过 CHAP 进行挂载和连接。</block>
  <block id="81f2df0265026a1a04bda5484798a10d" category="section-title">轮换凭据并更新后端</block>
  <block id="a7fe005c9f49619f4438aac8932fb361" category="paragraph">您可以通过更新 `backend.json` 文件中的 CHAP 参数来更新 CHAP 凭据。这需要更新 CHAP 密码并使用 `tridentctl update` 命令反映这些更改。</block>
  <block id="8959ac16a58b09dc5a158e86ab02cb53" category="admonition">更新后端的 CHAP 密码时，必须使用 `tridentctl` 来更新后端。请勿通过 CLI/ONTAP UI 更新存储集群上的凭据，因为 Astra Trident 将无法选取这些更改。</block>
  <block id="1a59d0d7850406f157c314978eb3b821" category="paragraph">现有连接将不受影响；如果凭据由 SVM 上的 Astra Trident 更新，则这些连接将继续保持活动状态。新连接将使用更新后的凭据，现有连接将继续保持活动状态。断开并重新连接旧的 PV 将导致它们使用更新后的凭据。</block>
  <block id="fe1db7f37fb893d9995534febe29a78b" category="summary">了解如何使用提供的示例配置将 Cloud Volumes Service for AWS 配置为 Astra Trident 安装的后端。</block>
  <block id="6e399579bcb032270367d78455e1976f" category="doc">为 AWS 后端配置 CVS</block>
  <block id="f7dc2116b38f0f6097d64ca1dfdcd0b7" category="paragraph">了解如何使用提供的示例配置将适用于 AWS 的 NetApp Cloud Volumes Service （ CVS ）配置为 Astra Trident 安装的后端。</block>
  <block id="0eb1a8be2d6b9505f3b9940718c0c492" category="admonition">Cloud Volumes Service for AWS 不支持小于 100 GB 的卷。如果请求的卷较小， Trident 会自动创建 100 GB 的卷。</block>
  <block id="11873d2393ac3286e0e2949c7fb94c92" category="paragraph">以配置和使用<block ref="9185b014ee020a0dd27e376023f04353" category="inline-link-rx"></block> 后端，您需要满足以下要求：</block>
  <block id="162fd644b5a366df1c98de24d39a28e4" category="list-text">配置了 NetApp CVS 的 AWS 帐户</block>
  <block id="65e26b8fa373ad7924b14a196242b605" category="list-text">CVS 帐户的 API 区域， URL 和密钥</block>
  <block id="f8d960efa7386a75b65e6abbdb9e3c36" category="cell">"AWS-CVS"</block>
  <block id="a6a8368ae9ff89e7a4ca4c9e2b64ab56" category="cell">CVS 帐户区域。您可以在 CVS Web 门户中的帐户设置 /API 访问中找到此值。</block>
  <block id="3639c86d22a854ef10a2cacfe9eed25d" category="cell">`apiURL`</block>
  <block id="9aea3113f9edf591b1b341775bd7d092" category="cell">CVS 帐户 API URL 。您可以在 CVS Web 门户中的帐户设置 /API 访问中找到此值。</block>
  <block id="3fc6085f3573a8e927eea401950de8d3" category="cell">CVS 帐户 API 密钥。您可以在 CVS Web 门户中的帐户设置 /API 访问中找到此值。</block>
  <block id="9a5b66949f53f92871d3e1a8aae0cc19" category="cell">`secreKey`</block>
  <block id="e3891e2d275bb1f55f9de70059eed199" category="cell">CVS 帐户密钥。您可以在 CVS Web 门户中的帐户设置 /API 访问中找到此值。</block>
  <block id="1394ee99ba1680da948a315df62a7b62" category="admonition">每个 `区域` 的 "apiURL"` 都是唯一的。 `例如， us-west-2 `apiRegion` 具有<block ref="445c370e1a8fd8a5bb35e4bcf66dc8ff" category="inline-link-rx"></block> `apiURL` 。同样， us-east-1 `apiRegion` 也具有<block ref="89a36317c553c294eadd1c2b2e179f46" category="inline-link-rx"></block> `apiURL` 。请务必查看 CVS 信息板，了解后端配置的正确 `apiRegion` 和 `apiURL` 参数。</block>
  <block id="b4ba9ff8dbbcd251a1cb4e16ba80c36c" category="paragraph">每个后端都会在一个 AWS 区域中配置卷。要在其他区域创建卷，您可以定义其他后端。</block>
  <block id="781e781b44169c656fb79130bd8bd062" category="cell">控制 ` .snapshot` 目录的可访问性</block>
  <block id="ef81b740be2293b7e3c41047afe98764" category="cell">"100 克 "</block>
  <block id="635686d413c736dacb149d183959f020" category="admonition">对于在 CVS AWS 后端创建的所有卷， Astra Trident 会在配置存储池时将存储池上的所有标签复制到该存储卷。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="2f51b29f400aa735b4f4bd32f0eeed4f" category="paragraph">如果您刚刚开始使用 CVS AWS 并尝试执行相关操作，则此配置是理想的选择，但实际上您希望为所配置的卷提供更多范围界定。</block>
  <block id="55c1dd55273b867b995333cc3abd250e" category="section-title">示例 2 ：单服务级别配置</block>
  <block id="f8ee3192003a383290a06e5d20105030" category="paragraph">此示例显示了一个后端文件，该文件对 AWS us-east-1 区域中由 Astra Trident 创建的所有存储应用相同的方面。此示例还显示了后端文件中使用的 `proxyURL` 。</block>
  <block id="2b00c4aa6134b525e9355d880ecb0c8d" category="section-title">示例 3 ：虚拟存储池配置</block>
  <block id="ff342df7522d6b527768cc6bfe5f9fae" category="summary">通过 Astra Trident ， Kubernetes 用户可以在创建卷后对其进行扩展。查找有关扩展 iSCSI 和 NFS 卷所需配置的信息。</block>
  <block id="15d79b565b148caa23e6f2b53813413d" category="section-title">展开 iSCSI 卷</block>
  <block id="0b981ab19df55a28a02578aa5f326db8" category="paragraph">您可以使用 CSI 配置程序扩展 iSCSI 永久性卷（ PV ）。</block>
  <block id="f8f338469c62eb8604f5304af08466ba" category="admonition">iSCSI 卷扩展受 `ontap-san` ， `ontap-san-economy` ， `solidfire-san` 驱动程序支持，需要 Kubernetes 1.16 及更高版本。</block>
  <block id="13311fb741bdb3b9d877937311a2d64d" category="paragraph">扩展 iSCSI PV 包括以下步骤：</block>
  <block id="5141e3596f63bc5db3fd9ee32b736127" category="list-text">编辑 StorageClass 定义以将 `allowVolumeExpansion` 字段设置为 `true` 。</block>
  <block id="9e7362e47322994c4d272d377e83f31b" category="list-text">编辑 PVC 定义并更新 `sPec.resources.requests.storage` 以反映新需要的大小，该大小必须大于原始大小。</block>
  <block id="0860a1b7122f04033fb722b29d878468" category="list-text">要调整 PV 大小，必须将 PV 连接到 Pod 。调整 iSCSI PV 大小时，有两种情况：</block>
  <block id="7ac758b4597806f6880d9618fa093e52" category="list-text">如果 PV 连接到 Pod ，则 Astra Trident 会扩展存储后端的卷，重新扫描设备并调整文件系统大小。</block>
  <block id="7efffb2478ff651b7e45343b4e9f6fa8" category="list-text">尝试调整未连接 PV 的大小时， Astra Trident 会扩展存储后端的卷。将 PVC 绑定到 Pod 后， Trident 会重新扫描设备并调整文件系统大小。然后， Kubernetes 会在扩展操作成功完成后更新 PVC 大小。</block>
  <block id="ec3e34c26eaf059dc3ac58d8efc9fa37" category="paragraph">以下示例显示了扩展 iSCSI PV 的工作原理。</block>
  <block id="fe9ee1935ea7894fe4fd2f600993cd7d" category="section-title">第 1 步：配置 StorageClass 以支持卷扩展</block>
  <block id="c83b8171dcc233263cf7eeaef8da6a4d" category="paragraph">对于已存在的 StorageClass ，请对其进行编辑，使其包含 `allowVolumeExpansion` 参数。</block>
  <block id="59973fd7be015512b53fe121a13d5580" category="section-title">第 2 步：使用您创建的 StorageClass 创建 PVC</block>
  <block id="8592e7b08d26d1aa2ef3c44409c736fa" category="paragraph">Astra Trident 会创建一个永久性卷（ PV ）并将其与此永久性卷声明（ PVC ）关联。</block>
  <block id="8dacc1d7fdb5bfd3f8a4daedf3ccdd88" category="section-title">第 3 步：定义连接 PVC 的 POD</block>
  <block id="85f5dec267aa48cff82ccaf993019e6d" category="paragraph">在此示例中，创建了一个使用 `san-PVC` 的 Pod 。</block>
  <block id="ebae1958b6002fb43077a474d845284c" category="section-title">第 4 步：展开 PV</block>
  <block id="63188b171689bcd93b1ca818b3a2ab9c" category="paragraph">要将已创建的 PV 从 1Gi 调整为 2Gi ，请编辑 PVC 定义并将 `sPec.resources.requests.storage` 更新为 2Gi 。</block>
  <block id="eabf614ed44fe1c3e78cb2300949eb63" category="section-title">第 5 步：验证扩展</block>
  <block id="28abbd693f528f04d0ff068b3013fcd6" category="paragraph">您可以通过检查 PVC ， PV 和 Astra Trident 卷的大小来验证扩展是否正常运行：</block>
  <block id="75b8249751a8ea5869a0b5a8e465efc1" category="section-title">展开 NFS 卷</block>
  <block id="b5d3e13cbbf4f66f0d6b13357e86f974" category="paragraph">Astra Trident 支持对在 `ontap-nas` ， `ontap-nas-economy` ， `ontap-nas-flexgroup` ， `AWS-CVS` ， `GCP-CVS` 上配置的 NFS PV 进行卷扩展。 和 `azure-netapp-files` 后端。</block>
  <block id="578f10bb7cad2abad1cbbcb9a9a732f9" category="paragraph">要调整 NFS PV 的大小，管理员首先需要将 `allowVolumeExpansion` 字段设置为 `true` 来配置存储类以允许卷扩展：</block>
  <block id="27b4a9ed8609e35526601aa8d8be1ab9" category="paragraph">如果您已创建没有此选项的存储类，则只需使用 `kubectl edit storageclass` 编辑现有存储类即可进行卷扩展。</block>
  <block id="784f78e647973a0dcfa11b7a028c7eae" category="paragraph">Astra Trident 应为此 PVC 创建一个 20 MiB NFS PV ：</block>
  <block id="3b16cea25bd4a9aaf5a9c3dcc13ea7eb" category="section-title">第 3 步：展开 PV</block>
  <block id="e5c2c0bfcfbe01e6174199aaff9616a5" category="paragraph">要将新创建的 20MiB PV 调整为 1GiB ，请编辑 PVC 并将 `sPec.resources.requests.storage` 设置为 1GB ：</block>
  <block id="4a59ce1bc63fd7e6333968fb4bbd9d45" category="section-title">第 4 步：验证扩展</block>
  <block id="c70f05fed7c73e0be4a0b24c8532a87c" category="paragraph">您可以通过检查 PVC ， PV 和 Astra Trident 卷的大小来验证调整大小是否正常工作：</block>
  <block id="cf13ba16f33b5f6772614929649be6c2" category="summary">您可以使用 `tridentctl import` 将现有存储卷作为 Kubernetes PV 导入。</block>
  <block id="5f48c343984786005c9830d96c6fca87" category="doc">导入卷</block>
  <block id="3cf3b5626cbcac07ab0c5304e90870e8" category="section-title">支持卷导入的驱动程序</block>
  <block id="be8c8810fd80d5e84acf47d57d4e0dbc" category="paragraph">下表介绍了支持导入卷的驱动程序及其引入的版本。</block>
  <block id="b8e7b465df7c5979dc731d06e84ce2cf" category="cell">版本。</block>
  <block id="b7a56ff81a861dd454ce0ee6725a66c2" category="paragraph">19.04</block>
  <block id="cb4e2f5c0cf3e43444774c2af2ada914" category="section-title">为什么应导入卷？</block>
  <block id="b347f0936a6b1f232605f50447a930de" category="paragraph">将卷导入到 Trident 的使用情形有多种：</block>
  <block id="cbccddedba4ba9a336f83d60dd1454f0" category="list-text">对应用程序进行容器化并重复使用其现有数据集</block>
  <block id="f0dd3bee13b8c14005d98bfbb9a48bf3" category="list-text">为临时应用程序使用数据集的克隆</block>
  <block id="97161389816216aabbaffd954ef4a1f4" category="list-text">重建发生故障的 Kubernetes 集群</block>
  <block id="fd045b8743b2b7018e0480bc9a2dd4c5" category="list-text">在灾难恢复期间迁移应用程序数据</block>
  <block id="92f0642c89b416c59d914adfb1e33828" category="section-title">导入的工作原理是什么？</block>
  <block id="902881a0ede032887467576928b25fe0" category="paragraph">卷导入过程使用永久性卷声明（ PVC ）文件创建 PVC 。PVC 文件应至少包含 name ， namespace ， accessModes 和 storageClassName 字段，如以下示例所示。</block>
  <block id="be25b6ff84fa0d015f05f46bbbb6abd1" category="paragraph">使用 `tridentctl` 客户端导入现有存储卷。Trident 通过保留卷元数据并创建 PVC 和 PV 来导入卷。</block>
  <block id="bcf64a12adc519c7d409f80e5cccbe24" category="paragraph">要导入存储卷，请指定包含该卷的 Astra Trident 后端的名称以及用于唯一标识存储上的卷的名称（例如： ONTAP FlexVol ， Element Volume ， CVS 卷路径）。存储卷必须允许读 / 写访问，并可由指定的 Astra Trident 后端访问。需要 ` -f` 字符串参数，并指定 YAML 或 JSON PVC 文件的路径。</block>
  <block id="021814b63472d2b6dab37ce7d62c3ea2" category="paragraph">当 Astra Trident 收到导入卷请求时，系统会在 PVC 中确定并设置现有卷大小。存储驱动程序导入卷后，系统将创建 PV ，并为其创建一个 Claims Ref 。在 PV 中，回收策略最初设置为 `retain` 。Kubernetes 成功绑定 PVC 和 PV 后，将更新回收策略以匹配存储类的回收策略。如果存储类的回收策略为 `delete` ，则在删除 PV 时，存储卷将被删除。</block>
  <block id="9d0bcc94449080a9fef1873acd638fb3" category="paragraph">使用 ` -no-manage` 参数导入卷时， Trident 不会在对象的生命周期内对 PVC 或 PV 执行任何其他操作。由于 Trident 会忽略 ` -no-manage` 对象的 PV 和 PVC 事件，因此删除 PV 时不会删除存储卷。卷克隆和卷大小调整等其他操作也会被忽略。如果要对容器化工作负载使用 Kubernetes ，但希望在 Kubernetes 外部管理存储卷的生命周期，则此选项非常有用。</block>
  <block id="76057e180d7b3edcebaa935c7ccab687" category="paragraph">PVC 和 PV 中会添加一个标注，用于指示卷已导入以及 PVC 和 PV 是否已管理。不应修改或删除此标注。</block>
  <block id="b20cebeefba038b396f3fe0494dad01b" category="paragraph">Trident 19.07 及更高版本可处理 PV 的连接，并在导入卷时挂载该卷。对于使用早期版本的 Astra Trident 进行的导入，数据路径中不会执行任何操作，卷导入将不会验证是否可以挂载卷。如果卷导入出错（例如 StorageClass 不正确），您可以通过将 PV 上的回收策略更改为 `retain` ，删除 PVC 和 PV 并重试 volume import 命令来恢复。</block>
  <block id="420279975083139d76ba010ce1956b74" category="section-title">ontap-nas 和 ontap-nas-flexgroup 导入</block>
  <block id="1b539ba5a07e124e582b2e4bfc489200" category="paragraph">使用 `ontap-nas` 驱动程序创建的每个卷都是 ONTAP 集群上的一个 FlexVol 。使用 `ontap-NAS` 驱动程序导入 FlexVol 的工作原理相同。ONTAP 集群上已存在的 FlexVol 可以导入为 `ONONTAP -NAS` PVC 。同样，可以将 FlexGroup vols 导入为 `ontap-nas-flexgroup` PVC 。</block>
  <block id="62a991a68d1e323e147c11deeaecdad2" category="admonition">要由 Trident 导入 ONTAP 卷，必须为 rw 类型。如果卷的类型为 DP ，则为 SnapMirror 目标卷；应先中断镜像关系，然后再将卷导入到 Trident 中。</block>
  <block id="b368a23170f18969c0c51a21bc3e2754" category="admonition">`ontap-NAS` 驱动程序无法导入和管理 qtree 。`ontap-nas` 和 `ontap-nas-flexgroup` 驱动程序不允许使用重复的卷名称。</block>
  <block id="20a208be23a9e8a96ac28258acb9daa4" category="paragraph">例如，要在名为 `ontap_NAS` 的后端导入名为 `manage_volume` 的卷，请使用以下命令：</block>
  <block id="deba327c80a83b34abd4ba640b21e454" category="paragraph">要导入名为 `unmanageed_volume` 的卷（位于 `ontap_NAS 后端` 上），而 Trident 不会管理该卷，请使用以下命令：</block>
  <block id="9be12be7e9d5bb9faa5c9a952feafe07" category="paragraph">使用 ` -no-manage` 参数时， Trident 不会重命名卷或验证卷是否已挂载。如果卷未手动挂载，则卷导入操作将失败。</block>
  <block id="4004cfbd69335a9d1ba9357ea0dfb079" category="admonition">先前存在的使用自定义 UnixPermissions 导入卷的错误已得到修复。您可以在 PVC 定义或后端配置中指定 unixPermissions ，并指示 Astra Trident 相应地导入卷。</block>
  <block id="d346ffc6ef3483fea67a321732823960" category="section-title">ontap-san 导入</block>
  <block id="d995f4307341e76349912869caa5e2fb" category="paragraph">Astra Trident 还可以导入包含单个 LUN 的 ONTAP SAN FlexVol 。这与 `ontap-san` 驱动程序一致，该驱动程序会为 FlexVol 中的每个 PVC 和 LUN 创建一个 FlexVol 。您可以像在其他情况下一样使用 `tridentctl import` 命令：</block>
  <block id="1dd2cc952267be6c2cc8e5cff2b5aab1" category="list-text">请输入 `ontap-san` 后端的名称。</block>
  <block id="e395471eab1d4c8fbc8452e98a95d0c5" category="list-text">提供需要导入的 FlexVol 的名称。请记住，此 FlexVol 仅包含一个必须导入的 LUN 。</block>
  <block id="9e6bd670c6fd6b2808fae744834b7675" category="list-text">提供必须与 ` -f` 标志结合使用的 PVC 定义路径。</block>
  <block id="36b577af0f959f68e5e66336695e816c" category="list-text">可以选择对 PVC 进行管理，也可以选择不对其进行管理。默认情况下， Trident 将管理 PVC 并重命名后端的 FlexVol 和 LUN 。要作为非受管卷导入，请传递 ` -no-manage` 标志。</block>
  <block id="f898748ff73fc5faf70687cbb0051311" category="admonition">导入非受管 `ontap-san` 卷时，应确保 FlexVol 中的 LUN 名为 `lun0` ，并已映射到具有所需启动程序的 igroup 。Astra Trident 会自动为受管导入处理此问题。</block>
  <block id="66f7455d3b73d0f9938704ee67b1f38a" category="paragraph">然后， Astra Trident 将导入 FlexVol 并将其与 PVC 定义关联。Astra Trident 还会将 FlexVol 重命名为 `vc-&lt;uid&gt;` 格式，并将 FlexVol 中的 LUN 重命名为 `lun0` 。</block>
  <block id="2d37ad5bcf7d115e10de14a38db72232" category="admonition">建议导入没有活动连接的卷。如果要导入当前使用的卷，请先克隆该卷，然后再执行导入。</block>
  <block id="72b3664e6e381ccc62031c13f7ad6df9" category="paragraph">要导入 `ontap_san_default` 后端上存在的 `ontap-san-managed` FlexVol ，请运行 `tridentctl import` 命令：</block>
  <block id="26d61ca2331eea0b3aca6c534f2dfcc7" category="admonition">ONTAP 卷的类型必须为 RW ，才能由 Astra Trident 导入。如果卷的类型为 DP ，则为 SnapMirror 目标卷；在将卷导入到 Astra Trident 之前，应中断镜像关系。</block>
  <block id="4b8f39874197ebe1407531bd66624aa3" category="section-title">元素导入</block>
  <block id="b00215e0583bb02c2474fa62f51462fa" category="paragraph">您可以使用 Trident 将 NetApp Element 软件 /NetApp HCI 卷导入到 Kubernetes 集群中。您需要提供 Astra Trident 后端的名称以及卷和 PVC 文件的唯一名称作为 `tridentctl import` 命令的参数。</block>
  <block id="c517a1b34541565def824e8e9aeb0524" category="admonition">Element 驱动程序支持重复的卷名称。如果卷名称重复，则 Trident 的卷导入过程将返回错误。作为临时解决策，克隆卷并提供唯一的卷名称。然后导入克隆的卷。</block>
  <block id="441d2edc083114ed813856f0b61524d4" category="section-title">AWS-CVS 导入</block>
  <block id="828c3f28cef558031e2f55632d27b6f4" category="admonition">要在 AWS 中导入由 NetApp Cloud Volumes Service 支持的卷，请按卷路径而非名称来标识该卷。</block>
  <block id="91676978c9f14db1332e3c5b60f4d681" category="paragraph">要在后端导入名为 `awscvs_YEppr` 的 `AWS-CVS` 卷，并且卷路径为 `adrot-joly-swift` ，请使用以下命令：</block>
  <block id="87e30ad820e5b10036bd18284c1f25ad" category="admonition">卷路径是卷导出路径中： / 之后的部分。例如，如果导出路径为 `10.0.0.1 ： /adrot-joly-swift` ，则卷路径为 `adrot-joly-swift` 。</block>
  <block id="3be8989f2135d86f8b2d60f19eed3846" category="section-title">GCP-CVS 导入</block>
  <block id="ea6ab4f91ea921bc82295089f42da373" category="paragraph">导入 `GCP-CVS` 卷与导入 `AWS-CVS` 卷的工作原理相同。</block>
  <block id="9f25c8d8bca8641faa974c73a8d2f5da" category="section-title">Azure-netapp-files 导入</block>
  <block id="e8945ce1398c6d24aa1d518bca08034c" category="paragraph">要在后端导入 `azure-netapp-files` 卷，该卷名为 `azurenetappfiles_40517` ，卷路径为 `importvol1` ，请运行以下命令：</block>
  <block id="c3417eb755bee1658ae5b42ff2115193" category="admonition">ANF 卷的卷路径位于： / 之后的挂载路径中。例如，如果挂载路径为 `10.0.0.2 ： /importvol1` ，则卷路径为 `importvol1` 。</block>
  <block id="e4f61797b38c111b04c612b285a06659" category="summary">了解如何准备使用 ONTAP NAS 驱动程序配置 ONTAP 后端。</block>
  <block id="9bc537b16cee9c42d1e2aa0048a2c426" category="paragraph">了解如何准备使用 ONTAP NAS 驱动程序配置 ONTAP 后端。对于所有 ONTAP 后端， Astra Trident 需要至少为 SVM 分配一个聚合。</block>
  <block id="00b8b321c68facfb94b31690cbd23e00" category="paragraph">对于所有 ONTAP 后端， Astra Trident 需要至少为 SVM 分配一个聚合。</block>
  <block id="c6cd2f38be30f5256f7116692ab56edd" category="paragraph">请记住，您还可以运行多个驱动程序，并创建指向其中一个驱动程序的存储类。例如，您可以配置一个使用 `ontap-nas` 驱动程序` 的金牌类和一个使用 `ontap-nas-economy-one 的铜牌类。</block>
  <block id="fff0b214bfcab1734e0bec7b1d1f6079" category="paragraph">所有 Kubernetes 工作节点都必须安装适当的 NFS 工具。请参见 <block ref="9ec363a49b52db56773849151c5853d4" category="inline-link-macro-rx"></block> 有关详细信息：</block>
  <block id="07b434b23f63ca6490df33b213599320" category="section-title">管理 NFS 导出策略</block>
  <block id="9d66483f8378ffe30cde84e1b6dbf484" category="paragraph">Astra Trident 使用 NFS 导出策略来控制对其配置的卷的访问。</block>
  <block id="a297d9b7dbc393d5e8a5b3f98bcc9337" category="paragraph">使用导出策略时， Astra Trident 提供了两个选项：</block>
  <block id="0c87d42e666bbc299da2143379484281" category="list-text">Astra Trident 可以动态管理导出策略本身；在此操作模式下，存储管理员会指定一个表示可接受 IP 地址的 CIDR 块列表。Astra Trident 会自动将属于这些范围的节点 IP 添加到导出策略中。或者，如果未指定任何 CIDR ，则在节点上找到的任何全局范围的单播 IP 都将添加到导出策略中。</block>
  <block id="e6add289c2b1cd5da45e00f3098b35de" category="list-text">存储管理员可以手动创建导出策略和添加规则。除非在配置中指定了不同的导出策略名称，否则 Astra Trident 将使用默认导出策略。</block>
  <block id="4603f08ad837f4108ff2fe7665b0b1e3" category="section-title">动态管理导出策略</block>
  <block id="801eb935808311c71ba522e642d12e3f" category="paragraph">CSI Trident 20.04 版可以动态管理 ONTAP 后端的导出策略。这样，存储管理员就可以为工作节点 IP 指定允许的地址空间，而不是手动定义显式规则。它大大简化了导出策略管理；修改导出策略不再需要手动干预存储集群。此外，这有助于将对存储集群的访问限制为仅允许 IP 位于指定范围内的工作节点访问，从而支持精细的自动化管理。</block>
  <block id="8b78bee43bfa1617b12c311f0ad26e81" category="admonition">只有 CSI Trident 才支持动态管理导出策略。请务必确保工作节点未被 NAT 处理。</block>
  <block id="44568b7468885ca198a66bb088b9e3b5" category="paragraph">必须使用两个配置选项。下面是一个后端定义示例：</block>
  <block id="2aaaab87910c3ed67eecb3ea8578619e" category="admonition">使用此功能时，您必须确保 SVM 中的根接合具有预先创建的导出策略，并具有允许节点 CIDR 块的导出规则（例如默认导出策略）。请始终遵循 NetApp 建议的最佳实践，为 Astra Trident 专用 SVM 。</block>
  <block id="4975fc485ff51ca8f82c6ea96f927287" category="paragraph">以下是使用上述示例对此功能的工作原理进行的说明：</block>
  <block id="acdca8a11423c4bc209db0a1a4909294" category="list-text">`autosExportPolicy` 设置为 `true` 。这表示 Astra Trident 将为 `svm1` SVM 创建导出策略，并使用 `autosExportCIDRS` 地址块处理规则的添加和删除。例如， UUID 为 403b5326-8482-40db-96d0-d83fb3f4daec 且 `autodExportPolicy` 设置为 `true` 的后端会在 SVM 上创建一个名为 `trident -403b5326-8482-40db-96d0-d83fb3f4daec` 的导出策略。</block>
  <block id="1bdcc9b4be16b7ad2f1b54c892491a43" category="list-text">`autosExportCIDR` 包含地址块列表。此字段为可选字段，默认为 "0.0.0.0/0 ， " ：： /0" 。如果未定义，则 Astra Trident 会添加在工作节点上找到的所有全局范围的单播地址。</block>
  <block id="96d8905e0d42a0d3573c71fd4ecce0b8" category="paragraph">在此示例中，提供了 `192.168.0.0/24` 地址空间。这表示此地址范围内的 Kubernetes 节点 IP 将添加到 Astra Trident 创建的导出策略中。当 Astra Trident 注册其运行的节点时，它会检索该节点的 IP 地址，并根据 `autosExportCIDRS` 中提供的地址块对其进行检查。筛选 IP 后， Astra Trident 会为其发现的客户端 IP 创建导出策略规则，并为其标识的每个节点创建一个规则。</block>
  <block id="4646f167a1fb9819f41f28d5ab11c1fa" category="paragraph">创建后，您可以为后端更新 `autosExportPolicy` 和 `autosExportCIDR` 。您可以为自动管理的后端附加新的 CIDR ，也可以删除现有的 CIDR 。删除 CIDR 时请务必小心，以确保现有连接不会断开。您也可以选择对后端禁用 `autosExportPolicy` ，并回退到手动创建的导出策略。这需要在后端配置中设置 `exportPolicy` 参数。</block>
  <block id="18deff64a140a603bdb6070abed4eed4" category="paragraph">在 Astra Trident 创建或更新后端后，您可以使用 `tridentctl` 或相应的 `tridentbackend` CRD 检查后端：</block>
  <block id="83af513d9b9d50c1dc648bfea29797cb" category="paragraph">当节点添加到 Kubernetes 集群并向 Astra Trident 控制器注册后，现有后端的导出策略将会更新（前提是它们位于后端的 `autosExportCIDR` 中指定的地址范围内）。</block>
  <block id="fd85ad7b0ce4e83937cbc1012086b9b3" category="paragraph">删除节点后， Astra Trident 会检查所有联机后端，以删除该节点的访问规则。通过从受管后端的导出策略中删除此节点 IP ， Astra Trident 可防止恶意挂载，除非此 IP 可由集群中的新节点重复使用。</block>
  <block id="cda5977f42a72ef440d3b6233b9970bf" category="paragraph">对于以前存在的后端，使用 `tridentctl update backend` 更新后端可确保 Astra Trident 自动管理导出策略。这将创建一个以后端 UUID 命名的新导出策略，后端上存在的卷将在重新挂载时使用新创建的导出策略。</block>
  <block id="de1d1f6b64a5c5b6890c313888b290b7" category="admonition">删除具有自动管理导出策略的后端将删除动态创建的导出策略。如果重新创建后端，则会将其视为新的后端，并会创建新的导出策略。</block>
  <block id="920708f6d71767dcff22f9e43b4ec0c0" category="paragraph">如果更新了活动节点的 IP 地址，则必须在此节点上重新启动 Astra Trident Pod 。然后， Astra Trident 将更新其管理的后端的导出策略，以反映此 IP 更改。</block>
  <block id="5f3124ab7224f89a36fbb64fd2ebda15" category="summary">了解如何在您的 Astra Trident 安装中创建和使用 ONTAP SAN 驱动程序。本节提供了后端配置示例以及有关如何将后端映射到 StorageClasses 的详细信息。</block>
  <block id="19ce3b2e7823907e5153f00fe04f64f7" category="doc">配置选项和示例</block>
  <block id="a85f55a18073767a4945eac810e72cb2" category="cell">"ontap-nas" ， "ontap-nas-economy-" ， "ontap-nas-flexgroup" ， "ontap-san " ， "ontap-san-economy-"</block>
  <block id="237d7a1666794b0937adde704bb4795c" category="cell">驱动程序名称 + "_" + dataLIF</block>
  <block id="07c54fe26be1e43601e99cd9d4fbe262" category="cell">`m年` 月 日</block>
  <block id="bf926726f76b2da3a5585d6c7f464adc" category="cell">集群或 SVM 管理 LIF 的 IP 地址</block>
  <block id="c560b8d02093547d93a87c72d8b16eaf" category="cell">"10.0.0.1 " ， "2001 ： 1234 ： abcd ：：： fefe] "</block>
  <block id="bd81db53971fda3e688447b28c747d1a" category="cell">`dataLIF`</block>
  <block id="d78aba84ea5a1453c8c9f4a603a84040" category="cell">协议 LIF 的 IP 地址。对于 IPv6 ，请使用方括号。设置后无法更新</block>
  <block id="57b6222ff12a4dc5a5607f02194a83ce" category="cell">由 SVM 派生，除非另有说明</block>
  <block id="ab4ce1634362493e6de248d103136787" category="cell">`使用 CHAP`</block>
  <block id="3d6bb44641a25033325da197fbb8a670" category="cell">使用 CHAP 对 iSCSI 的 ONTAP SAN 驱动程序进行身份验证 [ 布尔值 ]</block>
  <block id="7c6b65d42434282f1555f13b40e9fd25" category="cell">`chapInitiatorSecret`</block>
  <block id="c8a7a6136447a56280ecf99e3ed87d65" category="cell">CHAP 启动程序密钥。如果为 `useCHAP=true` ，则为必需项</block>
  <block id="b5cbbe3dadaab4a036fdb38af67ee936" category="cell">要应用于卷的一组任意 JSON 格式的标签</block>
  <block id="948938ec6491061ccf17c7ae8eafbd26" category="cell">`chapTargetInitiatorSecret`</block>
  <block id="48db71efc42dda989b98744160575f4f" category="cell">CHAP 目标启动程序密钥。如果为 `useCHAP=true` ，则为必需项</block>
  <block id="28687fafefb2992ff7856dcfd2c29e1f" category="cell">`chapUsername`</block>
  <block id="e3f84c141fd3f4682dfb31e0d71c7f5f" category="cell">入站用户名。如果为 `useCHAP=true` ，则为必需项</block>
  <block id="62fbbf4cfd0cc0a82f953199d14a61e3" category="cell">`chapTargetUsername`</block>
  <block id="a379a576b788ab047d5e6405ff4f3511" category="cell">目标用户名。如果为 `useCHAP=true` ，则为必需项</block>
  <block id="cbdaf784161be9806a24fe78a8046c01" category="cell">`客户端证书`</block>
  <block id="a84cbedc106b973917ae925d04533f97" category="cell">客户端证书的 Base64 编码值。用于基于证书的身份验证</block>
  <block id="8545e54eea74cf2579fbe1cb56b11862" category="cell">`clientPrivateKey`</block>
  <block id="4a54228eb2be79492f8f76bb814ddf63" category="cell">客户端专用密钥的 Base64 编码值。用于基于证书的身份验证</block>
  <block id="b071cd8105f8f59b777098388b7a3322" category="cell">`trustedCACertifate`</block>
  <block id="ffe4ce29fe1a6176d496c40332e9cb98" category="cell">受信任 CA 证书的 Base64 编码值。可选。用于基于证书的身份验证</block>
  <block id="6d77646a2fd9ab65f8e3344d7dce661a" category="cell">`用户名`</block>
  <block id="83425e975af1b2d60355aa4162300198" category="cell">用于连接到集群 /SVM 的用户名。用于基于凭据的身份验证</block>
  <block id="6aa91a7fbb8c9edcf4aa5f9411aec19c" category="cell">`密码`</block>
  <block id="63d06d6cc41e485615f99a3aad0002b3" category="cell">连接到集群 /SVM 的密码。用于基于凭据的身份验证</block>
  <block id="afc423de2be5ca5ab3a6ae9548bbfcf3" category="cell">`sVM`</block>
  <block id="972abf48cbbadbcd573754140d35e19a" category="cell">要使用的 Storage Virtual Machine</block>
  <block id="ef65dd3301d78701f7cfcf8a01834f2f" category="cell">如果指定了 SVM `managementLIF` ，则派生</block>
  <block id="3b890f58db76bb3003ada171cd18c4db" category="cell">`igroupName`</block>
  <block id="19563dd7f566b71700028a34e74a1107" category="cell">要使用的 SAN 卷的 igroup 的名称</block>
  <block id="1c59f4b76e4f9bf529f88205cd0a8ac6" category="cell">"trident — &lt; 后端 UUID &gt;"</block>
  <block id="c08068da3c5d19547544c4bd424a6b76" category="cell">`s存储前缀`</block>
  <block id="e3f688f3aa653574b3253640aa98f47c" category="cell">在 SVM 中配置新卷时使用的前缀。设置后无法更新</block>
  <block id="a996d2f8e072c583d6cc26aa1e4aba87" category="cell">Trident</block>
  <block id="12d2394af47293b12d6b5f411f99a6d1" category="cell">`limitAggregateUsage`</block>
  <block id="b6ea9c09f8ac215ea68be83cd0240aac" category="cell">如果使用量超过此百分比，则配置失败。* 不适用于适用于 ONTAP 的 Amazon FSx *</block>
  <block id="c07510d6ca04643a0f81501d2407311b" category="cell">如果经济型驱动程序请求的卷大小超过此值，则配置失败。</block>
  <block id="9d96dfa28e7454a1119de523123a1e05" category="cell">" （默认情况下不强制实施）</block>
  <block id="c9a303edbc714d051896c3a678e59a8a" category="cell">`lunsPerFlexvol`</block>
  <block id="79892588cbecd0b88729ea1a55b2a3a4" category="cell">每个 FlexVol 的最大 LUN 数，必须在 50 ， 200 范围内</block>
  <block id="2d782f413944b272c911c548418a18a3" category="cell">100</block>
  <block id="f703d18584e163e18762e4dc13ad96a0" category="cell">`useREST`</block>
  <block id="1cd645595b39c5c8647c3c9a9c395322" category="cell">用于使用 ONTAP REST API 的布尔参数。* 技术预览 *</block>
  <block id="32a44f322750e15e2564c4648823248e" category="admonition">`useREST` 提供了一个 * 技术预览 * ，建议用于测试环境，而不是生产工作负载。如果设置为 `true` ，则 Astra Trident 将使用 ONTAP REST API 与后端进行通信。此功能需要使用 ONTAP 9.9 及更高版本。此外，使用的 ONTAP 登录角色必须能够访问 `ONTAP` 应用程序。这一点可通过预定义的 `vsadmin` 和 `cluster-admin` 角色来满足。</block>
  <block id="57dc6ee0e65147014833f0586de90e46" category="paragraph">要与 ONTAP 集群通信，您应提供身份验证参数。这可以是安全登录的用户名 / 密码，也可以是已安装的证书。</block>
  <block id="928832023634637f59ed58617f382728" category="admonition">如果您使用适用于 NetApp ONTAP 后端的 Amazon FSX ，请勿指定 `limitAggregateUsage` 参数。Amazon FSX for NetApp ONTAP 提供的 `fsxadmin` 和 `vsadmin` 角色不包含检索聚合使用情况并通过 Astra Trident 对其进行限制所需的访问权限。</block>
  <block id="dba7349d856fb1f0791cb0f6c700266f" category="paragraph">对于 `ontap-san` 驱动程序，默认使用 SVM 中的所有数据 LIF IP 并使用 iSCSI 多路径。为 `ontap-san` 驱动程序的 dataLIF 指定 IP 地址会强制其禁用多路径并仅使用指定的地址。</block>
  <block id="9f86d18c38ffc3e7be07fb38b682a8be" category="admonition">创建后端时，请记住，创建后无法修改 `dataLIF` 和 `storagePrefix` 。要更新这些参数，您需要创建一个新的后端。</block>
  <block id="2fbf62d46404d999a0e6179621b359a3" category="paragraph">可以将 `igroupName` 设置为已在 ONTAP 集群上创建的 igroup 。如果未指定，则 Astra Trident 会自动创建一个名为 trident -&lt;backender-UUUUUID&gt; 的 igroup 。如果要在环境之间共享 SVM ，则如果提供预定义的 igroupName ， NetApp 建议为每个 Kubernetes 集群使用一个 igroup 。这对于 Astra Trident 自动保持 IQN 添加 / 删除是必需的。</block>
  <block id="22599fe16404024d4ce4c8111293b8c2" category="paragraph">后端也可以在创建后更新 igroup ：</block>
  <block id="bc47775cbee2d365887513f379efaf66" category="list-text">可以更新 igroupName 以指向在 Astra Trident 之外的 SVM 上创建和管理的新 igroup 。</block>
  <block id="3e01e438ad7180641957b0d7d9716f65" category="list-text">可以省略 igroupName 。在这种情况下， Astra Trident 将自动创建和管理 trident -&lt;backend-UUUUID&gt; igroup 。</block>
  <block id="73e65f4bf1c67cf81e3531ab80adee7e" category="paragraph">在这两种情况下，仍可访问卷附件。未来的卷附件将使用更新后的 igroup 。此更新不会中断对后端卷的访问。</block>
  <block id="8a89357317a0c827764c86bc08ee62bd" category="paragraph">可以为 `managementLIF` 选项指定完全限定域名（ FQDN ）。</block>
  <block id="88afceb4bf710fa1663fc5c08b2b1bda" category="paragraph">对于所有 ONTAP 驱动程序，也可以将 `managementLIF` 设置为 IPv6 地址。请务必使用 ` -use-ipv6` 标志安装 Trident 。必须注意在方括号内定义 `managementLIF` IPv6 地址。</block>
  <block id="e896e54be988d9d7199d0e796b08b19b" category="admonition">使用 IPv6 地址时，请确保在方括号内定义 `managementLIF` 和 `dataLIF` （如果包含在后端定义中），例如 [28e8 ： d9fb ： a825 ： b7bf ： 69a8 ： d02f ： 9e7b ： 3555] 。如果未提供 `dataLIF` ，则 Astra Trident 将从 SVM 提取 IPv6 数据 LIF 。</block>
  <block id="18bfd4fb5bd53bc4e45e393e24c47255" category="paragraph">要使 ontap-san 驱动程序能够使用 CHAP ，请在后端定义中将 `useCHAP` 参数设置为 `true` 。然后， Astra Trident 将配置双向 CHAP 并将其用作后端给定 SVM 的默认身份验证。请参见 <block ref="8665da470a88e198066a0307a2be351b" category="inline-link-macro-rx"></block> 了解其工作原理。</block>
  <block id="f9f7357cc7873819dbc075deb62cba4b" category="paragraph">对于 `ontap-san-economi` 驱动程序， `limitVolumeSize` 选项还会限制它为 qtree 和 LUN 管理的卷的最大大小。</block>
  <block id="29669b1b587897fc488d8e332600d528" category="admonition">Astra Trident 会在使用 `ontap-san` 驱动程序创建的所有卷的 "Comments" 字段中设置配置标签。对于创建的每个卷， FlexVol 上的 "Comments" 字段将使用其所在存储池上的所有标签填充。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="193a49bcfb561fea878daa5efe72cad9" category="section-title">用于配置卷的后端配置选项</block>
  <block id="4b162a795c1916b18df8b6a76a8fef49" category="paragraph">您可以在配置的特殊部分中使用这些选项来控制默认配置每个卷的方式。有关示例，请参见以下配置示例。</block>
  <block id="a0ee23c5b4cbd6a28a4143933891f927" category="cell">`spaceAllocation`</block>
  <block id="26161d08a960162cd8633d0e23058aed" category="cell">LUN 的空间分配</block>
  <block id="3be488c6a2bc52ceb7e8685ca24927d7" category="cell">true</block>
  <block id="a6bddf19eed00dbe2199864dee8454ce" category="cell">`s页面预留`</block>
  <block id="3bce5b103341500856287f5347e19f28" category="cell">空间预留模式； " 无 " （精简）或 " 卷 " （厚）</block>
  <block id="e84c56670c389b09fcad5da7309a165b" category="cell">无</block>
  <block id="0ec3875cf79264e4689a646be2f704b6" category="cell">`sSnapshot 策略`</block>
  <block id="77f69e470b8766d2dc5df4b7f469ed72" category="cell">要使用的 Snapshot 策略</block>
  <block id="84d2c2c768bd1900489bad5fb46b4aac" category="cell">`qosPolicy`</block>
  <block id="54b94bba5d336f4e3d5fd7e88544fad1" category="cell">要为创建的卷分配的 QoS 策略组。选择每个存储池 / 后端的 qosPolicy 或 adaptiveQosPolicy 之一</block>
  <block id="952e3a12d35e717bf86a6000b0c08976" category="cell">`adaptiveQosPolicy`</block>
  <block id="036c0eabd455d8a92d350429f2f5747e" category="cell">要为创建的卷分配的自适应 QoS 策略组。选择每个存储池 / 后端的 qosPolicy 或 adaptiveQosPolicy 之一</block>
  <block id="11f9fcd55c1d81cf352f86fe4cdfd444" category="cell">为快照预留的卷百分比为 "0"</block>
  <block id="af6626456fa359992271ea88de34094f" category="cell">如果 `snapshotPolicy` 为 " 无 " ，则为 " 无 " ，否则为 " "</block>
  <block id="4be01095ce6e500084fc427e5dec61ac" category="cell">`splitOnClone`</block>
  <block id="6f5c0c94b1a17baffd2c33facaa10db6" category="cell">创建克隆时，从其父级拆分该克隆</block>
  <block id="19b4c847405d74614976bd1228f59c9f" category="cell">false</block>
  <block id="b091cbafedf94db98f17823d044434bd" category="cell">`加密`</block>
  <block id="4ecb8b22870f9fb0645228cd38177c49" category="cell">启用 NetApp 卷加密</block>
  <block id="a463baaf6666da7178b6fc6a3c8a3fee" category="cell">`securityStyle`</block>
  <block id="41da49bdd3fd88b2ddc6be7d6df1b335" category="cell">新卷的安全模式</block>
  <block id="4cda9f87625c6278fae1a50fcbbf96d3" category="cell">"unix"</block>
  <block id="31aa018945eb62580d68d360cba8ba54" category="cell">`分层策略`</block>
  <block id="592a5879ac095ef6ca504cc43a9d7939" category="cell">使用 " 无 " 的分层策略</block>
  <block id="ee6508d5290be6edafccc6e0f471f120" category="cell">适用于 ONTAP 9.5 SVM-DR 之前的配置的 " 仅快照 "</block>
  <block id="99c2306b30b8939278f0f817230f3573" category="admonition">在 Astra Trident 中使用 QoS 策略组需要 ONTAP 9.8 或更高版本。建议使用非共享 QoS 策略组，并确保策略组分别应用于每个成分卷。共享 QoS 策略组将对所有工作负载的总吞吐量实施上限。</block>
  <block id="05c4365fe7e90a545f8b24060094a36a" category="paragraph">下面是定义了默认值的示例：</block>
  <block id="fab51d2bc90465982b0994bc86e69db9" category="admonition">对于使用 `ontap-san` 驱动程序创建的所有卷， Astra Trident 会向 FlexVol 额外添加 10% 的容量，以容纳 LUN 元数据。LUN 将使用用户在 PVC 中请求的确切大小进行配置。Astra Trident 将 FlexVol 增加 10% （在 ONTAP 中显示为可用大小）。用户现在将获得所请求的可用容量。此更改还可防止 LUN 变为只读状态，除非已充分利用可用空间。这不适用于 ontap-san-economy.</block>
  <block id="824d88f50ab9e39778b0ef5bc2516b2f" category="paragraph">对于定义 `snapshotReserve` 的后端， Astra Trident 将按如下方式计算卷的大小：</block>
  <block id="4e762198289d9294de9c1cbb3f0b26b6" category="paragraph">1.1 是 Astra Trident 向 FlexVol 额外添加 10% 以容纳 LUN 元数据。对于 `snapshotReserve` = 5% ， PVC 请求 = 5GiB ，卷总大小为 5.79GiB ，可用大小为 5.5GiB 。`volume show` 命令应显示与以下示例类似的结果：</block>
  <block id="2f1534ee8d0c6ec998511ed37cfe0da9" category="image-alt">显示了 volume show 命令的输出。</block>
  <block id="e6e049b4753c744e95db32b0eeed8d5c" category="paragraph">目前，调整大小是对现有卷使用新计算的唯一方法。</block>
  <block id="2aae2b6accd04335b3eeceb2193b34d6" category="section-title">最低配置示例</block>
  <block id="bca36ce39f61ce2d375cbdb66eab5162" category="paragraph">以下示例显示了将大多数参数保留为默认值的基本配置。这是定义后端的最简单方法。</block>
  <block id="19fd94d2657fdd90c44f1fcd72890482" category="admonition">如果您正在将 NetApp ONTAP 上的 Amazon FSx 与 Astra Trident 结合使用，建议为 LIF 指定 DNS 名称，而不是 IP 地址。</block>
  <block id="f9e7424816477078eb0e49bf4eb4c87e" category="section-title">具有基于证书的身份验证的 ontap-san 驱动程序</block>
  <block id="78e5b29e139db71ceb7ca6bc99b5e228" category="paragraph">这是一个最低后端配置示例。`clientCertificate` ， `clientPrivateKey` 和 `trustedCACertifate` （如果使用可信 CA ，则可选）分别填充在 `backend.json` 中，并采用客户端证书，私钥和可信 CA 证书的 base64 编码值。</block>
  <block id="9d6b2226030e3a797fc7ff6dbd810f66" category="section-title">具有双向 CHAP 的 ONTAP SAN 驱动程序</block>
  <block id="b0a5c44c844418c2a5474a0d4c19182c" category="paragraph">这是一个最低后端配置示例。此基本配置将创建一个 `ontap-san` 后端，并将 `useCHAP` 设置为 `true` 。</block>
  <block id="08f9dab0885378aea00f731ad9e52901" category="section-title">ontap-san-economy-driver</block>
  <block id="6bef8424baf7897ad4b3ecd9446fc7c8" category="section-title">虚拟存储池后端示例</block>
  <block id="54189b80c641ffe9ac5ea57dc48e465c" category="paragraph">在下面显示的示例后端定义文件中，会为所有存储池设置特定的默认值，例如 `spaceReserve` at none ， `spaceAllocation` at false 和 `encryption` at false 。虚拟存储池在存储部分中进行定义。</block>
  <block id="6a24af0a579ec0e851db9d35e047d58e" category="paragraph">在此示例中，某些存储池会设置自己的 `spaceReserve` ， `spaceAllocation` 和 `encryption` 值，而某些池会覆盖上述设置的默认值。</block>
  <block id="22aec9ab9f9270747cb10c5bd593c1ab" category="paragraph">以下是 `ontap-san-economy-经济` 驱动程序的 iSCSI 示例：</block>
  <block id="f00b69018be0961b32ee24ec54fb56d1" category="section-title">将后端映射到 StorageClasses</block>
  <block id="5303cd360e4a1dda505149e2497f5dd0" category="list-text">第一个 StorageClass （`protection-gold` ）将映射到 `ontap-nas-flexgroup` 后端的第一个，第二个虚拟存储池以及 `ontap-san` 后端的第一个虚拟存储池。这是唯一一个提供黄金级保护的池。</block>
  <block id="b56bbc7832c420bea7e7ad925a5d3c31" category="list-text">第二个 StorageClass （`protection-not-gold` ）将映射到 `ontap-nas-flexgroup` 后端的第三个，第四个虚拟存储池以及 `ontap-san` 后端的第二个，第三个虚拟存储池。这些池是唯一提供黄金级以外保护级别的池。</block>
  <block id="93e138c887e529cb6657f632aa3a3867" category="list-text">第三个 StorageClass （`app-mysqldb` ）将映射到 `ontap-NAS` 后端的第四个虚拟存储池和 `ontap-san-economy-backend` 的第三个虚拟存储池。这些池是唯一为 mysqldb 类型的应用程序提供存储池配置的池。</block>
  <block id="a445ee76dc7da803a09c273595c3555c" category="list-text">第四个存储类（`protection-silver-creditpoins-20k` ）将映射到 `ontap-nas-flexgroup` 后端的第三个虚拟存储池和 `ontap-san` 后端的第二个虚拟存储池。这些池是唯一以 20000 个信用点提供黄金级保护的池。</block>
  <block id="a2d5d3b55b3cff0e83e0c8feac3dfb45" category="list-text">第五个存储类（`credits-5k` ）将映射到 `ontap-nas-economy-backend` 中的第二个虚拟存储池和 `ontap-san` 后端的第三个虚拟存储池。这些是唯一一款具有 5000 个信用点的池产品。</block>
  <block id="dc92c330959507a128db0801090f9e0d" category="paragraph">Astra Trident 将决定选择哪个虚拟存储池，并确保满足存储要求。</block>
  <block id="ef1161058705470bb877fbce688eea9e" category="summary">了解如何使用 ONTAP SAN 驱动程序配置 ONTAP 后端。</block>
  <block id="31e8c05beab321d1465fc4c3f77e991a" category="doc">使用 ONTAP SAN 驱动程序配置后端</block>
  <block id="6c728e8788471413351ba9fcd26ca76e" category="list-text"><block ref="6c728e8788471413351ba9fcd26ca76e" category="inline-link-macro-rx"></block></block>
  <block id="e5fc4f2bd89271cfb112e8b768f74dde" category="inline-link-macro">配置和示例</block>
  <block id="874216718c1d50bbd2aa417449058e46" category="list-text"><block ref="874216718c1d50bbd2aa417449058e46" category="inline-link-macro-rx"></block></block>
  <block id="ce8828fc10a926c196951c9bdd0d534d" category="section-title">用户权限</block>
  <block id="96c17dbe45e7351fb2a4f71956c25e0c" category="paragraph">Astra Trident 应以 ONTAP 或 SVM 管理员身份运行，通常使用 `admin` cluster 用户或 `vsadmin` SVM 用户，或者使用具有相同角色的其他名称的用户。对于适用于 NetApp ONTAP 的 Amazon FSX 部署， Astra Trident 应使用集群 `fsxadmin` user 或 `vsadmin` SVM 用户或具有相同角色的其他名称的用户作为 ONTAP 或 SVM 管理员运行。`fsxadmin` 用户是集群管理员用户的有限替代用户。</block>
  <block id="4937b52eb2cb058f225b69b2caafaf29" category="admonition">如果使用 `limitAggregateUsage` 参数，则需要集群管理员权限。将适用于 NetApp ONTAP 的 Amazon FSx 与 Astra Trident 结合使用时， `limitAggregateUsage` 参数不适用于 `vsadmin` 和 `fsxadmin` 用户帐户。如果指定此参数，配置操作将失败。</block>
  <block id="821b0ad941ad2559ef18eb8de56a470e" category="summary">Kubernetes 集群中的所有工作节点都需要能够挂载为 Pod 配置的卷。如果您在其中一个后端使用的是 ontap-nas ， ontap-nas-economy. ontap-nas-flexgroup 驱动程序，则您的工作节点需要 NFS 工具。否则，它们需要使用 iSCSI 工具。</block>
  <block id="89d83ec6e8ec0c087fbc4aedc555b362" category="doc">准备工作节点</block>
  <block id="8b1d1603c11aec689eb0d88a5ebabb67" category="paragraph">Kubernetes 集群中的所有工作节点都需要能够挂载为 Pod 配置的卷。如果您在其中一个后端使用 `ontap-nas` ， `ontap-nas-economy` 或 `ontap-nas-flexgroup` 驱动程序，则您的工作节点需要 NFS 工具。否则，它们需要使用 iSCSI 工具。</block>
  <block id="9e4d9c5be865862a92caf88e2beae43f" category="paragraph">默认情况下，最新版本的 RedHat CoreOS 同时安装了 NFS 和 iSCSI 。</block>
  <block id="f5c6a9fc65ae9fb698dc758b23c4ee97" category="admonition">安装 NFS 或 iSCSI 工具后，您应始终重新启动工作节点，否则将卷连接到容器可能会失败。</block>
  <block id="b7a66d04a41292979004906785008ca9" category="section-title">NFS volumes</block>
  <block id="696c660ff8d9323e55146a6dbd4e4088" category="cell">操作系统</block>
  <block id="c441ee50c88f6e5e3a7c69fc69dad8b8" category="cell">命令</block>
  <block id="3fb1c9901f28248a22f47bd3917b5dc9" category="paragraph">RHEL/CentOS</block>
  <block id="e0b19bed1baf46134f4079471e193b01" category="paragraph">`sudo yum install -y nfs-utils`</block>
  <block id="7eaf289636bc8d4f8b29b333a0f32dc2" category="paragraph">Ubuntu 或 Debian</block>
  <block id="1054b270f1635a3dd940e995cbc7ed78" category="paragraph">`sudo apt-get install -y nfs-common`</block>
  <block id="31562df6c30f7b7efb939eaa0ee48415" category="admonition">您应确保 NFS 服务在启动期间启动。</block>
  <block id="29ba980a9e9adedc9414ea868c74ebd5" category="section-title">iSCSI 卷</block>
  <block id="222194999a60d89dfcd0ff5867f49e88" category="paragraph">使用 iSCSI 卷时，请考虑以下事项：</block>
  <block id="12fe03bf2457cc4e4e90af10a2f7092f" category="list-text">Kubernetes 集群中的每个节点都必须具有唯一的 IQN 。* 这是必要的前提条件 * 。</block>
  <block id="aaa200e86b57cd2a527761ec2bf4b9b0" category="list-text">如果将 RHCOS 4.5 或更高版本，或者将 RHEL 或 CentOS 8.2 或更高版本与 `solidfire-san` 驱动程序结合使用，请确保在 ` /etc/iscsi/iscsid.conf` 中将 CHAP 身份验证算法设置为 MD5 。</block>
  <block id="0bad70dcf33f40dcc0d528d58b9eac76" category="inline-link">RedHat 的文档</block>
  <block id="dbb4705e17a1f8ba49af109d4f366609" category="list-text">使用运行 RHEL/RedHat CoreOS 和 iSCSI PV 的工作节点时，请确保在 StorageClass 中指定 `discard` mountOption 以执行实时空间回收。请参见<block ref="166e862efdc516354d90f75a38532ddd" category="inline-link-rx"></block>。</block>
  <block id="8cd5b262d8d9950185128d052d55f7c8" category="list-text">安装以下系统软件包：</block>
  <block id="6bbf3284462dc8b9b90cb1adcd1c0ff4" category="paragraph">`sudo yum install -y lsscsi iscsi-initiator-utils sg3_utils device-mapper-multipath`</block>
  <block id="1a5157a00ea5806f553766d5b3b114fd" category="list-text">检查 iscsi-initiator-utils 版本是否为 6.2.0.877-2.el7 或更高版本：</block>
  <block id="55c13faac514053f94cef55eb316c9a4" category="paragraph">`rpm -q iscsi-initiator-utils`</block>
  <block id="19955b3c2d2c1cfc1c82c2fe0347a065" category="list-text">将扫描设置为手动：</block>
  <block id="d2db641a196e6107eecf8c32f7cd7a4e" category="paragraph">`sUdo sed -i 's/^ \ （ node.session.scan\).*/\1 = manual/' /etc/iscsi/iscsid.conf`</block>
  <block id="d0b02d407fd5c75d0e7eac549a852191" category="list-text">启用多路径：</block>
  <block id="87772a853423d643181e2b56bcb4b17f" category="paragraph">`sudo mpathconf -enable -with multipathd y`</block>
  <block id="8bec0eea71974a9138ccfa96983ddcfc" category="list-text">确保 `iscsid` 和 `multipathd` 正在运行：</block>
  <block id="90a9d2e9b1b4ae58a957ff989f0732ba" category="paragraph">`sudo systemctl enable -now iscsid multipathd`</block>
  <block id="8018f5d6ddc4e67678d1659757828deb" category="list-text">启用并启动 `iSCSI` ：</block>
  <block id="0f905161e16c2cfa712f1fb7640afee4" category="paragraph">`sudo systemctl enable —现在为 iSCSI`</block>
  <block id="28ea88befb3a7f6a8e98e7ea7a4fd35f" category="paragraph">`sUdo apt-get install -y open-iscsi lsscsi sg3-utils multipath-tools scsitool`</block>
  <block id="a53508e75911225e5de8b5febc82cf12" category="list-text">检查 open-iscsi 版本是否为 2.0.877-5ubuntu2.10 或更高版本（对于双子系统）或 2.0.877-7.1ubuntu6.1 或更高版本（对于 Focal ）：</block>
  <block id="f6802be29c6bca93d8f44768b0347ac9" category="paragraph">`dpkg -l open-iscsi`</block>
  <block id="b163c84ad8a4e55a17b51aad8074093e" category="list-text">确保已启用并运行 `open-iscsi` 和 `multipath-tools` ：</block>
  <block id="8741473f7a80f4dd83071161b2c95301" category="paragraph">`sudo systemctl status multipath-tools` `sudo systemctl enable -now open-iscsi.service` `sudo systemctl status open-iscsi`</block>
  <block id="1b757fe9c8a149de349a32b8d21feb54" category="admonition">对于 Ubuntu 18.04 ，您必须先使用 `iscsiadm` 发现目标端口，然后再启动 `open-iscsi` ， iSCSI 守护进程才能启动。您也可以将 `iscsi` 服务修改为自动启动 `iscsid` 。</block>
  <block id="fc1adc7c8cce02d3bd3dbc3e7ae52990" category="admonition">如果您希望了解有关自动员工节点准备的更多信息，这是一项测试功能，请参见 <block ref="a57ab171c518329af81ea9d2536c4e10" category="inline-link-macro-rx"></block>。</block>
  <block id="4cc2b9916e7383e5fa29dc6188159e32" category="summary">后端定义了 Astra Trident 与存储系统之间的关系。它告诉 Astra Trident 如何与该存储系统进行通信，以及 Astra Trident 如何从该存储系统配置卷。安装 Astra Trident 后，下一步是创建后端。使用 `TridentBackendConfig` Custom Resource Definition （ CRD ），您可以直接通过 Kubernetes 界面创建和管理 Trident 后端。为此，您可以对 Kubernetes 分发版使用 `kubectl` 或等效的命令行界面工具。</block>
  <block id="913a4b06671d1e04e6582a85afe3abbe" category="section-title">TridentBackendConfig</block>
  <block id="d2031a5a319b9363cf98da6b1509598a" category="paragraph">`TridentBackendConfig` （`tbc` ， `tbconfig` ， `tbackendconfig` ）是一个前端命名的 CRD ，可用于使用 `kubectl` 管理 Astra Trident 后端。现在， Kubernetes 和存储管理员可以直接通过 Kubernetes 命令行界面创建和管理后端，而无需专用命令行实用程序（`tridentctl` ）。</block>
  <block id="b44c2fd5cefc815abed7e31c0fa8c8ac" category="paragraph">创建 `TridentBackendConfig` 对象时，将发生以下情况：</block>
  <block id="858fafdff7fa27f202ae0eb981c6dff0" category="list-text">Astra Trident 会根据您提供的配置自动创建后端。此值在内部表示为 `TridentBackend` （`tbe` ， `tridentbackend` ） CR 。</block>
  <block id="40640dd98ca175d098c1c765b1e148d9" category="list-text">`TridentBackendConfig` 唯一绑定到由 Astra Trident 创建的 `TridentBackend` 。</block>
  <block id="1efc3a14ca6dc7c90db79e02f3abe7d5" category="paragraph">每个 `TridentBackendConfig` 都与 `TridentBackend` 保持一对一映射。前者是为用户提供的用于设计和配置后端的接口；后者是 Trident 表示实际后端对象的方式。</block>
  <block id="c9038f47fe0df535b6bf5619c9ff629e" category="admonition">`TridentBackend` CRS 由 Astra Trident 自动创建。您 * 不应 * 修改它们。如果要更新后端，请通过修改 `TridentBackendConfig` 对象来执行此操作。</block>
  <block id="9c3385530cf6e460576e5f6e7cc1b912" category="paragraph">有关 `TridentBackendConfig` CR 的格式，请参见以下示例：</block>
  <block id="c84ef67352bb6783ff2881f9f2821c2a" category="inline-link">Trident 安装程序</block>
  <block id="f13a06ff6eab87969a9f96765f31ed9c" category="paragraph">您还可以查看中的示例<block ref="6511e50af21389f9e77db56e03f6dd72" category="inline-link-rx"></block> 所需存储平台 / 服务的示例配置目录。</block>
  <block id="06df669f3ef6f929e9b58c9f47b65310" category="inline-link-macro">存储驱动程序的后端配置信息</block>
  <block id="182839d8f6b2bdde60e1d972422cf3a2" category="paragraph">`sPec` 采用后端特定的配置参数。在此示例中，后端使用 `ontap-san` 存储驱动程序并使用此处所示的配置参数。有关所需存储驱动程序的配置选项列表，请参见 <block ref="5f2d139eefa7c36061f4d97161be02ea" category="inline-link-macro-rx"></block>。</block>
  <block id="92051c832f01d9070a7ed71d1ce523c5" category="paragraph">`sPec` 部分还包括 `credentials` 和 `deletionPolicy` 字段，这些字段在 `TridentBackendConfig` CR 中新增：</block>
  <block id="5ab961de690e071f0dc1c0dabac7fd89" category="list-text">`credentials` ：此参数为必填字段，包含用于向存储系统 / 服务进行身份验证的凭据。此密码设置为用户创建的 Kubernetes Secret 。凭据不能以纯文本形式传递，因此会导致错误。</block>
  <block id="9f11e03722a7b912083c63fc68f4dd7b" category="list-text">`deeltionPolicy` ：此字段定义删除 `TridentBackendConfig` 时应发生的情况。它可以采用以下两种可能值之一：</block>
  <block id="d09d50d3f84f9c585492818f491a2497" category="list-text">`delete` ：这将同时删除 `TridentBackendConfig` CR 和关联后端。这是默认值。</block>
  <block id="f0c89ce27bf4c43949ad8f26a4f586bb" category="list-text">`retain` ：删除 `TrdentBackendConfig` CR 后，后端定义仍存在，可使用 `tridentctl` 进行管理。将删除策略设置为 `retain` 允许用户降级到早期版本（ 21.04 之前）并保留创建的后端。创建 `TridentBackendConfig` 后，可以更新此字段的值。</block>
  <block id="7f2208582df334d090d35357eb5d6901" category="admonition">后端名称使用 `sPec.backendName` 设置。如果未指定，则后端的名称将设置为 `TridentBackendConfig` 对象的名称（ metadata.name ）。建议使用 `sPec.backendName` 显式设置后端名称。</block>
  <block id="317e77f416ffd109037a657fffa1e7f7" category="admonition">使用 `tridentctl` 创建的后端没有关联的 `TridentBackendConfig` 对象。您可以通过创建 `TridentBackendConfig` CR ，选择使用 `kubectl` 来管理此类后端。必须注意指定相同的配置参数（例如 `sPec.backendName` ， `sPec.storagePrefix` ， `sPec.storageDriverName` 等）。Astra Trident 会自动将新创建的 `TridentBackendConfig` 与已有的后端绑定。</block>
  <block id="625cc9b8ccc34496dc2b3fcffb7e384a" category="section-title">步骤概述</block>
  <block id="a867c4bbc8d632a517f22b7377b9b8ed" category="paragraph">要使用 `kubectl` 创建新后端，应执行以下操作：</block>
  <block id="4db4699aa0126dfb06878d7e07c0abdf" category="inline-link">Kubernetes 机密</block>
  <block id="7e5e1bb39eefe4eec7a88b845126d41d" category="list-text">创建<block ref="fcce7b7bd05b6b012eabe3df8de04808" category="inline-link-rx"></block>。此密钥包含 Astra Trident 与存储集群 / 服务通信所需的凭据。</block>
  <block id="c39d193a9cc4084cc6c7964e1bb5efd8" category="list-text">创建 `TridentBackendConfig` 对象。其中包含有关存储集群 / 服务的详细信息，并引用了上一步中创建的密钥。</block>
  <block id="286b0035cf59742ffe54696b798f2368" category="paragraph">创建后端后，您可以使用 `kubectl get tbc &lt;tbc-name&gt; -n &lt;trident 命名空间 &gt;` 来观察其状态，并收集其他详细信息。</block>
  <block id="494cb787cd1c1f78123323c1006f2081" category="section-title">第 1 步：创建 Kubernetes 机密</block>
  <block id="a8c4d0cb53af2c6e334f5c58890021d6" category="paragraph">创建一个机密，其中包含后端的访问凭据。这是每个存储服务 / 平台所特有的。以下是一个示例：</block>
  <block id="04402bf69acac56c72a55c0e4ac2165c" category="paragraph">下表汇总了每个存储平台的机密中必须包含的字段：</block>
  <block id="94cec86c6eef229009007e6d00d54ef1" category="cell">存储平台机密字段问题描述</block>
  <block id="1e6947ac7fb3a9529a9726eb692c8cc5" category="cell">机密</block>
  <block id="c11257eff6563de2c05e353770c514ca" category="cell">字段问题描述</block>
  <block id="93c5bebdea9c94a0740fe6fd9bb250f0" category="paragraph">clientId</block>
  <block id="012e85295e2f1f744cfb8757f8dd4830" category="paragraph">应用程序注册中的客户端 ID</block>
  <block id="c9ff119073ea2567730fb42e3a4fe805" category="paragraph">apiKey</block>
  <block id="defb11bd732dde7d185fcc4583818851" category="paragraph">CVS 帐户 API 密钥</block>
  <block id="ce656850400574e9f9cffb285ee8abc0" category="paragraph">secretKey</block>
  <block id="5324944de62956f7d758fd5d2f6d8826" category="paragraph">CVS 帐户密钥</block>
  <block id="ee64ef6c307cfcfe5c0f085471cd61fa" category="paragraph">private_key_id</block>
  <block id="1e31c22f827d25c5973eee697baace79" category="paragraph">专用密钥的 ID 。具有 CVS 管理员角色的 GCP 服务帐户的 API 密钥的一部分</block>
  <block id="156a17333e77a3c504018cae5ada8c3b" category="paragraph">private_key</block>
  <block id="8e0708b67ba6ce0f70a948152e7e7895" category="paragraph">专用密钥。具有 CVS 管理员角色的 GCP 服务帐户的 API 密钥的一部分</block>
  <block id="25de05ab7f10e99b499db62e0b89ad33" category="cell">Element （ NetApp HCI/SolidFire ）</block>
  <block id="2a6ba72e93aa7fa676d07973ed2716bb" category="paragraph">端点</block>
  <block id="14c4b06b824ec593239362517f538b29" category="paragraph">username</block>
  <block id="6e1b40351708d93ce8c387f6f8ca7533" category="paragraph">用于连接到集群 /SVM 的用户名。用于基于凭据的身份验证</block>
  <block id="5f4dcc3b5aa765d61d8327deb882cf99" category="paragraph">password</block>
  <block id="4d3fd9a7ab4c84b857fc26b2633237d0" category="paragraph">连接到集群 /SVM 的密码。用于基于凭据的身份验证</block>
  <block id="19dce7ac7f5290fc8fa218ad0c858df5" category="paragraph">客户端权限密钥</block>
  <block id="8c5e8d4f9acf9295e1a96feef0c0b516" category="paragraph">客户端专用密钥的 Base64 编码值。用于基于证书的身份验证</block>
  <block id="039e9d80fa53ba861c06b590ba3f9d34" category="paragraph">用户名</block>
  <block id="a7128cd45d4a277fe5c6ed6f6c4238f7" category="paragraph">入站用户名。如果 useCHAP=true ，则为必需项。适用于 `ontap-san` 和 `ontap-san-economy.`</block>
  <block id="f9d0dc78b203f2c1106dc0c7d58a5397" category="paragraph">chapInitiatorSecret</block>
  <block id="2f573af61fb37b4f1c5e2def2341b7c4" category="paragraph">CHAP 启动程序密钥。如果 useCHAP=true ，则为必需项。适用于 `ontap-san` 和 `ontap-san-economy.`</block>
  <block id="2ebe107bb3bc9551fbb0e5033046931c" category="paragraph">chapTargetUsername</block>
  <block id="e945f079b3e50bd5722f056b72282608" category="paragraph">目标用户名。如果 useCHAP=true ，则为必需项。适用于 `ontap-san` 和 `ontap-san-economy.`</block>
  <block id="4ab84a55744951d967033db9b64f6b27" category="paragraph">chapTargetInitiatorSecret</block>
  <block id="61b50fba255c10a4a2b5f7cf8276849a" category="paragraph">CHAP 目标启动程序密钥。如果 useCHAP=true ，则为必需项。适用于 `ontap-san` 和 `ontap-san-economy.`</block>
  <block id="73d583a1445e1497ec3adaa011e2724c" category="paragraph">在下一步中创建的 `TrdentBackendConfig` 对象的 `sPec.credentials` 字段将引用此步骤中创建的机密。</block>
  <block id="80a6c6a7044e3f06bb524f88ac2058f4" category="section-title">第 2 步：创建 TridentBackendConfig CR</block>
  <block id="3394622f88ed2c82c85e92e908879095" category="paragraph">现在，您可以创建 `TridentBackendConfig` CR 了。在此示例中，使用 `TriventBackendConfig` 对象创建使用` ontap-san `驱动程序的后端，如下所示：</block>
  <block id="b5a13f13012993635ae9e627f314bbb9" category="section-title">第 3 步：验证 TridentBackendConfig CR 的状态</block>
  <block id="967688089cfc07a6c8e893bce5186445" category="paragraph">现在，您已创建 `TridentBackendConfig` CR ，可以验证状态。请参见以下示例：</block>
  <block id="edc9d2e179d9bd8effd5277699967aff" category="paragraph">已成功创建后端并将其绑定到 `TridentBackendConfig` CR 。</block>
  <block id="ecb5320e6f020f2c2dcad7a6268111ed" category="paragraph">阶段可以采用以下值之一：</block>
  <block id="35ef366711dba4820492cd153e2bc30d" category="list-text">`bound` ： `TridentBackendConfig` CR 与后端关联，后端包含 `configRef` 设置为 `TridentBackendConfig` CR 的 UID 。</block>
  <block id="f2edf590deb30828e48e7290aa78e788" category="list-text">`Unbound` ：使用 ` ""` 表示。`TridentBackendConfig` 对象未绑定到后端。默认情况下，所有新创建的 `TridentBackendConfig` CRS 均处于此阶段。此阶段发生更改后，它将无法再次还原为 "Unbound （已取消绑定） " 。</block>
  <block id="895ba30a6f39f0691ad851fe26560431" category="list-text">`deleting` ： The `TridentBackendConfig` CR 's `deletionPolicy` was set to delete.删除 `TridentBackendConfig` CR 后，它将过渡到 Deleting 状态。</block>
  <block id="0550ab6955adf5805cf2d00b7c592718" category="list-text">如果后端不存在永久性卷请求（ PVC ），则删除 `TridentBackendConfig` 将导致 Astra Trident 删除后端以及 `TridentBackendConfig` CR 。</block>
  <block id="ffd02eb489e62222a00391567d0bad81" category="list-text">如果后端存在一个或多个 PVC ，则会进入删除状态。`TridentBackendConfig` CR 随后也会进入删除阶段。只有在删除所有 PVC 后，才会删除后端和 `TridentBackendConfig` 。</block>
  <block id="39d978e14d4d8c9f19589af0d4e72661" category="list-text">`Lost` ：与 `TridentBackendConfig` CR 关联的后端被意外或故意删除， `TridentBackendConfig` CR 仍引用已删除的后端。无论 `detionPolicy` 值如何，仍可删除 `TridentBackendConfig` CR 。</block>
  <block id="8375bdbfbc291bcedc60e7555e3dc43a" category="list-text">`未知` ： Astra Trident 无法确定与 `TridentBackendConfig` CR 关联的后端的状态或存在。例如，如果 API 服务器未响应或缺少 `tridentbackends.trident.netapp.io` CRD 。这可能需要用户干预。</block>
  <block id="fdf3d4560a801cb64c255cc2790fe9cc" category="inline-link-macro">后端更新和后端删除</block>
  <block id="57867491a75119ccf33f6ed8a434ff8e" category="paragraph">在此阶段，已成功创建后端！此外，还可以处理多个操作，例如 <block ref="9f5a7b55f1a44b55d5336cefd3bf688e" category="inline-link-macro-rx"></block>。</block>
  <block id="4dca0b80562cc590644c1acfada17219" category="section-title">（可选）第 4 步：获取更多详细信息</block>
  <block id="22f66c61dd35abb0ae1840a7e38ae1b9" category="paragraph">您可以运行以下命令来获取有关后端的详细信息：</block>
  <block id="aab3a73056ee2962dff0130da0538454" category="paragraph">此外，您还可以获取 YAML/JSON 转储 `TridentBackendConfig` 。</block>
  <block id="9fae9b8b2e8f0d5b91654165a5dacc1f" category="paragraph">`backendInfo` 包含为响应 `TridentBackendConfig` CR 而创建的后端的 `backendName` 和 `backendUUID` 。`lastOperationStatus` 字段表示 `TridentBackendConfig` CR 的上次操作状态，该操作可以是用户触发的（例如，用户在 `sPec` 中更改了某个内容），也可以是由 Astra Trident 触发的（例如，在 Astra Trident 重新启动期间）。可以是成功，也可以是失败。`phase` 表示 `TridentBackendConfig` CR 与后端之间关系的状态。在上面的示例中， `phase` 的值为 bound ，这意味着 `TridentBackendConfig` CR 与后端关联。</block>
  <block id="7b7587593fc7d381339d450faa35dfa9" category="paragraph">您可以运行 `kubectl -n trident describe tbc &lt;tbc-cr-name&gt;` 命令来获取事件日志的详细信息。</block>
  <block id="6dc07da7e54d697726bb349fb693fa8b" category="inline-link-macro">请参见此处</block>
  <block id="c732962a4a01ea5f406ec66e50e98903" category="admonition">您不能使用 `tridentctl` 更新或删除包含关联的 `TridentBackendConfig` 对象的后端。要了解在 `tridentctl` 和 `TridentBackendConfig` 之间切换所涉及的步骤， <block ref="8d6bc70a41f48e3f72c3f5ea8752090b" category="inline-link-macro-rx"></block>。</block>
  <block id="99c7791f20f0d41bd8f14c11e666a405" category="summary">通过将 Astra Trident 与适用于 NetApp ONTAP 的 Amazon FSx 结合使用，您可以确保在 Amazon Elastic Kubernetes Service （ EKS ）中运行的 Kubernetes 集群可以配置由 ONTAP 提供支持的块和文件永久性卷。</block>
  <block id="337de5d45c69b1e4dcf87a8e7ec9ff76" category="doc">将 Astra Trident 与适用于 NetApp ONTAP 的 Amazon FSX 结合使用</block>
  <block id="679e88f51c747ba6602cbc38cb32bff8" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block>是一种完全受管的 AWS 服务，支持客户启动和运行由 NetApp 的 ONTAP 存储操作系统提供支持的文件系统。Amazon FSX for NetApp ONTAP 支持您利用您熟悉的 NetApp 功能，性能和管理功能，同时利用在 AWS 上存储数据的简便性，灵活性，安全性和可扩展性。FSX 支持 ONTAP 的许多文件系统功能和管理 API 。</block>
  <block id="7eb620c879218a348ba0e9afaedf6b01" category="paragraph">文件系统是 Amazon FSX 中的主要资源，类似于内部部署的 ONTAP 集群。在每个 SVM 中，您可以创建一个或多个卷，这些卷是将文件和文件夹存储在文件系统中的数据容器。借助适用于 NetApp ONTAP 的 Amazon FSX ， Data ONTAP 将作为云中的托管文件系统提供。新的文件系统类型称为 * NetApp ONTAP * 。</block>
  <block id="98cbc4f3bec852897b19deb4e76af117" category="paragraph">通过将 Astra Trident 与适用于 NetApp ONTAP 的 Amazon FSx 结合使用，您可以确保在 Amazon Elastic Kubernetes Service （ EKS ）中运行的 Kubernetes 集群可以配置由 ONTAP 提供支持的块和文件永久性卷。</block>
  <block id="ff27e75635c1ff1e88fbc656b16e56ce" category="section-title">了解 Astra Trident</block>
  <block id="ac7bd35f3efc1fd44a6368cea5fa9c21" category="paragraph">如果您是 Astra Trident 的新用户，请使用下面提供的链接进行熟悉：</block>
  <block id="483a5da192f46e3cfe8391d3ef234fc4" category="inline-link-macro">常见问题解答</block>
  <block id="291df90d8802914b42223577bb41f627" category="list-text"><block ref="291df90d8802914b42223577bb41f627" category="inline-link-macro-rx"></block></block>
  <block id="d977410bdd2db39b51f9b9fbdbcc8061" category="inline-link-macro">使用 Astra Trident 的要求</block>
  <block id="4d644a71fe6f2b6c8e2bcc86d5aaed77" category="list-text"><block ref="4d644a71fe6f2b6c8e2bcc86d5aaed77" category="inline-link-macro-rx"></block></block>
  <block id="486632f7d2196e772b742db4a4a0ad7c" category="inline-link-macro">部署 Astra Trident</block>
  <block id="70638242b92c90c812dfa8f50f272806" category="list-text"><block ref="70638242b92c90c812dfa8f50f272806" category="inline-link-macro-rx"></block></block>
  <block id="bec2d42d896d0905cf546e4b5ca33b97" category="inline-link-macro">配置适用于 NetApp ONTAP 的 ONTAP ， Cloud Volumes ONTAP 和 Amazon FSX 的最佳实践</block>
  <block id="80a1961bd7058b357bb20148eaf24ec2" category="list-text"><block ref="80a1961bd7058b357bb20148eaf24ec2" category="inline-link-macro-rx"></block></block>
  <block id="80e431e9c3f38eb259dc9d255c8f4cf2" category="list-text"><block ref="80e431e9c3f38eb259dc9d255c8f4cf2" category="inline-link-macro-rx"></block></block>
  <block id="a479f33489c8d81410024a41c9544214" category="inline-link-macro">ONTAP SAN 后端配置</block>
  <block id="9b405a9aada0c758f606770edf5e729c" category="list-text"><block ref="9b405a9aada0c758f606770edf5e729c" category="inline-link-macro-rx"></block></block>
  <block id="3db2a44c712d8cff702c0fe05daddb2c" category="inline-link-macro">ONTAP NAS 后端配置</block>
  <block id="88cc0a1e56925a83682b7c1f999e281b" category="list-text"><block ref="88cc0a1e56925a83682b7c1f999e281b" category="inline-link-macro-rx"></block></block>
  <block id="0606b09e12901baae5719fde5a162beb" category="paragraph">详细了解驱动程序功能 <block ref="36417a02a2b8551d9a22837b23ac7abd" category="inline-link-macro-rx"></block>。</block>
  <block id="55449fd175613962d882ab450cfc5f3c" category="inline-link">FabricPool</block>
  <block id="d07e2d99267e4fc3c508f6701be977b4" category="paragraph">适用于 NetApp ONTAP 的 Amazon FSX 使用<block ref="d1584952da6bdedb0a24d5dbd43ce0bf" category="inline-link-rx"></block> 以管理存储层。通过它，您可以根据数据是否经常访问来将数据存储在层中。</block>
  <block id="0066f4a006b2b4f192583757b5f7a3c2" category="paragraph">Astra Trident 应以 ONTAP 或 SVM 管理员身份运行，使用集群 `fsxadmin` user 或 `vsadmin` SVM 用户，或者使用具有相同角色的其他名称的用户。`fsxadmin` 用户是对 `admin` cluster 用户的有限替代。对于非 Amazon FSX for ONTAP 部署， Astra Trident 通常使用 `admin` cluster 用户。</block>
  <block id="8e64a609e66214066595e6300aaab281" category="section-title">驱动程序</block>
  <block id="5979964b20770952072578428e9c11cb" category="paragraph">您可以使用以下驱动程序将 Astra Trident 与适用于 NetApp ONTAP 的 Amazon FSx 集成：</block>
  <block id="79a4618bb191cb293c330f8189531a13" category="list-text">`ontap-san` ：配置的每个 PV 都是其自己的 Amazon FSX for NetApp ONTAP 卷中的一个 LUN 。</block>
  <block id="b8f98ceeb9b158e8af3527fce91e9e57" category="list-text">`ontap-san-economi` ：为 NetApp ONTAP 卷配置的每个 PV 都是一个 LUN ，每个 Amazon FSX 具有可配置的 LUN 数量。</block>
  <block id="a5bc2c9e7628ac6c73838f9fea0e6ed6" category="list-text">`ONONTAP NAS` ：配置的每个 PV 都是适用于 NetApp ONTAP 的完整 Amazon FSX 卷。</block>
  <block id="94a834f420b7c21f3a1053e6dc705a31" category="list-text">`ontap-nas-economy.` ：配置的每个 PV 都是一个 qtree ，对于 NetApp ONTAP 卷，每个 Amazon FSx 的 qtree 数量是可配置的。</block>
  <block id="e42b07a9f050ef51ea1211004a50f223" category="list-text">`ontap-nas-flexgroup` ：配置的每个 PV 都是适用于 NetApp ONTAP FlexGroup 卷的完整 Amazon FSX 。</block>
  <block id="9dd7dc44e4a27c9a2c567d6b2a8b221a" category="paragraph">Astra Trident 提供两种身份验证模式：</block>
  <block id="5cefadbc856e5afd968e0dbf6f90ad85" category="list-text">基于凭据：您可以使用文件系统的 `fsxadmin` 用户或为 SVM 配置的 `vsadmin` 用户。建议使用 `vsadmin` 用户配置后端。Astra Trident 将使用此用户名和密码与 FSX 文件系统进行通信。</block>
  <block id="ed2536bee60113131cf25b2de3ec8734" category="list-text">基于证书： Astra Trident 将使用 SVM 上安装的证书与 FSX 文件系统上的 SVM 进行通信。</block>
  <block id="28e8b87c947c614dcb6e6f51703815e1" category="paragraph">要了解有关身份验证的详细信息，请参见以下链接：</block>
  <block id="619b69dca5d7c9f1f67ec55897733162" category="inline-link-macro">ONTAP NAS</block>
  <block id="b773e97e2ae2aebea91c33b771a98316" category="list-text"><block ref="b773e97e2ae2aebea91c33b771a98316" category="inline-link-macro-rx"></block></block>
  <block id="548fedaf4074fe2826e3c53dfd92a19e" category="inline-link-macro">ONTAP SAN</block>
  <block id="58ec862225833e810e6a7f94667d42db" category="list-text"><block ref="58ec862225833e810e6a7f94667d42db" category="inline-link-macro-rx"></block></block>
  <block id="9f6c198d85b31b573b56186f8ecc4394" category="section-title">使用适用于 NetApp ONTAP 的 Amazon FSX 在 EKS 上部署和配置 Astra Trident</block>
  <block id="80d13d3dbe137e8fb646193f275eceeb" category="list-text">已安装 `kubectl` 的现有 Amazon EKS 集群或自管理 Kubernetes 集群。</block>
  <block id="52d48fdd62aa109d7f163f0ef8a31b83" category="list-text">可从集群的工作节点访问的适用于 NetApp ONTAP 文件系统和 Storage Virtual Machine （ SVM ）的现有 Amazon FSX 。</block>
  <block id="ae9a35d29039db87d65a796241a9043d" category="inline-link-macro">NFS 和 / 或 iSCSI</block>
  <block id="26717a7ec67b264dcb09707406b962ef" category="list-text">为准备工作的工作节点 <block ref="b4b6a021fd40b8007c50db2baa5f32f0" category="inline-link-macro-rx"></block>。</block>
  <block id="fe914214000491758957f04647f8da36" category="inline-link">Amazon Machine 映像</block>
  <block id="b048d74c93505355f9535fd30cba1a60" category="admonition">确保按照 Amazon Linux 和 Ubuntu 所需的节点准备步骤进行操作<block ref="70013ee128d5437b3d9579d66ece4066" category="inline-link-rx"></block> （ AMIS ），具体取决于您的 EKS AMI 类型。</block>
  <block id="7b94315b87c307aaeb6180ba3d298112" category="paragraph">有关其他 Astra Trident 要求，请参见 <block ref="9754671a728b750cb0063ea36c5205bc" category="inline-link-macro-rx"></block>。</block>
  <block id="a63af3333b229a7d3d80f554369071d3" category="list-text">使用 ./trident 部署 Astra Trident 。 Get-started/Kubernetes 部署 .html[ 部署方法^ ] 之一部署 Astra Trident 。</block>
  <block id="064bdeb131b9f896a140c3620503f952" category="list-text">按照以下步骤配置 Astra Trident ：</block>
  <block id="0416f36f8f02433e530639fd76b0721d" category="list-text">收集 SVM 的管理 LIF DNS 名称。例如，通过使用 AWS 命令行界面，在运行以下命令后，在 `Endpoints` -&gt; `Management` 下找到 `DNSName` 条目：</block>
  <block id="d4eca488acc4ec18f87e7f00d23309cd" category="list-text">创建并安装用于身份验证的证书。如果您使用的是 `ontap-san` 后端，请参见 <block ref="db35e24c08f3bb29e6d31cbaa530e9d6" category="inline-link-macro-rx"></block>。如果您使用的是 `ontap-nas` 后端，请参见 <block ref="118a5731ca660935428e52a749b9e8a6" category="inline-link-macro-rx"></block>。</block>
  <block id="3e25473814d436a2ebac91120e147b0b" category="admonition">您可以从可以访问文件系统的任何位置使用 SSH 登录到文件系统（例如，安装证书）。使用 `fsxadmin` 用户，创建文件系统时配置的密码以及 `AWS FSx describe 文件系统` 中的管理 DNS 名称。</block>
  <block id="860958fe641e0edbd80fe522c36d0560" category="list-text">使用您的证书和管理 LIF 的 DNS 名称创建后端文件，如以下示例所示：</block>
  <block id="1584837635038d443115ce4eeb3b33e4" category="paragraph">有关创建后端的信息，请参见以下链接：</block>
  <block id="6f95a39ae3c518928ed5e4681a0fd49b" category="inline-link-macro">使用 ONTAP NAS 驱动程序配置后端</block>
  <block id="82744a46443ebff9011b85aa2468fdc2" category="list-text"><block ref="82744a46443ebff9011b85aa2468fdc2" category="inline-link-macro-rx"></block></block>
  <block id="d1e8ff43d93982813a74a45f9b721655" category="list-text"><block ref="d1e8ff43d93982813a74a45f9b721655" category="inline-link-macro-rx"></block></block>
  <block id="408cf26cdce3db57f4b0cfb372f60739" category="admonition">请勿为 `ontap-san` 和 `ontap-san-economy-` 驱动程序指定 `dataLIF` ，以允许 Astra Trident 使用多路径。</block>
  <block id="f15eb14cb9557fc6c608200b83965ea4" category="admonition">将适用于 NetApp ONTAP 的 Amazon FSx 与 Astra Trident 结合使用时， `limitAggregateUsage` 参数不适用于 `vsadmin` 和 `fsxadmin` 用户帐户。如果指定此参数，配置操作将失败。</block>
  <block id="d11f02b39cdb338286053b2f1315c6b4" category="inline-link-macro">存储类，配置卷以及将卷挂载到 Pod 中</block>
  <block id="95a5f873da165cd068ef3ec7e17364f3" category="paragraph">部署完成后，执行以下步骤以创建 <block ref="15bf5a6bf382a8a35f58cdae8ebe845c" category="inline-link-macro-rx"></block>。</block>
  <block id="cc788b7e72b2a734dd0985bd1e0e9fe3" category="inline-link">Amazon FSX for NetApp ONTAP 文档</block>
  <block id="fd570b75466e2daca21a032e6fd5981c" category="list-text"><block ref="fd570b75466e2daca21a032e6fd5981c" category="inline-link-rx"></block></block>
  <block id="0ef79cb4bb284d3ca9c3e95489919301" category="inline-link">有关适用于 NetApp ONTAP 的 Amazon FSX 的博客文章</block>
  <block id="3b94214fe5975bca8da92b72f8926be2" category="list-text"><block ref="3b94214fe5975bca8da92b72f8926be2" category="inline-link-rx"></block></block>
  <block id="8682abd0ce083533bad141869c96ab2a" category="summary">Astra Trident 提供了多种用于管理卷的功能。了解 Astra Trident 为卷提供的功能。</block>
  <block id="b42cbc6e68075c106b9faa27e4931091" category="doc">执行卷操作</block>
  <block id="eb487790322c4b8e9b4953d60be1acee" category="paragraph">了解 Astra Trident 为管理卷提供的功能。</block>
  <block id="3d4635d3cf4f27b0e87f3fe86a84744d" category="inline-link-macro">使用 CSI 拓扑</block>
  <block id="9e325272e7aed7c7bd6c28ff6fa4a90f" category="list-text"><block ref="9e325272e7aed7c7bd6c28ff6fa4a90f" category="inline-link-macro-rx"></block></block>
  <block id="e5879288a130fbd8d0b8682cfc375c4f" category="inline-link-macro">使用快照</block>
  <block id="c499fa59a1c9a0f6da195782a581f2e3" category="list-text"><block ref="c499fa59a1c9a0f6da195782a581f2e3" category="inline-link-macro-rx"></block></block>
  <block id="56661e701892ff873e44b62ffeec85e5" category="list-text"><block ref="56661e701892ff873e44b62ffeec85e5" category="inline-link-macro-rx"></block></block>
  <block id="c0417f5bbd54c5dc1c3704d6b566fcf3" category="list-text"><block ref="c0417f5bbd54c5dc1c3704d6b566fcf3" category="inline-link-macro-rx"></block></block>
  <block id="8b7b728c6a1e7accd6148646ba730e77" category="summary">了解如何在 Astra Trident 中管理后端。</block>
  <block id="4342473e01edd2e1440b8b76076f4c9e" category="doc">在后端管理选项之间移动</block>
  <block id="207aacc2f1990ce861bf20cfcd0ca067" category="paragraph">了解如何在 Astra Trident 中管理后端。随着 `TridentBackendConfig` 的推出，管理员现在可以通过两种独特的方式管理后端。这会提出以下问题：</block>
  <block id="a7b407f571446f9f4a30f63e8160784a" category="list-text">使用 `tridentctl` 创建的后端是否可以使用 `TridentBackendConfig` 进行管理？</block>
  <block id="3e1fc11d05c13404995af2b9fda64675" category="list-text">使用 `TridentBackendConfig` 创建的后端是否可以使用 `tridentctl` 进行管理？</block>
  <block id="41b338cd1cea5e2df168994a9bdedf75" category="section-title">使用 TridentBackendConfig 管理 tridentctl 后端</block>
  <block id="d6da18e16f248df47ee8e5139ef0156a" category="paragraph">本节介绍通过创建 `TridentBackendConfig` 对象直接通过 Kubernetes 界面管理使用 `tridentctl` 创建的后端所需的步骤。</block>
  <block id="bee2ae6068ad50344ddb325737434004" category="paragraph">这适用于以下情形：</block>
  <block id="e9c4de6d076377511c2b6a8463898ef2" category="list-text">预先存在的后端，没有 `TridentBackendConfig` ，因为它们是使用 `tridentctl` 创建的。</block>
  <block id="8eed1f3ae09f008e2dbfb4280a0c137c" category="list-text">使用 `tridentctl` 创建的新后端，而存在其他 `TridentBackendConfig` 对象。</block>
  <block id="0507a4f0ac746171a414097e7f033dca" category="paragraph">在这两种情况下，后端仍会存在，其中 Astra Trident 会计划卷并对其进行操作。管理员可以选择以下两种方式之一：</block>
  <block id="95328f21e7a6deb7bb94acb3866753a6" category="list-text">继续使用 `tridentctl` 管理使用它创建的后端。</block>
  <block id="82c1dd66573aab904c86b63e2d5486ad" category="list-text">使用 `tridentctl` 创建的后端绑定到新的 `TridentBackendConfig` 对象。这样做意味着将使用 `kubectl` 而不是 `tridentctl` 来管理后端。</block>
  <block id="d12d5022b29f44c340ee55411970fe10" category="paragraph">要使用 `kubectl` 管理已有后端，您需要创建一个绑定到现有后端的 `TridentBackendConfig` 。下面简要介绍了它的工作原理：</block>
  <block id="0637b40285532fa1b6c6a4548e63d2f4" category="list-text">创建 Kubernetes 机密。此密钥包含 Astra Trident 与存储集群 / 服务通信所需的凭据。</block>
  <block id="b863de09ccfaf2861ead350dd78a9933" category="list-text">创建 `TridentBackendConfig` 对象。其中包含有关存储集群 / 服务的详细信息，并引用了上一步中创建的密钥。必须注意指定相同的配置参数（例如 `sPec.backendName` ， `sPec.storagePrefix` ， `sPec.storageDriverName` 等）。`sPec.backendName` 必须设置为现有后端的名称。</block>
  <block id="44411eb1f3a70196b442f0ed4bb62820" category="section-title">第 0 步：确定后端</block>
  <block id="c400920d4e58cf882999474fbdf967d3" category="paragraph">要创建绑定到现有后端的 `TridentBackendConfig` ，您需要获取后端的配置。在此示例中，假设已使用以下 JSON 定义创建了后端：</block>
  <block id="2181a22b3daf7866094f9f0d79da87d0" category="paragraph">创建一个包含后端凭据的机密，如以下示例所示：</block>
  <block id="c030a8fb45dd1e59dbe723d93fefa8b4" category="section-title">第 2 步：创建 TridentBackendConfig CR</block>
  <block id="276e25c1cf06c603ba2d133ae2e39dde" category="paragraph">下一步是创建一个 `TridentBackendConfig` CR ，该 CR 将自动绑定到已有的 `ontap-nas-backend` （如本示例所示）。确保满足以下要求：</block>
  <block id="0cbfd18f16db9afdef577eeddd6a8bee" category="list-text">在 `sPec.backendName` 中定义了相同的后端名称。</block>
  <block id="f261e4f2fe82344f35f04f9b3813e425" category="list-text">配置参数与原始后端相同。</block>
  <block id="12bf8ac3a10fbfae1244c8505d9aa91a" category="list-text">虚拟存储池（如果存在）必须与原始后端保持相同的顺序。</block>
  <block id="8f50f98a5b56105263e2f7ab18dc0686" category="list-text">凭据通过 Kubernetes Secret 提供，而不是以纯文本形式提供。</block>
  <block id="05c8cd2e49ae2ecaee101c9bc5619d49" category="paragraph">在这种情况下， `TridentBackendConfig` 将如下所示：</block>
  <block id="63d6f3ce15066b6232a788bb692bf721" category="paragraph">创建 `TridentBackendConfig` 后，其阶段必须为 `bound` 。它还应反映与现有后端相同的后端名称和 UUID 。</block>
  <block id="d1a75f7c76623350486029378ab164c3" category="paragraph">现在，可以使用 `tbc-ontap-nas-backend` `TridentBackendConfig` 对象对后端进行全面管理。</block>
  <block id="fe1ffe29ba93d2779f921228fcba083e" category="section-title">使用 tridentctl 管理 TridentBackendConfig 后端</block>
  <block id="fcea92f3e948217919ca8b4051c2c61e" category="paragraph">`tridentctl` 可用于列出使用 `TridentBackendConfig` 创建的后端。此外，管理员还可以选择通过 `tridentctl` 来完全管理此类后端，方法是删除 `TridentBackendConfig` 并确保将 `spec.deletionPolicy` 设置为 `retain` 。</block>
  <block id="ab0c73d8e0377b2df5b783d3a76f2249" category="paragraph">例如，假设使用 `TridentBackendConfig` 创建了以下后端：</block>
  <block id="9874d325a018b14fb52adf25f612579e" category="paragraph">从输出中可以看到 `TridentBackendConfig` 已成功创建并绑定到后端【观察后端的 UUUID] 。</block>
  <block id="416d2581db02ba9bc1187cf17c86a1c4" category="section-title">第 1 步：确认 deletionPolicy 设置为 Retain</block>
  <block id="ea64db0654e81907c68ffc52d023c3c7" category="paragraph">让我们来看看 `deletionPolicy` 的价值。需要将此值设置为 `retain` 。这样可以确保删除 `TridentBackendConfig` CR 时，后端定义仍存在，并可使用 `tridentctl` 进行管理。</block>
  <block id="1ad97e0f65ef91102831baaa31630c76" category="admonition">请勿继续执行下一步，除非将 `deletionPolicy` 设置为 `retain` 。</block>
  <block id="e66283ad5a3e477773a4c58ea53d800f" category="section-title">第 2 步：删除 TridentBackendConfig CR</block>
  <block id="8313f77478cb0df464604ae4435acce2" category="paragraph">最后一步是删除 `TridentBackendConfig` CR 。确认 `deeltionPolicy` 设置为 `retain` 后，您可以继续执行删除：</block>
  <block id="c1493b6d6e05639a816e5772bbb491af" category="paragraph">删除 `TridentBackendConfig` 对象后， Astra Trident 只需删除该对象，而无需实际删除后端本身。</block>
  <block id="72a5926b7fb086fe87e93771f6620556" category="summary">了解如何使用 `tridentctl` 执行后端管理操作。</block>
  <block id="aeeb03235358f0f4bf3be628bed08721" category="section-title">创建后端</block>
  <block id="34746f7a1d24170eeebf5510a045d43d" category="inline-link-macro">后端配置文件</block>
  <block id="99b7232073a67a8c82304f979e3dc83f" category="paragraph">创建后 <block ref="03c0b6ed8698193668e92f56e9be3efa" category="inline-link-macro-rx"></block>下，运行以下命令：</block>
  <block id="1cabe44c722167581b1e219de6c58341" category="paragraph">如果后端创建失败，则后端配置出现问题。您可以运行以下命令来查看日志以确定发生原因：</block>
  <block id="b5f9999463782f0c36ecc89573a90a49" category="paragraph">确定并更正配置文件中的问题后，您只需再次运行 `create` 命令即可。</block>
  <block id="634b471e6af84767e06324552492b533" category="section-title">删除后端</block>
  <block id="412228c370a388e25ee06e8ad7a1da3f" category="paragraph">要从 Astra Trident 中删除后端，请执行以下操作：</block>
  <block id="f6816a6570e6b6097177f9adc1f4805b" category="list-text">检索后端名称：</block>
  <block id="11f4ccb46eb9afc4b1187c376b53123f" category="list-text">删除后端：</block>
  <block id="c87f53b53d179c2b5dcd5fad1efba831" category="admonition">如果 Astra Trident 从此后端配置了仍存在的卷和快照，则删除后端将阻止其配置新卷。后端将继续处于 " 删除 " 状态，而 Trident 将继续管理这些卷和快照，直到将其删除为止。</block>
  <block id="d694c8966214ec6d0068c0ab2951b65c" category="section-title">查看现有后端</block>
  <block id="a6345aca446812b9124c47b385b33f43" category="paragraph">要查看 Trident 了解的后端，请执行以下操作：</block>
  <block id="cb325bc4dded2aa4744b594966262a99" category="list-text">要获取摘要，请运行以下命令：</block>
  <block id="9f073deeee70a1418443c3b8379c5c02" category="list-text">要获取所有详细信息，请运行以下命令：</block>
  <block id="93dbcf0189ff94d39230d2e3726969ab" category="section-title">更新后端</block>
  <block id="27709162cf6b8ffced7bb1da6dd49df3" category="paragraph">创建新的后端配置文件后，运行以下命令：</block>
  <block id="4ca005817e9c882d0ef15d451a97dbf0" category="paragraph">如果后端更新失败，则后端配置出现问题或您尝试的更新无效。您可以运行以下命令来查看日志以确定发生原因：</block>
  <block id="20b5ebaa2558437206eb6d1d47577805" category="paragraph">确定并更正配置文件中的问题后，您只需再次运行 `update` 命令即可。</block>
  <block id="d47f84a3cda326babf841866ad2326ab" category="section-title">确定使用后端的存储类</block>
  <block id="02fe9d429af25b46c16a1172d735124f" category="paragraph">以下是您可以使用问题解答与 JSON 回答的问题的示例，这些问题会 `tridentctl` 后端对象的输出。此操作将使用 `JQ` 实用程序，您需要安装该实用程序。</block>
  <block id="e00013adda7b5901ea3e44ae300fd73d" category="paragraph">这也适用于使用 `TridentBackendConfig` 创建的后端。</block>
  <block id="bc960ce53bb0d62c44b5a3f212c279d3" category="summary">您可以创建存储类，删除存储类以及查看现有存储类。</block>
  <block id="e8b9c3a9859a62e9a58431c3b61f75d5" category="doc">管理存储类</block>
  <block id="5802c976ee5f858f76699af5294812e6" category="paragraph">查找有关创建存储类，删除存储类以及查看现有存储类的信息。</block>
  <block id="e123173acd76721f31496874fd778eca" category="section-title">设计存储类</block>
  <block id="a9a4b52c93b141ba28676afe58a5900d" category="paragraph">请参见 <block ref="5a81d2db77288939223c6a591fc3991d" category="inline-link-macro-rx"></block> 有关什么是存储类以及如何配置这些类的详细信息，请参见。</block>
  <block id="14f4c7abe09c4481722f1fa6563f2604" category="section-title">创建存储类。</block>
  <block id="99b068c418b4a658f64806517e8567ac" category="paragraph">创建存储类文件后，运行以下命令：</block>
  <block id="fac03ff7d61c420a4caeeb44355cb2be" category="paragraph">` &lt;storage-class-file&gt;` 应替换为存储类文件名。</block>
  <block id="0fe0aa7b9b7529f66030afb1629507bb" category="section-title">删除存储类</block>
  <block id="4bf50148821c75f616a96daca9255e6f" category="paragraph">要从 Kubernetes 中删除存储类，请运行以下命令：</block>
  <block id="65494a0b3404ce637afd88bcb7c82998" category="paragraph">` &lt; 存储类 &gt;` 应替换为您的存储类。</block>
  <block id="a5f526f5d63d827ce2c0146a20cd2ff7" category="paragraph">通过此存储类创建的任何永久性卷将保持不变， Astra Trident 将继续对其进行管理。</block>
  <block id="1ffda19a93d453b434cfabeb86681d6d" category="admonition">Astra Trident 会为其创建的卷强制使用空的 `FSType` 。对于 iSCSI 后端，建议在 StorageClass 中强制实施 `parameters.FSType` 。您应删除现有 StorageClasses 并使用指定的 `parameters.FSType` 重新创建它们。</block>
  <block id="e606165355271961ba07945766fbf83a" category="section-title">查看现有存储类</block>
  <block id="7c237bc6c124137d25df2dec1cb3e528" category="list-text">要查看现有 Kubernetes 存储类，请运行以下命令：</block>
  <block id="4aae22fbb9c0d354d0a9c15c6c126d89" category="list-text">要查看 Kubernetes 存储类详细信息，请运行以下命令：</block>
  <block id="bed443a9c5577e1043c277e8ebbb542f" category="list-text">要查看 Astra Trident 的同步存储类，请运行以下命令：</block>
  <block id="db66cf4d314ab7a719a76ed3af1b0173" category="list-text">要查看 Astra Trident 的同步存储类详细信息，请运行以下命令：</block>
  <block id="ce32eb748bd7452bd6ee6d1d7ad6d3a7" category="section-title">设置默认存储类</block>
  <block id="f30a1542c01c3c493f3c01c88dfe5fcd" category="paragraph">Kubernetes 1.6 增加了设置默认存储类的功能。如果用户未在永久性卷声明（ PVC ）中指定永久性卷，则此存储类将用于配置永久性卷。</block>
  <block id="7c435ae4763642458286cb691812ea55" category="list-text">通过在存储类定义中将标注 `storageclass.Kubernetes 。 io/is-default-class` 设置为 true 来定义默认存储类。根据规范，任何其他值或标注不存在均视为 false 。</block>
  <block id="61fd76f55d29aaceb4a6ee09a318dc45" category="list-text">您可以使用以下命令将现有存储类配置为默认存储类：</block>
  <block id="800477137444bec636483de85335cbb5" category="list-text">同样，您也可以使用以下命令删除默认存储类标注：</block>
  <block id="2d2f31c3012657fd7b38b41312d1a0b8" category="paragraph">Trident 安装程序包中也有包含此标注的示例。</block>
  <block id="94d8ac3a8d98f2232d3dc735878a5bc3" category="admonition">在任何给定时间，集群中只能有一个默认存储类。Kubernetes 在技术上不会阻止您拥有多个存储类，但其行为就像根本没有默认存储类一样。</block>
  <block id="6c36cb9c072dc4cb9e163c44568f6a91" category="section-title">确定存储类的后端</block>
  <block id="dc0742ede78913414129866d60898f67" category="paragraph">以下是您可以使用问题解答与 JSON 一起为 Astra Trident 后端对象输出的 `tridentctl` 类问题的示例。此操作将使用 `JQ` 实用程序，您可能需要先安装该实用程序。</block>
  <block id="08c4bc4ac4edd9b12963c0596478d746" category="summary">通过使用 CSI 拓扑功能， Astra Trident 可以有选择地创建卷并将其附加到 Kubernetes 集群中的节点。</block>
  <block id="4abea6bac3b0b48d11dd8dcd02a11bf9" category="inline-link">CSI 拓扑功能</block>
  <block id="d8af5701dd1ffedb08b7db3f7efcd86b" category="paragraph">Astra Trident 可以通过使用有选择地创建卷并将其附加到 Kubernetes 集群中的节点<block ref="80b9a4f4a1bc9851317207ee3477041a" category="inline-link-rx"></block>。使用 CSI 拓扑功能，可以根据区域和可用性区域将对卷的访问限制为一小部分节点。如今，借助云提供商， Kubernetes 管理员可以生成基于分区的节点。节点可以位于可用性区域内的不同区域，也可以位于不同可用性区域之间。为了便于在多区域架构中为工作负载配置卷， Astra Trident 使用了 CSI 拓扑。</block>
  <block id="592af423a2f6a51f57c639ec7f7b245e" category="admonition">了解有关 CSI 拓扑功能的更多信息<block ref="ff042e7f24bd2adcec09d78466034177" category="inline-link-rx"></block>。</block>
  <block id="bbdcaf9b704dc7a7cf73e6000101b65a" category="paragraph">Kubernetes 提供了两种唯一的卷绑定模式：</block>
  <block id="93590d63acbb4fa6864a4665157fbcea" category="list-text">如果将 `VolumeBindingMode` 设置为 `immediate` ，则 Astra Trident 将创建卷，而不会感知任何拓扑。创建 PVC 时会处理卷绑定和动态配置。这是默认值 `VolumeBindingMode` ，适用于不强制实施拓扑约束的集群。创建永久性卷时，不会依赖于请求的 Pod 的计划要求。</block>
  <block id="5fca24470d51aa51b0fb2d0f27c25c68" category="list-text">如果将 `VolumeBindingMode` 设置为 `WaitForFirstConsuming` ，则为 PVC 创建和绑定永久性卷的操作将延迟，直到计划并创建使用 PVC 的 Pod 为止。这样，卷就会根据拓扑要求强制实施的计划限制来创建。</block>
  <block id="3bbc2da928dcf77a048cdd745fe7d208" category="admonition">`WaitForFirstConsumer"` 绑定模式不需要拓扑标签。此功能可独立于 CSI 拓扑功能使用。</block>
  <block id="edff21c44983aaa85506a3dfe467c494" category="paragraph">要使用 CSI 拓扑，您需要满足以下条件：</block>
  <block id="6127fe8ac0294f905386b8e26b9a62a3" category="list-text">运行 1.17 或更高版本的 Kubernetes 集群。</block>
  <block id="f9213d77978aabdafac36d2b0a184e56" category="list-text">集群中的节点应具有可引入拓扑感知的标签（`topology.Kubernetes IO/ 区域` 和 `topology.Kubernetes IO/ 区域` ）。在安装 Astra Trident 之前，集群中的节点上应存在这些标签 * ，以使 Astra Trident 能够识别拓扑。</block>
  <block id="0bd58c9826639ac2db106c3b277a7e0f" category="section-title">第 1 步：创建可感知拓扑的后端</block>
  <block id="c7d3751a47274aaa616d77a14f2e2722" category="paragraph">可以设计 Astra Trident 存储后端，以便根据可用性区域有选择地配置卷。每个后端都可以包含一个可选的 `supportedTopatis` 块，该块表示必须支持的分区和区域的列表。对于使用此后端的 StorageClasses ，只有在受支持区域 / 区域中计划的应用程序请求时，才会创建卷。</block>
  <block id="168d311a918475a654f296f89a7da983" category="paragraph">下面是后端定义示例：</block>
  <block id="3e778236fe8f94ccc453f52d827e3719" category="admonition">`supportedTopologies` 用于提供每个后端的区域和分区列表。这些区域和分区表示可在 StorageClass 中提供的允许值列表。对于包含后端提供的部分区域和分区的 StorageClasses ， Astra Trident 将在后端创建卷。</block>
  <block id="217d95247b26701da7fd823884d84723" category="paragraph">您也可以为每个存储池定义 `supportedTopologies` 。请参见以下示例：</block>
  <block id="c6c80256ac468b3d88d7b62d8753f192" category="paragraph">在此示例中， `reGion` 和 `zone` 标签表示存储池的位置。`topology.Kubernees.io/zone` 和 `topology.Kubernees.io/zone` 指定存储池的使用位置。</block>
  <block id="54e204e8e05b6eb24d965741eb977e69" category="section-title">第 2 步：定义可识别拓扑的 StorageClasses</block>
  <block id="090f70d385b4a21aa6c8f2a0ca558616" category="paragraph">根据为集群中的节点提供的拓扑标签，可以将 StorageClasses 定义为包含拓扑信息。这将确定用作 PVC 请求候选对象的存储池，以及可使用 Trident 配置的卷的节点子集。</block>
  <block id="ecb383148a1bc974cba3ac735a79f4c6" category="paragraph">请参见以下示例：</block>
  <block id="ab0c7ec9411ede93aa545fbc095c0e75" category="paragraph">在上述 StorageClass 定义中， `volumeBindingMode` 设置为 `WaitForFirstConsumer"` 。在此存储类中请求的 PVC 在 Pod 中引用之前不会执行操作。此外， `allowedTopologies` 还提供了要使用的分区和区域。`NetApp-san-us-East1` StorageClass 将在上述 `san-backend-us-East1` 后端创建 PVC 。</block>
  <block id="df340fb31051c975afb3518dfd32e07c" category="section-title">第 3 步：创建和使用 PVC</block>
  <block id="f98be29d352e7c38a6502e76bbfaf34c" category="paragraph">创建 StorageClass 并将其映射到后端后，您现在可以创建 PVC 。</block>
  <block id="c4b17c8733f9f36fdc682242d2b64ab2" category="paragraph">请参见以下示例 `sPec` ：</block>
  <block id="427e01a8fca484c85a1e8e3a672b999a" category="paragraph">使用此清单创建 PVC 将导致以下结果：</block>
  <block id="e65f170821e3417d48579a28989a9260" category="paragraph">要使 Trident 创建卷并将其绑定到 PVC ，请在 Pod 中使用 PVC 。请参见以下示例：</block>
  <block id="9b8ff27bceb4601d1f866c4cf39fe449" category="paragraph">此 podSpec 指示 Kubernetes 在 `us-East1` 区域中的节点上计划 Pod ，并从 `us-East1-a` 或 `us-East1-b` 区域中的任何节点中进行选择。</block>
  <block id="c93345596f9f82deea04d17ef8c6ca89" category="paragraph">请参见以下输出：</block>
  <block id="0be3f6c5ce787eead27ad72578c2d31a" category="section-title">更新后端以包括支持的拓扑</block>
  <block id="476950aea923438779c9544953093cb9" category="paragraph">可以使用 `tridentctl backend update` 更新原有后端，以包含 `supportedTopologies` 列表。这不会影响已配置的卷，并且仅用于后续的 PVC 。</block>
  <block id="ded10f93b9e4453980b7009035c63418" category="inline-link">管理容器的资源</block>
  <block id="47ea3356a13b3f6644e6c05450e9d5e1" category="list-text"><block ref="47ea3356a13b3f6644e6c05450e9d5e1" category="inline-link-rx"></block></block>
  <block id="6370f866cf64618c026027da41bd248e" category="inline-link">节点选择器</block>
  <block id="2a4ad9fc807789134426a1b2babc5733" category="list-text"><block ref="2a4ad9fc807789134426a1b2babc5733" category="inline-link-rx"></block></block>
  <block id="873bf2b9b61a741ce5b7326a3a053489" category="inline-link">关联性和反关联性</block>
  <block id="ec5df0a2adb621359563958138462e34" category="list-text"><block ref="ec5df0a2adb621359563958138462e34" category="inline-link-rx"></block></block>
  <block id="e1e08e40036f927a0e660c22aa837f88" category="inline-link">损害和公差</block>
  <block id="66b1e0aa9cd6e46c0b85fdf56a15154a" category="list-text"><block ref="66b1e0aa9cd6e46c0b85fdf56a15154a" category="inline-link-rx"></block></block>
  <block id="2941c38dbb7c39c325787067c0540247" category="summary">了解如何使用 `kubectl` 执行后端管理操作。</block>
  <block id="20309eb77b701e6c49ca6b99a8f93f90" category="paragraph">通过删除 `TridentBackendConfig` ，您可以指示 Astra Trident 删除 / 保留后端（基于 `detionPolicy` ）。要删除后端，请确保将 `deletionPolicy` 设置为 delete 。要仅删除 `TridentBackendConfig` ，请确保将 `deletionPolicy` 设置为 Retain 。这样可以确保后端仍然存在，并可使用 `tridentctl` 进行管理。</block>
  <block id="3fa37f688874143cd423aabca8075ffb" category="paragraph">Astra Trident 不会删除 `TridentBackendConfig` 使用的 Kubernetes 机密。Kubernetes 用户负责清理密钥。删除机密时必须小心。只有在后端未使用机密时，才应将其删除。</block>
  <block id="265ab4809f08d248e5045a8638ac7afa" category="paragraph">您也可以运行 `tridentctl get backend -n trident` 或 `tridentctl get backend -o YAML -n trident` 来获取存在的所有后端的列表。此列表还将包括使用 `tridentctl` 创建的后端。</block>
  <block id="93700a3ea9dc6d858638cd66cd2f2bfa" category="paragraph">更新后端可能有多种原因：</block>
  <block id="56cdd71a65518838d73e00276ed6fab1" category="list-text">存储系统的凭据已更改。要更新凭据，必须更新 `TridentBackendConfig` 对象中使用的 Kubernetes Secret 。Astra Trident 将使用提供的最新凭据自动更新后端。运行以下命令以更新 Kubernetes Secret ：</block>
  <block id="6ef0ccb954a07e30d4ff894b5256ae30" category="list-text">需要更新参数（例如所使用的 ONTAP SVM 的名称）。在这种情况下，可以直接通过 Kubernetes 更新 `TridentBackendConfig` 对象。</block>
  <block id="d4609cbe039ed7019e7151718c417bec" category="paragraph">或者，也可以运行以下命令来更改现有的 `TridentBackendConfig` CR ：</block>
  <block id="d38f034e9aa082af3ec19c23caff4b0f" category="paragraph">如果后端更新失败，则后端仍会保持在其上次已知配置中。您可以通过运行 `kubectl get tbc &lt;tbc-name&gt; -o yaml -n trident` 或 `kubectl describe tbc &lt;tbc-name&gt; -n trident` 来查看日志以确定发生原因。</block>
  <block id="5878b59fb3a8430928026b63b5ca336f" category="paragraph">确定并更正配置文件中的问题后，您可以重新运行 update 命令。</block>
  <block id="bee1e2306bc7054ee443dc651eae90de" category="summary">Astra Trident 提供了一组 Prometheus 指标端点，您可以使用这些端点监控 Astra Trident 的性能。</block>
  <block id="44a004cad6eb7ea8839aaa8754ead178" category="doc">监控 Astra Trident</block>
  <block id="3f8e7343fbab71427901476dc4eb0cf3" category="paragraph">Astra Trident 提供了一组 Prometheus 指标端点，您可以使用这些端点监控 Astra Trident 的性能。</block>
  <block id="c827f266cf12e05adc1fe95215415abf" category="paragraph">通过 Astra Trident 提供的指标，您可以执行以下操作：</block>
  <block id="6111d709595b0a106ff313a249eb9d92" category="list-text">保留有关 Astra Trident 运行状况和配置的选项卡。您可以检查操作的成功程度以及它是否能够按预期与后端进行通信。</block>
  <block id="64dbac0ca36d9b1f6a8cf1e8a0123261" category="list-text">检查后端使用情况信息，并了解在后端配置的卷数量以及占用的空间量等。</block>
  <block id="7f6516030964b624d9c71fd9ec7f83dd" category="list-text">维护可用后端配置的卷数量的映射关系。</block>
  <block id="e436794bccbe602731bbde7766c1fa49" category="list-text">跟踪性能。您可以了解 Astra Trident 与后端通信并执行操作所需的时间。</block>
  <block id="efe0d75090a22534acabc936f8669994" category="admonition">默认情况下， Trident 的指标会显示在 `/metrics` 端点的目标端口` 8001 ` 上。安装 Trident 时，这些指标默认为 * 已启用 * 。</block>
  <block id="1ed994b9754ad078cfc46aaf3dbf3a5d" category="list-text">安装了 Astra Trident 的 Kubernetes 集群。</block>
  <block id="eb8bfd69bb88378a6f4d987811890ce6" category="inline-link">容器化 Prometheus 部署</block>
  <block id="42ae2e91a939ffa9bbda53c10bf5f89f" category="inline-link">原生应用程序</block>
  <block id="050899631250104f17d24b27cc8a12e5" category="list-text">一个 Prometheus 实例。可以是<block ref="bd5b9e4bd7b88b90afb221fb760a777c" category="inline-link-rx"></block> 或者，您也可以选择将 Prometheus 作为运行<block ref="3f1d5beaea78c0fd8cb397fbeb1c88bd" category="inline-link-rx"></block>。</block>
  <block id="68276ca40dfbfd36de911402152fa452" category="section-title">第 1 步：定义 Prometheus 目标</block>
  <block id="84c49e3c77b51ea186020145ae78103f" category="paragraph">您应定义一个 Prometheus 目标以收集指标并获取有关后端 Astra Trident 管理的信息，它创建的卷等。这<block ref="dc7964965bf1b3af43b28caf6231e550" category="inline-link-rx"></block> 介绍如何将 Prometheus 和 Grafana 与 Astra Trident 结合使用来检索指标。博客介绍了如何在 Kubernetes 集群中以操作员身份运行 Prometheus ，以及如何创建 ServiceMonitor 来获取 Astra Trident 的指标。</block>
  <block id="c33638e0de87536b08eeb94264671d0f" category="section-title">第 2 步：创建 Prometheus ServiceMonitor</block>
  <block id="81a21a88b42cd5c83d149a080a627bad" category="paragraph">要使用 Trident 指标，您应创建一个 Prometheus ServiceMonitor ，该监控器可监控 `trident CSI` 服务并侦听 `mtrigics` 端口。示例 ServiceMonitor 如下所示：</block>
  <block id="bfc1ad0fa725ea87ea056b2f2e8b6fe8" category="paragraph">此 ServiceMonitor 定义会检索 `trident CSI` 服务返回的指标，并专门查找服务的 `mtrics` 端点。因此， Prometheus 现在已配置为了解 Astra Trident 的指标。</block>
  <block id="07338294bd70ea1e7710a574d7c8e2ce" category="paragraph">除了直接从 Astra Trident 获得的指标之外， kubelet 还通过自己的指标端点公开了许多 `kubelet_volume_*` 指标。Kubelet 可以提供有关已连接的卷， Pod 及其处理的其他内部操作的信息。请参见<block ref="3f1f0977d0df3e8b343e403140284021" category="inline-link-rx"></block>。</block>
  <block id="1db2022a8a8de5d612eda8e3be0e1065" category="section-title">第 3 步：使用 PromQL 查询 Trident 指标</block>
  <block id="f5142e19a3b1edf809fce9d3b6aefc05" category="paragraph">PromQL 非常适合创建返回时间序列或表格数据的表达式。</block>
  <block id="8c6fb1be2521fd16337c11c626672678" category="paragraph">您可以使用以下 PromQL 查询：</block>
  <block id="b214fd0009b3929347f097bd843f0bfd" category="section-title">获取 Trident 运行状况信息</block>
  <block id="69fc54b5fac064131422d41948eb77ed" category="list-text">来自 Astra Trident 的 HTTP 2XX 响应的百分比</block>
  <block id="f43362a8efc950ece8c14d4e5faddfa4" category="list-text">通过状态代码来自 Astra Trident 的 REST 响应的百分比</block>
  <block id="e69d9a06025140f38adabb6f709f6e5b" category="list-text">* 由 Astra Trident 执行的操作的平均持续时间（毫秒） *</block>
  <block id="0505e17dec1e849391ad96f558fa613a" category="section-title">获取 Astra Trident 使用信息</block>
  <block id="f160a52d617adf6e6c5d379a9b8bca89" category="list-text">卷大小 * 平均值 *</block>
  <block id="eb978bfe01ec0c72ad231f3953e304a2" category="list-text">* 每个后端配置的卷总空间 *</block>
  <block id="5f735ae12eafbe476178928f4645475b" category="section-title">获取单个卷的使用情况</block>
  <block id="ee0898e9f0caa503f3eaa39c919f4c53" category="admonition">只有在同时收集 kubelet 指标时，才会启用此功能。</block>
  <block id="0bc301d2423b2ffaa38a5e275e4ec6f9" category="list-text">* 每个卷的已用空间百分比 *</block>
  <block id="8516d75df966e595bd1b5491acd01515" category="section-title">了解有关 Astra Trident AutoSupport 遥测的信息</block>
  <block id="6f4ddec0f501988d2b0315a77c87eeaa" category="paragraph">默认情况下， Astra Trident 会按每日节奏向 NetApp 发送 Prometheus 指标和基本后端信息。</block>
  <block id="5276683815b670b0addfb8c8a45bbb41" category="list-text">要阻止 Astra Trident 向 NetApp 发送 Prometheus 指标和基本后端信息，请在 Astra Trident 安装期间传递 ` -silning-autosupport` 标志。</block>
  <block id="ca0f9a86ca33f1d6baa9051bd7f4ed21" category="inline-link">隐私政策</block>
  <block id="5b58783cbe6d85941bac008d83d3f5c8" category="list-text">Astra Trident 还可以通过 `tridentctl send AutoSupport` 按需将容器日志发送到 NetApp 支持部门。您需要触发 Astra Trident 以上传其日志。在提交日志之前，您应接受 NetApp 的<block ref="91b6c0438017ba5fa21c286a96d5acb4" category="inline-link-rx"></block>。</block>
  <block id="63b95d84cf55d169b2592f3ac621055f" category="list-text">除非另有说明，否则 Astra Trident 会从过去 24 小时提取日志。</block>
  <block id="5224919a4ae5ccf610fb0ee74e4e7a94" category="inline-link">Trident AutoSupport</block>
  <block id="18bc3bf6223e289af8243b039cd8d702" category="list-text">您可以使用 ` -since` 标志指定日志保留时间范围。例如： `tridentctl send AutoSupport -sase=1h` 。此信息通过与 Astra Trident 一起安装的 `trident — autosupport` 容器进行收集和发送。您可以从获取容器映像<block ref="1b00454f0ab35dcec2ee1a0061efc6e5" category="inline-link-rx"></block>。</block>
  <block id="53084cad3d11df800502598c11e2d10b" category="inline-link">EULA</block>
  <block id="b9a52e8d1e9b14b8825c6ea01c0ce6d6" category="list-text">Trident AutoSupport 不会收集或传输个人身份信息（ PiII ）或个人信息。它附带了<block ref="173a360b412944768c2ab13e6c8fd1c7" category="inline-link-rx"></block> 这不适用于 Trident 容器映像本身。您可以详细了解 NetApp 对数据安全和信任的承诺<block ref="8470ff535916bda3f4ea4723647a7135" category="inline-link-rx"></block>。</block>
  <block id="89f0f2832f60f480805faf638848c5b7" category="paragraph">Astra Trident 发送的有效负载示例如下：</block>
  <block id="d2ec86f126f845e79aff07e70bf89472" category="list-text">AutoSupport 消息将发送到 NetApp 的 AutoSupport 端点。如果使用私有注册表存储容器映像，则可以使用 ` -image-regRegistry` 标志。</block>
  <block id="86c5a11fba83815412aec79f67f2d276" category="list-text">您也可以通过生成安装 YAML 文件来配置代理 URL 。为此，可以使用 `tridentctl install -generate-custom-yaml` 创建 YAML 文件，并在 `trident dedeployment.yaml` 中为 `trident autosupport` 容器添加 ` -proxy-url` 参数。</block>
  <block id="46ab735110312d196d5265e534453cba" category="section-title">禁用 Astra Trident 指标</block>
  <block id="8ec47dab227d183e0d3ad0cd529d289b" category="paragraph">要 ` 报告指标，您应生成自定义 YAML （使用` -generate-custom-yaml ` 标志）并对其进行编辑，以删除为 `trident 主` 容器调用的` -metrics 标志。</block>
  <block id="3f82682ace484ae8a94f6b713a856a1f" category="summary">了解如何使用提供的示例配置将 Azure NetApp Files 配置为 Trident 安装的后端。</block>
  <block id="28b0abcecaf7a63edb46e4e137337018" category="doc">配置 Azure NetApp Files 后端</block>
  <block id="f972fcadaebc8b30143815ae86f44966" category="paragraph">了解如何使用提供的示例配置将 Azure NetApp Files （ ANF ）配置为 Astra Trident 安装的后端。</block>
  <block id="573fa5dc2f7f8efb65f65f94f56fb8ea" category="admonition">Azure NetApp Files 服务不支持小于 100 GB 的卷。如果请求的卷较小，则 Astra Trident 会自动创建 100 GB 的卷。</block>
  <block id="07e7004c50a67a3e4e366b4ca1c28e3d" category="paragraph">配置和使用<block ref="24a785881ff1cdf191a2239811dc9597" category="inline-link-rx"></block> 后端，您需要满足以下要求：</block>
  <block id="66d640a9a050b05e6a914cbcd88a1e2e" category="list-text">`ssubscriptionID` 来自启用了 Azure NetApp Files 的 Azure 订阅。</block>
  <block id="b12fb354025b3dfa01277964eb72c060" category="inline-link">应用程序注册</block>
  <block id="26e3a81fff63a114b3f66931fe9817bd" category="list-text">`租户 ID` ， `clientID` 和 `clientSecret` 来自<block ref="8cf7d0e47908a64c9538530ae13f3b17" category="inline-link-rx"></block> 在 Azure Active Directory 中，具有足够的 Azure NetApp Files 服务权限。应用程序注册应使用` Azure 预定义的 `owner` 或 `Contributor... 角色。</block>
  <block id="3cedfb797d3e1bc073ba2b0b4d2502cf" category="inline-link">Azure 文档</block>
  <block id="0d379fc2fdd52ac2845c4a58f8ab28b3" category="admonition">要了解有关 Azure 内置角色的详细信息，请参见<block ref="b2e35876b943de7ace62c0922ab24aca" category="inline-link-rx"></block>。</block>
  <block id="f494e4df0fff53e809d6563f8ec1782f" category="inline-link">委派子网</block>
  <block id="96bad1a88a06c10d87cfb36e3a2e4569" category="list-text">至少包含一个的 Azure `位置`<block ref="c5f14b2142014dc234282a513132bad4" category="inline-link-rx"></block>。</block>
  <block id="4a836a0efc98ecae9af9c3407923eefe" category="inline-link">《快速入门指南》</block>
  <block id="7b0fbaf9fee0388fe8032c97b8257fdc" category="list-text">如果您是首次使用 Azure NetApp Files 或在新位置使用，则需要进行一些初始配置。请参见<block ref="713c3fd99272dda043016179a5584f00" category="inline-link-rx"></block>。</block>
  <block id="4a56a2a81941c5206604b30f5115b1ba" category="paragraph">根据后端配置（子网，虚拟网络，服务级别和位置）， Trident 会在请求位置提供的容量池上创建 ANF 卷，并与请求的服务级别和子网匹配。</block>
  <block id="0b0b881d3a43e5782867f1e6ea7ae219" category="admonition">Astra Trident 21.04.0 及更早版本不支持手动 QoS 容量池。</block>
  <block id="3e566c45584d66d2ab94c2108f7c3488" category="cell">"Azure-netapp-files"</block>
  <block id="9dd18f393b35bf22098cf53e9c1c7fa6" category="cell">驱动程序名称 + "_" + 随机字符</block>
  <block id="665120e71659a6a32f990a3181688d1b" category="cell">`ssubscriptionID` 。</block>
  <block id="b2ad290b003ccdce2a538f49a795f281" category="cell">Azure 订阅中的订阅 ID</block>
  <block id="e07778d10cef90430253876cba7157e4" category="cell">`租户 ID` 。</block>
  <block id="2975d48342e428a3b18123f85ed0ecb5" category="cell">应用程序注册中的租户 ID</block>
  <block id="949ba1045db0d48bd189044e672d8097" category="cell">`客户端 ID` 。</block>
  <block id="56ef18e84ab36c2bdc4546e6a2756673" category="cell">`clientSecret` 。</block>
  <block id="85f484f0892a96287b6224ddd3c5fbb2" category="cell">应用程序注册中的客户端密钥</block>
  <block id="1c65f12b4d30114593cc01384938cb5f" category="cell">`S标准` ， `高级` 或 `超级` 之一</block>
  <block id="b21b08bb55acd409e40e9b45edd3bb34" category="cell">"" （随机）</block>
  <block id="fc7dd5b65d21ee7272a067c9404a8498" category="cell">`位置`</block>
  <block id="8fce436e09a08bd124727374d3e1d1d5" category="cell">要创建新卷的 Azure 位置的名称</block>
  <block id="32ef1af5ccda7c2f6d85e55f5034f105" category="cell">`virtualNetwork`</block>
  <block id="10afd0959cfa4a53bce9c8d395c40c48" category="cell">具有委派子网的虚拟网络的名称</block>
  <block id="ec045173f4df65e5e8951c3ca9579945" category="cell">`ssubnet`</block>
  <block id="0b8deda0ecc5080e8c0ed0b475e983ba" category="cell">委派给 `Microsoft.Netapp/volumes` 的子网的名称</block>
  <block id="9440dab4b1faaad2a053d658b9e70623" category="admonition">如果在尝试创建 PVC 时遇到 " 未找到容量池 " 错误，则您的应用程序注册可能没有关联的所需权限和资源（子网，虚拟网络，容量池）。启用调试后， Astra Trident 将记录在创建后端时发现的 Azure 资源。请务必检查是否正在使用适当的角色。</block>
  <block id="e5ac299cc3b14e1fac29518569ca9bb1" category="cell">新卷的默认大小</block>
  <block id="dbb358dadb4da7e240eeaa0513a064e1" category="admonition">对于在 ANF 后端创建的所有卷， Astra Trident 会在配置存储池时将存储池上的所有标签复制到该存储卷。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="e43b3577dd4b74a4cfa994a56e8138b8" category="paragraph">当您刚开始使用 ANF 并尝试执行相关操作时，此配置是理想的选择，但实际上，您希望为所配置的卷提供更多范围界定。</block>
  <block id="725ae241ec74eed978f0b099030236b8" category="section-title">示例 3 ：高级配置</block>
  <block id="a83f4a534ccef7ac1d209fb0015cd907" category="paragraph">此后端配置进一步将卷放置范围缩小为一个子网，并修改了某些卷配置默认值。</block>
  <block id="198188b722e4e8ee2004b3bd2a9348ed" category="paragraph">此后端配置可在一个文件中定义多个存储池。如果您有多个容量池支持不同的服务级别，并且您希望在 Kubernetes 中创建表示这些服务级别的存储类，则此功能非常有用。</block>
  <block id="db471f3119123601d175fe8d2ef2dd0a" category="paragraph">以下 `S存储类` 定义是指上述存储池。通过使用 `parameters.selector` 字段，您可以为每个 `StorageClass` 指定用于托管卷的实际池。卷将在选定池中定义各个方面。</block>
  <block id="0cc7642bbaf969ea355ea12764841c91" category="summary">了解如何在您的 Astra Trident 安装中创建和使用 ONTAP NAS 驱动程序。本节提供了后端配置示例以及有关如何将后端映射到 StorageClasses 的详细信息。</block>
  <block id="a0f3a965c12688befda99da850903dcb" category="cell">`autosExportPolicy`</block>
  <block id="4a5695a4c9eea28a296b0b2f210a15f8" category="cell">启用自动创建和更新导出策略 [ 布尔值 ]</block>
  <block id="b4ad0dff08149092bc3e4b16572af575" category="cell">`autosExportCIDR`</block>
  <block id="af7117fef2444ab632b393ea31e722b8" category="cell">启用 `AutoExportPolicy` 时用于筛选 Kubernetes 节点 IP 的 CIDR 列表</block>
  <block id="e537a193eb90bd46a645ce750bb5f3fc" category="cell">[ "0.0.0.0/0 " ， " ：： /0 "]`</block>
  <block id="08b29ae4ea305dd80d0c3a96da64e57e" category="cell">NFS 挂载选项的逗号分隔列表</block>
  <block id="07f6b23cad3d6da54012935ff972affe" category="cell">`qtreesPerFlexvol`</block>
  <block id="a13306f726fdf72d2d992a7ebdc63b1b" category="cell">每个 FlexVol 的最大 qtree 数，必须在 50 ， 300 范围内</block>
  <block id="28326357ec2f8c06e01271c4ee2201f1" category="cell">200</block>
  <block id="c8725b273a5d1a37cc4d2ceafe222f96" category="admonition">创建后端时，请记住，创建后无法修改 `dataLIF` 和 `storagePrefix` 。要更新这些参数，您需要创建一个新的后端。</block>
  <block id="118ec9e23f24f4ea0355c0a8fc7644f8" category="paragraph">可以为 `managementLIF` 选项指定完全限定域名（ FQDN ）。也可以为 `dataLIF` 选项指定 FQDN ，在这种情况下， FQDN 将用于 NFS 挂载操作。这样，您就可以创建循环 DNS ，以便在多个数据 LIF 之间实现负载平衡。</block>
  <block id="3de9530f105c3bf7d417c73170a03e5a" category="paragraph">对于所有 ONTAP 驱动程序，也可以将 `managementLIF` 设置为 IPv6 地址。请务必使用 ` -use-ipv6` 标志安装 Astra Trident 。必须 `m方括号内的` anagementLIF IPv6 地址。</block>
  <block id="06390865e9ec240a0e295db286d7bef7" category="paragraph">使用 `autosExportPolicy` 和 `autosExportCIDR` 选项， CSI Trident 可以自动管理导出策略。所有 ontap-nas-* 驱动程序均支持此功能。</block>
  <block id="e98c128dda80ebab208244e4f62e7372" category="paragraph">对于 `ontap-nas-economy` 驱动程序， `limitVolumeSize` 选项还会限制它为 qtree 和 FlexVol 管理的卷的最大大小，而 `qtreesPerFlexvol` 选项允许自定义每个 的最大 qtree 数。</block>
  <block id="92e660f52759e323dbc0ec71541a2e9e" category="paragraph">可以使用 `nfsMountOptions` 参数指定挂载选项。Kubernetes 永久性卷的挂载选项通常在存储类中指定，但如果在存储类中未指定挂载选项，则 Astra Trident 将回退为使用存储后端配置文件中指定的挂载选项。如果在存储类或配置文件中未指定挂载选项，则 Astra Trident 不会在关联的永久性卷上设置任何挂载选项。</block>
  <block id="7587c806a60b3f88688668f32e0b766c" category="admonition">Astra Trident 会在使用 `ontap-NAS` 和 `ontap-nas-flexgroup` 创建的所有卷的 "Comments" 字段中设置配置标签。根据所使用的驱动程序，注释将在 FlexVol （`ontap-NAS` ）或 FlexGroup （`ontap-nas-flexgroup` ）上进行设置。Astra Trident 会在配置存储池时将存储池上的所有标签复制到该存储卷。存储管理员可以为每个存储池定义标签，并对存储池中创建的所有卷进行分组。这样，您就可以根据后端配置中提供的一组可自定义标签来方便地区分卷了。</block>
  <block id="831924abd31e90baedabed887dbfc24c" category="cell">要为创建的卷分配的自适应 QoS 策略组。选择每个存储池 / 后端的 qosPolicy 或 adaptiveQosPolicy 之一。不受 ontap-nas-economy.</block>
  <block id="3e9a232d025270ed6767c385b8291871" category="cell">新卷的模式</block>
  <block id="2ad2c2d9206a1be7e744bb13b2b126dd" category="cell">777.</block>
  <block id="7ad68fdac2eac069eb8ed0fc45b0fb74" category="cell">snapshotDir</block>
  <block id="2907de5eba980e910513008165ea2c2b" category="cell">控制 ` .snapshot` 目录的可见性</block>
  <block id="c1a0e97f953c948568aed6c134fc9711" category="cell">要使用的导出策略</block>
  <block id="f7f695c763ad0e0ba03c2ff9cbcfcb3d" category="cell">securityStyle</block>
  <block id="06602e99c8d46d601029e6dd0b37e3f8" category="paragraph">对于 `ontap-nas` 和 `ontap-nas-flexgroups` ， Astra Trident 现在使用新的计算方法来确保 FlexVol 的大小正确，并使用 snapshotReserve 百分比和 PVC 。当用户请求 PVC 时， Astra Trident 会使用新计算创建具有更多空间的原始 FlexVol 。此计算可确保用户在 PVC 中收到所请求的可写空间，而不是小于所请求的空间。在 v21.07 之前，如果用户请求 PVC （例如， 5GiB ），并且 snapshotReserve 为 50% ，则只会获得 2.5 GiB 的可写空间。这是因为用户请求的是整个卷，而 `snapshotReserve` 是其中的一个百分比。在 Trident 21.07 中，用户请求的是可写空间， Astra Trident 将 `snapshotReserve` number 定义为整个卷的百分比。这不适用于 `ontap-nas-economy"` 。请参见以下示例以了解其工作原理：</block>
  <block id="86ec808b80973d24eadfc617926f534e" category="paragraph">计算方法如下：</block>
  <block id="28ad7be76b350116bde3ae04e5f94a60" category="paragraph">对于 snapshotReserve = 50% ， PVC 请求 = 5GiB ，卷总大小为 2/.5 = 10GiB ，可用大小为 5GiB ，这是用户在 PVC 请求中请求的大小。`volume show` 命令应显示与以下示例类似的结果：</block>
  <block id="daabb7db82ac9f3f074671a1185c462e" category="paragraph">在升级 Astra Trident 时，先前安装的现有后端将按照上述说明配置卷。对于在升级之前创建的卷，您应调整其卷的大小，以便观察到所做的更改。例如，一个 2 GiB PVC ，其 `snapshotReserve=50` earlier 会导致一个卷提供 1 GiB 的可写空间。例如，将卷大小调整为 3GiB 可为应用程序在一个 6 GiB 卷上提供 3GiB 的可写空间。</block>
  <block id="f35c0fe4b6581c16866c964cef229bfa" category="admonition">如果在采用 Trident 的 NetApp ONTAP 上使用 Amazon FSx ，建议为 LIF 指定 DNS 名称，而不是 IP 地址。</block>
  <block id="acf031eeb31936d30314a2d2a698e85b" category="section-title">具有基于证书的身份验证的 ONTAP NAS 驱动程序</block>
  <block id="89e5db56c8bbbfc3f8f2325201c46450" category="section-title">具有自动导出策略的 ontap-NAS 驱动程序</block>
  <block id="8c35a9f7d631f51e05811b36617db641" category="paragraph">此示例显示了如何指示 Astra Trident 使用动态导出策略自动创建和管理导出策略。这对于 `ontap-nas-economy.` 和 `ontap-nas-flexgroup` 驱动程序也是如此。</block>
  <block id="97cf2271125e9ece6c4bb85c7e38b6f6" category="section-title">ontap-nas-flexgroup 驱动程序</block>
  <block id="0178beee313066e023eef8c258ed5bfc" category="section-title">使用 IPv6 的 ONTAP NAS 驱动程序</block>
  <block id="e3d163236efea4513c9df89a9c1be381" category="section-title">ontap-nas-economy-driver</block>
  <block id="412b252fa44d1a73e3e7bf22113f99a2" category="section-title">ontap-NAS 驱动程序</block>
  <block id="141da5e3f576179cbf2f6506b07ef538" category="summary">从 Astra Trident 的 20.01 版开始，您可以在 Kubernetes 层创建永久性卷（ PV ）的快照。您可以使用这些快照维护由 Astra Trident 创建的卷的时间点副本，并计划创建其他卷（克隆）。</block>
  <block id="332138092a1597c4d5e69679199e490c" category="inline-link">发布博客</block>
  <block id="006b05a472974308122f7f05ef147e80" category="admonition">此功能可从 Kubernetes 1.17 （测试版）获得，从 1.20 开始正式上市。要了解从测试版迁移到 GA 所涉及的变化，请参见<block ref="02a1c904d0035e03c61e261dbe622345" category="inline-link-rx"></block>。升级到 GA 后，将推出 `v1` API 版本，并向后兼容 `v1bea1` 快照。</block>
  <block id="e197a057bfe0ae792bb2b9ce9a78761e" category="list-text">要创建卷快照，需要创建外部快照控制器以及一些自定义资源定义（ Custom Resource Definitions ， CRD ）。这是所使用的 Kubernetes 流程编排程序（例如： Kubeadm ， GKEE ， OpenShift ）的职责。</block>
  <block id="3923fe4170ab3f204b53d4caf958045f" category="paragraph">您可以按如下所示创建外部快照控制器和快照 CRD ：</block>
  <block id="7737ff29322b0df9949b5d44ad3809a9" category="list-text">创建卷快照 CRD ：</block>
  <block id="7a993e4667899d0bca97d13e0bc37568" category="list-text">在所需命名空间中创建 snapshot-controller 。编辑以下 YAML 清单以修改命名空间。</block>
  <block id="26c4fe55fc424c7b41b517701f54f074" category="inline-link">正在验证 webhook</block>
  <block id="46b189b23dfbd5f3f622a1c04590b05e" category="admonition">CSI Snapshotter 提供了<block ref="927ab0e919f8034deab1249bed53a289" category="inline-link-rx"></block> 帮助用户验证现有 v1bea1 快照并确认它们是有效的资源对象。正在验证的 webhook 会自动标记无效的快照对象，并防止将来创建无效对象。验证 webhook 由 Kubernetes 流程编排程序部署。请参见有关手动部署验证 webhook 的说明<block ref="07cb3cdda0599ec9f2e82062ecd12e82" category="inline-link-rx"></block>。查找无效快照清单的示例<block ref="bceda34f0850fc68d82f08741abbc69e" category="inline-link-rx"></block>。</block>
  <block id="f535be08d3997f1a801b132862d99a5c" category="paragraph">下面详细介绍的示例说明了使用快照所需的构造，并说明了如何创建和使用快照。</block>
  <block id="551730f3a084f9dee63029647e815d3a" category="section-title">第 1 步：设置 VolumeSnapshotClass</block>
  <block id="d7ca7162c394dee752c35d07a92823da" category="inline-link-macro">`VolumeSnapshotClass`</block>
  <block id="b91e58d7d80a51e4fa86b9ab27dca505" category="paragraph">在创建卷快照之前，请设置 <block ref="c740b46915208e935cb2017421ec0264" category="inline-link-macro-rx"></block>。</block>
  <block id="4744d2c82c1c470ab40280b2ebba0c08" category="paragraph">`d河` 指向 Astra Trident 的 CSI 驱动程序。`deeltionPolicy` 可以是 `Delete` 或 `Retain` 。如果设置为 `Retain` ，则即使删除了 `VolumeSnapshot` 对象，存储集群上的底层物理快照也会保留。</block>
  <block id="0ab6380edce0d0e7b8538ebf3215ebbd" category="section-title">第 2 步：创建现有 PVC 的快照</block>
  <block id="ef55488b02c4b0173eb6f7bb867db086" category="paragraph">正在为名为 `PVC1` 的 PVC 创建快照，并且快照名称设置为 `PVC1-Snap` 。</block>
  <block id="501470eb266ff6637de993e3f193ba40" category="paragraph">这样就创建了一个 `VolumeSnapshot` 对象。VolumeSnapshot 类似于 PVC ，并与代表实际快照的 `VolumeSnapshotContent` 对象关联。</block>
  <block id="320e7c242b569ab5bbdaa490b3df817e" category="paragraph">可以通过描述来标识 `PVC1-Snap` VolumeSnapshot 的 `VolumeSnapshotContent` 对象。</block>
  <block id="b3841b02d7da01fde480332e3295a08e" category="paragraph">`Snapshot Content Name` 用于标识提供此快照的 VolumeSnapshotContent 对象。`Ready to Use` 参数表示可使用 Snapshot 创建新的 PVC 。</block>
  <block id="7957320b126678e9b713ef146b3ac009" category="section-title">第 3 步：从 VolumeSnapshots 创建 PVC</block>
  <block id="4d780b57cad08f64bcd1ea7351a15588" category="paragraph">有关使用快照创建 PVC 的示例，请参见以下示例：</block>
  <block id="2592284f87bba60e4c05337a134ef047" category="paragraph">`dataSource` 显示必须使用名为 `PVC1-Snap` 的 VolumeSnapshot 作为数据源来创建 PVC 。此操作将指示 Astra Trident 从快照创建 PVC 。创建 PVC 后，可以将其附加到 Pod 上，并像使用任何其他 PVC 一样使用。</block>
  <block id="bda01e3aa44c411129a6fbf29445bfb4" category="admonition">删除具有关联快照的永久性卷时，相应的 Trident 卷将更新为 " 正在删除 " 状态。要删除 Astra Trident 卷，应删除该卷的快照。</block>
  <block id="fab3fcd54585164dbc9d7adf57f8e3d9" category="list-text"><block ref="fab3fcd54585164dbc9d7adf57f8e3d9" category="inline-link-macro-rx"></block></block>
  <block id="c740b46915208e935cb2017421ec0264" category="list-text"><block ref="c740b46915208e935cb2017421ec0264" category="inline-link-macro-rx"></block></block>
  <block id="3d79668ab3683a20086b2953dd541cfc" category="summary">后端定义了 Astra Trident 与存储系统之间的关系。它告诉 Astra Trident 如何与该存储系统进行通信，以及 Astra Trident 如何从该存储系统配置卷。Astra Trident 将自动从后端提供符合存储类定义的要求的存储池。了解有关根据您拥有的存储系统类型配置后端的更多信息。</block>
  <block id="87dc0337d3ded2211d9b01c32e22d90d" category="doc">配置后端</block>
  <block id="2acbb5dd492d792d00383b0c76ade4ad" category="list-text"><block ref="2acbb5dd492d792d00383b0c76ade4ad" category="inline-link-macro-rx"></block></block>
  <block id="bf50e8af5395f90aa84ae77d9267a6d6" category="inline-link-macro">为 AWS 后端配置 Cloud Volumes Service</block>
  <block id="cda28963ed4e2275760c1b26ef6c78e0" category="list-text"><block ref="cda28963ed4e2275760c1b26ef6c78e0" category="inline-link-macro-rx"></block></block>
  <block id="252e63ff646a0204671ca04a26b88e06" category="inline-link-macro">配置适用于 Google 云平台的 Cloud Volumes Service 后端</block>
  <block id="c00b6e370d4496e06d2135275a992af5" category="list-text"><block ref="c00b6e370d4496e06d2135275a992af5" category="inline-link-macro-rx"></block></block>
  <block id="b1064b6f7a5906eac23601dc24ba95a8" category="list-text"><block ref="b1064b6f7a5906eac23601dc24ba95a8" category="inline-link-macro-rx"></block></block>
  <block id="d7f015aa2f1d488e17e175dac6de3149" category="list-text"><block ref="d7f015aa2f1d488e17e175dac6de3149" category="inline-link-macro-rx"></block></block>
  <block id="24ca391029d6df294c5d5b8f1fe5b4eb" category="summary">了解如何使用 ONTAP NAS 驱动程序配置 ONTAP 后端。</block>
  <block id="df3afb1ce4cf5592326d7f536313cbc9" category="list-text"><block ref="df3afb1ce4cf5592326d7f536313cbc9" category="inline-link-macro-rx"></block></block>
  <block id="6a60ddae29750feed1e12421a92ea824" category="list-text"><block ref="6a60ddae29750feed1e12421a92ea824" category="inline-link-macro-rx"></block></block>
  <block id="0f5dc79c8003190ab8f758b1748ba0d8" category="summary">NetApp 不断改进和完善其产品和服务。以下是最新版 Astra Trident 中的一些最新功能，增强功能和错误修复。</block>
  <block id="5dd03e8d039863e563e049be198c3fd3" category="doc">发行说明</block>
  <block id="2e6ce374ac42de81aea6a3d682b92e33" category="paragraph">发行说明提供了有关最新版本的 Astra Trident 中的新增功能，增强功能和错误修复的信息。</block>
  <block id="e4c4d344a524d21b898e4d04b6539aa7" category="admonition">安装程序 zip 文件中提供的 `tridentctl` 二进制文件是经过测试且受支持的版本。请注意， zip 文件的 ` 或 Extras` 部分中提供的 `macos` 二进制文件未经过测试或不受支持。</block>
  <block id="fdb053d6bab681277dcb47b3a45e2e85" category="section-title">自 Astra Trident 21.07 以来发生的变化</block>
  <block id="41cf959adc98386b54829d71a6ed5d37" category="section-title">修复</block>
  <block id="a6e7aa999ba654c6844672ae59f5137a" category="list-text">修复了问题描述，其中无法将 XFS 卷的克隆挂载到与源卷相同的节点上（ GitHub 问题描述 514 ）。</block>
  <block id="4a921ae3eb8c2695dabd4044ff81141a" category="list-text">修复了问题描述，其中 Astra Trident 在关闭时记录了致命错误（ GitHub 问题描述 597 ）。</block>
  <block id="852acc81ea6fa7363b73c5313002de83" category="list-text">与 Kubernetes 相关的修复程序：</block>
  <block id="f94cc5159119c43751041256941deb2c" category="list-text">使用 `ontap-NAS` 和 `ontap-nas-flexgroup` 驱动程序创建快照时，将卷的已用空间返回为最小还原大小（ GitHub 问题描述 645 ）。</block>
  <block id="742ce2e3c9c8496323bd1176af2838a4" category="list-text">修复了问题描述，其中 `无法扩展文件系统` 在调整卷大小后记录了错误（ GitHub 问题描述 560 ）。</block>
  <block id="9a445ecbad9af70a94bd7558ba95e059" category="list-text">修复了 POD 可能停留在 `正在终止` 状态的问题描述（ GitHub 问题描述 572 ）。</block>
  <block id="4f81c320a621b8c9d81c7334f2cffc71" category="list-text">修复了 `ontap-san-economy-lun` FlexVol 可能已满快照 LUN 的情况（ GitHub 问题描述 533 ）。</block>
  <block id="169c3be63dd22b315ed7884e246338de" category="list-text">使用不同映像修复了自定义 YAML 安装程序问题描述（ GitHub 问题描述 613" ）。</block>
  <block id="1077a1a91a96498c2f56bc630e632eee" category="list-text">固定快照大小计算（ GitHub 问题描述 611 ）。</block>
  <block id="fe705e5b02638736087c9fd97b2c4952" category="list-text">修复了问题描述，其中所有 Astra Trident 安装程序都可以将纯 Kubernetes 标识为 OpenShift （ GitHub 问题描述 639 ）。</block>
  <block id="27b76ffa775f907a1fd51f21a669551b" category="list-text">修复了 Trident 操作员在无法访问 Kubernetes API 服务器时停止协调的问题（ GitHub 问题描述 599 ）。</block>
  <block id="c1748037d10cffabb8e95e4ccf77c613" category="section-title">增强功能</block>
  <block id="1f9e922b6eff6cb06fca1ed9137eed38" category="list-text">为 GCP-CVS 性能卷增加了对 `unixPermissions` 选项的支持。</block>
  <block id="294b850a76a040c20913e76c2fe6589a" category="list-text">增加了对 GCP 中 600 GiB 到 1 TiB 范围内的扩展优化 CVS 卷的支持。</block>
  <block id="0333eb54465646b87754facff75fdb5f" category="list-text">Kubernetes 相关增强功能：</block>
  <block id="c32aa411caa1ffd0e30a271f5be834d9" category="list-text">增加了对 Kubernetes 1.22 的支持。</block>
  <block id="fa1fd8841173fa7ccde5059fb7c2f903" category="list-text">已启用 Trident 操作员和 Helm 图表以使用 Kubernetes 1.22 （ GitHub 问题描述 628 ）。</block>
  <block id="dbaa551f190105e514f7816811f4b397" category="list-text">已将操作员映像添加到 `tridentctl` images 命令（ GitHub 问题描述 570 ）中。</block>
  <block id="be575f1ff204f2800114965a5c0d8575" category="section-title">实验增强功能</block>
  <block id="29ddf941d9825cc9283521ee90468595" category="list-text">在 `ontap-san` 驱动程序中增加了对卷复制的支持。</block>
  <block id="e2f2b85987da5e2397c1e342a6fd9e28" category="list-text">增加了对 `ontap-nas-flexgroup` ， `ontap-san` 和 `ontap-nas-economy` 驱动程序的 * 技术预览 * REST 支持。</block>
  <block id="95dc0391ce7b396d7dd5622284e8fc3e" category="section-title">已知问题</block>
  <block id="64a8f71bee95a6635e88bce00f1a2d3c" category="paragraph">已知问题用于确定可能会阻止您成功使用本产品的问题。</block>
  <block id="572b1d7e33a1c667884a1ffdff7a2d25" category="list-text">对于在其 StorageClass 中未指定 `FSType` 的卷， Astra Trident 现在会强制使用空的 `FSType` （`FSTtype=""` ）。使用 Kubernetes 1.17 或更高版本时， Trident 支持为 NFS 卷提供一个空的 `FSType` 。对于 iSCSI 卷，在使用安全上下文强制执行 `fsGroup` 时，您需要在 StorageClass 上设置 `FSType` 。</block>
  <block id="91186d69835ccf9911e356f74938c539" category="list-text">在多个 Astra Trident 实例之间使用后端时，每个后端配置文件对于 ONTAP 后端应具有不同的 `storagePrefix` 值，或者对于 SolidFire 后端使用不同的 `租户名称` 。Astra Trident 无法检测其他 Astra Trident 实例创建的卷。尝试在 ONTAP 或 SolidFire 后端创建现有卷会成功，因为 Astra Trident 会将卷创建视为一项幂等操作。如果 `storagePrefix` 或 `租户名称` 不存在差异，则在同一后端创建的卷可能会发生名称冲突。</block>
  <block id="9bf4c601179068ff3574d2cf87536564" category="list-text">安装 Astra Trident （使用 `tridentctl` 或 Trident 操作员）并使用 `tridentctl` 管理 Astra Trident 时，应确保设置 `KUBECONFIG` 环境变量。这是 `需要对` tridentctl 进行处理的 Kubernetes 集群进行指示的。在使用多个 Kubernetes 环境时，您应确保准确获取 `KUBECONFIG` 文件。</block>
  <block id="6d791d3b45515fd8619e489b938f39e8" category="inline-link">挂载选项</block>
  <block id="d4b9b9554fd820f43eae492d33e41167" category="inline-link">`s存储类`</block>
  <block id="a5c785ee36f0f2d14349653f744c8e3b" category="list-text">要对 iSCSI PV 执行联机空间回收，工作节点上的底层操作系统可能需要将挂载选项传递到卷。这一点适用于需要 `discard` 的 RHEL/RedHat CoreOS 实例<block ref="2ee633fb26bfccf07d490458d29f92a2" category="inline-link-rx"></block>；确保中包含 Discard mountOption<block ref="b44436f062a8f5a535d8cafcffeb70b2" category="inline-link-rx"></block> 支持联机块丢弃。</block>
  <block id="c2ebda3702872aaa7ad44122f2343d7e" category="list-text">如果每个 Kubernetes 集群有多个 Astra Trident 实例，则 Astra Trident 将无法与其他实例通信，也无法发现它们创建的其他卷，如果集群中运行多个实例，则会导致意外的错误行为。每个 Kubernetes 集群只能有一个 Astra Trident 实例。</block>
  <block id="294f8c33b7ccdbcbf422998b64c9c931" category="list-text">如果在 Astra Trident 脱机时从 Kubernetes 中删除了基于 Astra Trident 的 `StorageClass` 对象，则 Astra Trident 不会在恢复联机后从其数据库中删除相应的存储类。您应使用 `tridentctl` 或 REST API 删除这些存储类。</block>
  <block id="ddab3f1d971a7608afb4c30c688a32ac" category="list-text">如果用户在删除相应的 PVC 之前删除了由 Astra Trident 配置的 PV ，则 Astra Trident 不会自动删除后备卷。您应通过 `tridentctl` 或 REST API 删除此卷。</block>
  <block id="0821431aba133adbfa7fa0ca1781eedd" category="list-text">ONTAP 不能同时配置多个 FlexGroup ，除非聚合集对于每个配置请求是唯一的。</block>
  <block id="38699c45ccc629a8b46bd780d7aef2f6" category="list-text">使用基于 IPv6 的 Astra Trident 时，应在后端定义中方括号内指定 `managementLIF` 和 `dataLIF` 。例如， `` FD20 ： 8b1e ： b258 ： 2000 ： f816 ： 3effe ： feec ： 0`` 。</block>
  <block id="d83c67344719a209c50396895dd2fbe1" category="list-text">如果将 `solidfire-san` 驱动程序与 OpenShift 4.5 结合使用，请确保底层工作节点使用 MD5 作为 CHAP 身份验证算法。</block>
  <block id="e9a7080bd6d1b50ff15cef6f14fa1d64" category="inline-link">Astra Trident GitHub</block>
  <block id="b94e036fb032554ca486dd8fc2e3fafe" category="list-text"><block ref="b94e036fb032554ca486dd8fc2e3fafe" category="inline-link-rx"></block></block>
  <block id="3334dfda9735f9b3ed55a34ef316b599" category="inline-link">Astra Trident 博客</block>
  <block id="d090b5d97388b77aa02e5d1203c037a0" category="list-text"><block ref="d090b5d97388b77aa02e5d1203c037a0" category="inline-link-rx"></block></block>
  <block id="34c4dac14496e9c45d92f345d9392fc8" category="summary">如果您未运行最新版本，则可以参考有关先前版本的 Astra Trident 的文档。</block>
  <block id="ba09ee47d11962c1ccd13d7e1f10e6c5" category="doc">文档的早期版本</block>
  <block id="0c141ec81d4107f4c63fb0deb2531c0d" category="inline-link">Astra Trident 21.04</block>
  <block id="193bfae1ebda99fb7289c66fa69395a0" category="list-text"><block ref="193bfae1ebda99fb7289c66fa69395a0" category="inline-link-rx"></block></block>
  <block id="cba2c660d905f83e39a0d1771286c9e7" category="inline-link">Astra Trident 21.01</block>
  <block id="97f32ab1a5165dc49105dca53b9f4de7" category="list-text"><block ref="97f32ab1a5165dc49105dca53b9f4de7" category="inline-link-rx"></block></block>
  <block id="727d2d1e15a5c7260e90c50b1c250a4c" category="inline-link">Astra Trident 20.10</block>
  <block id="8a0315074645cbbab67a7445dcdf42f2" category="list-text"><block ref="8a0315074645cbbab67a7445dcdf42f2" category="inline-link-rx"></block></block>
  <block id="bad2b8fa41c05085668e48d7c14968dc" category="inline-link">Astra Trident 20.07</block>
  <block id="449d7e957347de63ee3d9841c40b4e7f" category="list-text"><block ref="449d7e957347de63ee3d9841c40b4e7f" category="inline-link-rx"></block></block>
  <block id="7c0a09ca9ea4472728e4661755a43c6b" category="inline-link">Astra Trident 20.04</block>
  <block id="8a72b28486832ed8c725617460afbdcb" category="list-text"><block ref="8a72b28486832ed8c725617460afbdcb" category="inline-link-rx"></block></block>
  <block id="1dc5429c6c86712d7628beb5652a0e2e" category="inline-link">Astra Trident 20.01</block>
  <block id="23204facdc38bad335a6afce81db0827" category="list-text"><block ref="23204facdc38bad335a6afce81db0827" category="inline-link-rx"></block></block>
  <block id="5b2d210bf907d26b59abbaa0e22fbbe6" category="inline-link">Astra Trident 19.10</block>
  <block id="3377906a52734323c44c8f31b2d29e63" category="list-text"><block ref="3377906a52734323c44c8f31b2d29e63" category="inline-link-rx"></block></block>
  <block id="f1d7fe87216a18ff3ffcfa98d6065689" category="inline-link">Astra Trident 19.07</block>
  <block id="12e29d431cea2700aa9d89e0c89e67bc" category="list-text"><block ref="12e29d431cea2700aa9d89e0c89e67bc" category="inline-link-rx"></block></block>
  <block id="fe4bdabecc64b786523a3d86bb1f9cfd" category="inline-link">Astra Trident 19.04</block>
  <block id="e43783d5a51a10670edf444f0b58b6af" category="list-text"><block ref="e43783d5a51a10670edf444f0b58b6af" category="inline-link-rx"></block></block>
  <block id="5e152ff33f3262612abc4b942db27ad1" category="inline-link">Astra Trident 19.01</block>
  <block id="977636e26059252def0425dca74811ef" category="list-text"><block ref="977636e26059252def0425dca74811ef" category="inline-link-rx"></block></block>
  <block id="e84181a29f4e43a18b27e7d82797adef" category="summary">适用于 Docker 的 Astra Trident 可与适用于 NetApp 存储平台的 Docker 生态系统以及 AWS 中的 Cloud Volumes Service 直接集成。它支持从存储平台到 Docker 主机的存储资源配置和管理，并提供一个框架，用于在未来添加其他平台。</block>
  <block id="d2eb05d1990246a079aeb2f56e3a4237" category="paragraph">Astra Trident 的多个实例可以同时在同一主机上运行。这样可以同时连接到多个存储系统和存储类型，并能够自定义用于 Docker 卷的存储。</block>
  <block id="89bcbd8e4ba49b7310e9fa748e878c4b" category="inline-link-macro">部署的前提条件</block>
  <block id="d1e7215d070e62d3e82e915d703ceaa9" category="paragraph">请参见 <block ref="a51fda4654690ac4414966ed4956599c" category="inline-link-macro-rx"></block>。确保满足前提条件后，即可部署 Astra Trident 。</block>
  <block id="88f0ab229fa9d759d74fcf6ab7cc17b1" category="section-title">Docker 托管插件方法（ 1.13/17.03 及更高版本）</block>
  <block id="135b308ed83c53f1516b7c754566d1c4" category="admonition-title">开始之前</block>
  <block id="070ecb002d71e4e7618a4b46a5ba690f" category="admonition">如果您在传统守护进程方法中使用了 Astra Trident 之前的 Docker 1.13/ 17.03 ，请确保在使用受管插件方法之前停止 Astra Trident 进程并重新启动 Docker 守护进程。</block>
  <block id="7bf1ee8f4e093050c1cdf1842931af7d" category="list-text">停止所有正在运行的实例：</block>
  <block id="47b9ec5c8c4439980c63f4188bad5324" category="list-text">重新启动 Docker 。</block>
  <block id="5311ac4d72d5c91dcaa39b896d3b8027" category="list-text">确保已安装 Docker 引擎 17.03 （新版本 1.13 ）或更高版本。</block>
  <block id="07d6db5e99a0aa19fe76f15efed30ecf" category="inline-link">安装或更新安装</block>
  <block id="2c3bc9d0632e0cccc05fdd3c42467df9" category="paragraph">如果您的版本已过期，<block ref="ddebe10ca17c0276898872fa2632e8fb" category="inline-link-rx"></block>。</block>
  <block id="48afbcf494fc19ee409f5aff48ae32c3" category="list-text">创建配置文件并按如下所示指定选项：</block>
  <block id="9314e9bcd24c80b255fc3e9e697a2ada" category="list-text">`config` ：默认文件名为 `config.json` ，但您可以使用所选的任何名称，方法是使用文件名指定 `config` 选项。此配置文件必须位于主机系统上的 ` /etc/netappdvp` 目录中。</block>
  <block id="8798dc2a3b5e61873054923c9f170ac7" category="list-text">`log-level` ：指定日志记录级别（ `debug` ， `info` ， `warn` ， `error` ， `fal` ）。默认值为 `info` 。</block>
  <block id="45ed67026a1141006588fcc698646141" category="list-text">`debug` ：指定是否启用调试日志记录。默认值为 false 。如果为 true ，则覆盖日志级别。</block>
  <block id="3bed6f89999b483af7f55024d9e7c02a" category="list-text">为配置文件创建一个位置：</block>
  <block id="28156615c51d4bad2ee47d0a9f43f404" category="list-text">创建配置文件：</block>
  <block id="4e2deef4eda7b7593f1e94279c96a31d" category="list-text">使用受管插件系统启动 Astra Trident 。</block>
  <block id="a4574d19d34a14aa0accde782f35318b" category="list-text">开始使用 Astra Trident 消耗已配置系统中的存储。</block>
  <block id="a9c521f25a3bacb94ad1dd4705b3585f" category="list-text">创建名为 "firstVolume" 的卷：</block>
  <block id="4fbca4f67cbe96bc7d7a16691d2912c2" category="list-text">在容器启动时创建默认卷：</block>
  <block id="b8e88709dbc4f2f80a96f53f83862704" category="list-text">删除卷 "firstVolume" ：</block>
  <block id="0e68ac1d84bfedf203365a9fb37db9ed" category="section-title">传统方法（ 1.12 或更早版本）</block>
  <block id="2c1107bda4c1ae7904ab1835c35973b7" category="list-text">确保您已安装 Docker 版本 1.10 或更高版本。</block>
  <block id="b6fdfa2eab3e357687eba5ddec2bea0c" category="paragraph">如果您的版本已过期，请更新您的安装。</block>
  <block id="45c61654258cfd16ceec15df7df02138" category="inline-link">按照适用于您的分发版本的说明进行操作</block>
  <block id="07dff22faeb910f375341cfcbd4899fd" category="paragraph">或<block ref="9ce989a7f7f995616a47f5dd291ed229" category="inline-link-rx"></block>。</block>
  <block id="588d2fe1c60271cde75dbeba32e0b25b" category="list-text">确保已为您的系统配置 NFS 和 / 或 iSCSI 。</block>
  <block id="03fe5b0d58270efa87041677cac72ad7" category="list-text">安装和配置 NetApp Docker 卷插件：</block>
  <block id="f45f5a64dae951d3e37c9bd382201b06" category="list-text">下载并解压缩应用程序：</block>
  <block id="b255d9e06a4ca8e9f5bc31c9198426ad" category="list-text">移动到托箱路径中的某个位置：</block>
  <block id="ca8a5486f4257b2aef35a8e769fc51d9" category="list-text">放置二进制文件并创建配置文件后，使用所需的配置文件启动 Trident 守护进程。</block>
  <block id="d3fa61f14ead6cf1cf1d584cf0b6c4e1" category="admonition">除非指定，否则卷驱动程序的默认名称为 "netapp" 。</block>
  <block id="9ad37c975c341297c49c69353516a727" category="paragraph">启动守护进程后，您可以使用 Docker 命令行界面创建和管理卷</block>
  <block id="e3dec3f86b9a3b1be209ab63855ce432" category="list-text">创建卷</block>
  <block id="5ff2e3e853922fdb84ef21b85ffdac2e" category="list-text">启动容器时配置 Docker 卷：</block>
  <block id="8f6a91f5f21d0478e3fd89095fc28ab9" category="list-text">删除 Docker 卷：</block>
  <block id="e63e2a2b9c9184e703ff8d93bb92508b" category="section-title">在系统启动时启动 Astra Trident</block>
  <block id="34f4e076aba0519cebd8bb63617b2f7e" category="paragraph">有关基于 systemd 的系统的示例单元文件，请参见 Git repo 中的 `contrib/trident.service.example` 。要将此文件与 CentOS/RHEL 结合使用，请执行以下操作：</block>
  <block id="5b51496da86e5a2073e0c618390c3d2a" category="list-text">将文件复制到正确的位置。</block>
  <block id="44103de0a164f687d305ad91e919d8ee" category="paragraph">如果正在运行多个实例，则单元文件应使用唯一名称。</block>
  <block id="3223aadc84a3ccb4a3473ba01c895184" category="list-text">编辑文件，更改问题描述（第 2 行）以匹配驱动程序名称和配置文件路径（第 9 行）以反映您的环境。</block>
  <block id="1edae3931401a32d7dd7dd6e0a2ad563" category="list-text">重新加载 systemd 以载入更改：</block>
  <block id="db38a93e27eba57d507611d002ad612f" category="list-text">启用服务。</block>
  <block id="c7e0a4deeebe264aa7d5f7f3ca3ef77f" category="paragraph">根据您在 ` /usr/lib/systemd/system` 目录中为文件命名的内容，此名称会有所不同。</block>
  <block id="baa04490a79e9e8de7fa4cd44e2c6fbb" category="list-text">启动服务。</block>
  <block id="93c7574cf83c1f01b04891cf2d826cea" category="list-text">查看状态。</block>
  <block id="f4f15418284ae7a01b27fccc1af0463a" category="admonition">每当您修改单元文件时，请运行 `systemctl daemon-reload` 命令，使其了解所做的更改。</block>
  <block id="23c9c608b55b9071002aeddfd6c5563c" category="summary">在部署 Astra Trident 之前，您必须在主机上安装和配置必要的协议前提条件。</block>
  <block id="782bd8949cb40c80fd3f3126eccab35a" category="doc">部署的前提条件</block>
  <block id="b4851e92b19af0c5c82447fc0937709d" category="inline-link-macro">要求</block>
  <block id="33446a91021b76dfabfca4afe312824a" category="list-text">验证您的部署是否满足所有要求 <block ref="bc54c30334f793aa90542f3d86da0da6" category="inline-link-macro-rx"></block>。</block>
  <block id="d46ecc35447a8c17ef014ff6daf07bba" category="inline-link">安装或更新它</block>
  <block id="1035fa0ac2c3ed19f6ba56cafe7e121f" category="list-text">验证您是否安装了受支持的 Docker 版本。如果您的 Docker 版本已过时，<block ref="0b011811ae105895ca4da9769d7e6f99" category="inline-link-rx"></block>。</block>
  <block id="7760c52227ccba10f5bc395571ca7a60" category="list-text">验证是否已在主机上安装和配置协议前提条件：</block>
  <block id="7f50d5e5825124658e17cc8cfaa7f823" category="list-text">启动多路径守护进程：</block>
  <block id="43ce2a55c085b27f271203155d2745e1" category="list-text">确保已启用 `iscsid` 和 `multipathd` 并正在运行：</block>
  <block id="04c298ec3fc67bce1115cddcc2b3b829" category="paragraph">`sudo systemctl enable iscsid multipathd` `sudo systemctl start iscsid multipathd`</block>
  <block id="2cfaa468af4e9de7ba9933d9e0081572" category="list-text">发现 iSCSI 目标：</block>
  <block id="f0c700b766cfcc86bc21496513c58391" category="paragraph">`sudo iscsiadm -m discoverydb -t st -p &lt;data_LIF_IP&gt; -discover`</block>
  <block id="18124bf28831e04dabc4dc81d1d4e69f" category="list-text">登录到发现的 iSCSI 目标：</block>
  <block id="ba64ec4efdc69990967a75a918b83635" category="paragraph">`sudo iscsiadm -m node -p &lt;data_LIF_IP&gt; -login`</block>
  <block id="8bd830b1ea0595874b57cfd34c877123" category="paragraph">`sudo systemctl enable iscsi` `sudo systemctl start iscsi`</block>
  <block id="e6693412ed2252a87ece3f264fb334ed" category="paragraph">`sUdo tee /etc/multipath.conf &lt;&lt;-'EOF' defaults ｛ user_friendly_names yes find_multipaths yes ｝ eOF sudo service multipath-tools restart`</block>
  <block id="0d29eaa34aa7badaae0d49b35a2a0d12" category="paragraph">`sudo service open-iscsi start sudo service multipath-tools start`</block>
  <block id="0e9e734e557a02db30a20e5ac259cfb9" category="summary">每个存储驱动程序都有一组不同的选项，您可以在创建卷时指定这些选项来自定义结果。有关适用于您配置的存储系统的选项，请参见以下内容。</block>
  <block id="11e1b165c1d718d825f4bb9aaf0b884e" category="doc">驱动程序专用的卷选项</block>
  <block id="bca0712c590c8d3c228bf1044aed730b" category="paragraph">在卷创建操作期间使用这些选项非常简单。在命令行界面操作期间，使用 ` -o` 运算符提供选项和值。这些参数将覆盖 JSON 配置文件中的任何等效值。</block>
  <block id="6021d91bdededf94b8ae37c30e820118" category="section-title">ONTAP 卷选项</block>
  <block id="16dc9caa069072a49db7ea7c81a7cf66" category="paragraph">NFS 和 iSCSI 的卷创建选项包括以下内容：</block>
  <block id="054b4f3ea543c990f6b125f41af6ebf7" category="cell">选项</block>
  <block id="d3a07c97b6050b305c7dda0aea1657be" category="paragraph">卷的大小默认为 1 GiB 。</block>
  <block id="69e8c7b4f73d39cea9948875813f7ddd" category="paragraph">精简或厚配置卷，默认为精简。有效值为 `none` （精简配置）和 `volume` （厚配置）。</block>
  <block id="91853d7e2338a1395280185fc93d4650" category="paragraph">此操作会将 Snapshot 策略设置为所需的值。默认值为 `none` ，表示不会自动为卷创建快照。除非存储管理员修改，否则所有 ONTAP 系统上都存在一个名为 "defaultion" 的策略，该策略会创建并保留六个每小时快照，两个每日快照和两个每周快照。通过浏览到卷中任意目录中的 ` .snapshot` 目录，可以恢复快照中保留的数据。</block>
  <block id="b8a0fde33bd7662b7b9cb4158f04ef52" category="paragraph">此操作会将快照预留设置为所需百分比。默认值为 no 值，这意味着如果您选择了 snapshotPolicy ， ONTAP 将选择 snapshotReserve （通常为 5% ）；如果 snapshotPolicy 为 none ，则选择 0% 。您可以在配置文件中为所有 ONTAP 后端设置默认 snapshotReserve 值，并可将其用作除 ontap-nas-economy. 以外的所有 ONTAP 后端的卷创建选项。</block>
  <block id="0625856b9dc58db03a6e2c49b1f029e3" category="paragraph">克隆卷时，此操作将使发生原因 ONTAP 立即从其父卷拆分克隆。默认值为 `false` 。在克隆卷的某些使用情形中，最好在创建后立即将克隆从其父卷中拆分，因为不太可能有任何提高存储效率的机会。例如，克隆空数据库可以节省大量时间，但节省的存储很少，因此最好立即拆分克隆。</block>
  <block id="be94792f601f829d9b2be22553c6bf31" category="paragraph">这将在新卷上启用 NetApp 卷加密（ NVE ），默认为 `false` 。要使用此选项，必须在集群上获得 NVE 的许可并启用 NVE 。</block>
  <block id="cdaf246fba737b75127faa65456baa30" category="paragraph">设置要用于卷的分层策略。这将决定数据在变为非活动状态（冷）时是否移至云层。</block>
  <block id="1c46d85ab16f6b373409ad15260b1b0a" category="paragraph">以下附加选项适用于 NFS * 仅 * ：</block>
  <block id="ce46e8f3fc6eaddbe03115e0d62090ac" category="cell">`unixPermissions`</block>
  <block id="b145a4acc7a577d843f538580013776b" category="paragraph">此选项用于控制为卷本身设置的权限。默认情况下，权限将设置为 `` -rwrxr-xr-x` ，或以数字表示法 0755 表示，并且 `root` 将为所有者。文本或数字格式均可使用。</block>
  <block id="76a4004d727b54162f2e0542094a89a3" category="paragraph">将此值设置为 `true` 将使访问卷的客户端能够看到 ` 。 snapshot` 目录。默认值为 `false` ，这意味着默认情况下禁用 ` .snapshot` 目录的可见性。当 ` .snapshot` 目录可见时，某些映像（例如官方 MySQL 映像）无法按预期运行。</block>
  <block id="e59001176f4360988f5d774a8405b4b9" category="cell">`exportPolicy`</block>
  <block id="700d608597316c75fc869190f51cff49" category="paragraph">设置要用于卷的导出策略。默认值为 `default` 。</block>
  <block id="6b068a846d408b1d9ccd2c7220326b9d" category="paragraph">设置用于访问卷的安全模式。默认值为 `UNIX` 。有效值为 `UNIX` 和 `mi 已加传真` 。</block>
  <block id="842aac52866a44b40a5733ce352cf6df" category="paragraph">以下附加选项适用于 iSCSI * 仅 * ：</block>
  <block id="3184b1a9846944fabb00496c4b6b613a" category="cell">`fileSystemType`</block>
  <block id="56efcdcb9168adcb146b4d86bf55e99d" category="cell">设置用于格式化 iSCSI 卷的文件系统。默认值为 `ext4` 。有效值为 `ext3` ， `ext4` 和 `xfs` 。</block>
  <block id="79686ba706c992e7385f0c5b28be8294" category="cell">如果将此值设置为 `false` ，则会关闭 LUN 的空间分配功能。默认值为 `true` ，表示当卷空间用尽且卷中的 LUN 无法接受写入时， ONTAP 会通知主机。此选项还允许 ONTAP 在主机删除数据时自动回收空间。</block>
  <block id="ff7c0fcd6a31e735a61c001f75426961" category="section-title">示例</block>
  <block id="9e6d454a094b92b0132e48d2369debf5" category="paragraph">请参见以下示例：</block>
  <block id="be1e1c94a5fc3bb66c2ae9425eeefbdb" category="list-text">创建 10 GiB 卷：</block>
  <block id="a6490f19f59ecd8e4ed8634990ea366c" category="list-text">创建具有快照的 100GiB 卷：</block>
  <block id="297d0d2fcc555e5037c8d251daf5a620" category="list-text">创建启用了 setuid 位的卷：</block>
  <block id="6e31a0481f4f7e423abcde0bf31025c8" category="paragraph">最小卷大小为 20MiB 。</block>
  <block id="a65684b0a191599ad968126dd65f2e9d" category="paragraph">如果未指定快照预留且快照策略为 `none` ，则 Trident 将使用 0% 的快照预留。</block>
  <block id="8c05fd71822bf85c290cef86db959f68" category="list-text">创建无快照策略且无快照预留的卷：</block>
  <block id="d15d662af6e4417b0b7c134a84ed577c" category="list-text">创建一个无快照策略且自定义快照预留为 10% 的卷：</block>
  <block id="52a56a468f11c3298931c8e32c938e15" category="list-text">创建具有快照策略和 10% 自定义快照预留的卷：</block>
  <block id="0a77fdb1c16069c98ebe6510137af9d2" category="list-text">使用快照策略创建卷，并接受 ONTAP 的默认快照预留（通常为 5% ）：</block>
  <block id="f6f813eaaff2b296a27b6bf051485d2b" category="section-title">Element 软件卷选项</block>
  <block id="a514753df071ac540af065b659d1c65c" category="paragraph">Element 软件选项会显示与卷关联的大小和服务质量（ QoS ）策略。创建卷时，将使用 ` -o type=service_level` 命名空间指定与其关联的 QoS 策略。</block>
  <block id="f201e088f13d93e3d12b3c0ef78dece3" category="paragraph">使用 Element 驱动程序定义 QoS 服务级别的第一步是至少创建一种类型，并指定与配置文件中的名称关联的最小，最大和突发 IOPS 。</block>
  <block id="5cb7e4a4b6a51af0b5b09cb230b83422" category="paragraph">其他 Element 软件卷创建选项包括：</block>
  <block id="8730c4572b866ffc01a4aefebc896555" category="paragraph">卷的大小，默认为 1GiB 或配置条目 ... " 默认值 " ： ｛ "size" ： "5c" ｝ 。</block>
  <block id="d52146098b8ecd83b888289a86e26d19" category="cell">`块大小`</block>
  <block id="348ef18ccca06aa29547bd9ad87beebe" category="paragraph">使用 512 或 4096 ，默认为 512 或配置条目 DefaultBlockSize 。</block>
  <block id="1daf1c12549d6d3ae75c4d8d5f59d532" category="paragraph">请参见以下包含 QoS 定义的示例配置文件：</block>
  <block id="7afe0c73e341cee7c90b4d4dda4600d9" category="paragraph">在上述配置中，我们有三个策略定义：铜牌，银牌和金牌。这些名称是任意的。</block>
  <block id="cb5b68dacb07bd02a5152bf4ad1de8c6" category="list-text">创建 10 GiB 黄金卷：</block>
  <block id="89014c611c13195dc852587ef9d2bb16" category="list-text">创建 100GiB 铜牌卷：</block>
  <block id="7f65aa9497b5352a28e3eed539643ea7" category="section-title">AWS 卷选项上的 Cloud Volumes Service （ CVS ）</block>
  <block id="97f74fbb7a82eb99b7ea43017c0bfbe2" category="paragraph">AWS 上的 CVS 驱动程序的卷创建选项包括以下内容：</block>
  <block id="742a301c15fea3569e5059520217090e" category="paragraph">卷的大小默认为 100 GB 。</block>
  <block id="326ea14a491277cac4032c7b6413a545" category="paragraph">卷的 CVS 服务级别默认为标准。有效值包括标准，高级和极高。</block>
  <block id="a6b420fe5da257523d2105e9aae9fbc1" category="paragraph">`此操作会将快照预留设置为所需百分比。默认值为 no 值，表示 CVS 将选择快照预留（通常为 0% ）。</block>
  <block id="fe0bb617c9579d2f1d51ca5a627839fb" category="list-text">创建 200 GiB 卷：</block>
  <block id="6f5c2d108fc1cf862350561160c4ecac" category="list-text">创建一个 500 GiB 高级卷：</block>
  <block id="84e002f675928fb7347e346a6214eefc" category="paragraph">最小卷大小为 100 GB 。</block>
  <block id="c3fa12e6fe179aa6330774fb658371a5" category="section-title">GCP 上的 CVS 卷选项</block>
  <block id="c112845976cf3ccb7ec927bea467b805" category="paragraph">基于 GCP 的 CVS 驱动程序的卷创建选项包括以下内容：</block>
  <block id="3d9999cfb7d197cd40ffb0d665cf46a6" category="paragraph">卷的大小，默认情况下， CVS-Performance 卷为 100 GiB ， CVS 卷为 300 GiB 。</block>
  <block id="256a798c267200d8cfa583eecaa2cc31" category="paragraph">此操作会将快照预留设置为所需百分比。默认值为 no 值，表示 CVS 将选择快照预留（通常为 0% ）。</block>
  <block id="4e984a8dd0f1e9f166c162b4c01da5d2" category="list-text">创建 2 TiB 卷：</block>
  <block id="39407360e3929c32bb19c04cf3549d2e" category="list-text">创建 5 TiB 高级卷：</block>
  <block id="077eacce80395f222c5785ca68ffe958" category="paragraph">对于 CVS-Performance 卷，最小卷大小为 100 GiB ，对于 CVS 卷，最小卷大小为 300 GiB 。</block>
  <block id="05891dbb3b7306197f5cd0da8f1768ef" category="section-title">Azure NetApp Files 卷选项</block>
  <block id="bda1cf59d924de8c8c73a8b619aace9c" category="paragraph">Azure NetApp Files 驱动程序的卷创建选项包括：</block>
  <block id="fc96768681dcf6770119445ffe2537cd" category="summary">要创建卷，请根据需要使用标准的 `docker volume` 命令以及指定的 Astra Trident 驱动程序名称。</block>
  <block id="feabbbf9b5afb31194daf0d8e3ff75dc" category="doc">使用卷</block>
  <block id="00e5ed77f92b42f144be7dfb7106bf10" category="paragraph">您可以根据需要使用标准的 `docker volume` 命令以及指定的 Astra Trident 驱动程序名称轻松创建，克隆和删除卷。</block>
  <block id="dc88dce8ec264777b2f90ec0af744f43" category="section-title">创建卷</block>
  <block id="a32b09b1335e0afbb640a9412690680d" category="list-text">使用默认名称创建包含驱动程序的卷：</block>
  <block id="8b5708fe1297b9ca8b3be5b99bf29407" category="list-text">使用特定的 Astra Trident 实例创建卷：</block>
  <block id="93da65a9fd0004d9477aeac024e08e15" category="inline-link-macro">选项</block>
  <block id="593e5c95e1adc19e8d81719c16b57bc1" category="admonition">如果未指定任何 <block ref="3a0a40f90bfa29e0eb23418c553e5ef5" category="inline-link-macro-rx"></block>，将使用驱动程序的默认值。</block>
  <block id="1e1e2461d5dfd51f1ebd0eadcba142f4" category="list-text">覆盖默认卷大小。要使用驱动程序创建 20GiB 卷，请参见以下示例：</block>
  <block id="5149eec9d959a54cf392efaa710541d1" category="admonition">卷大小以字符串表示，该字符串包含一个包含可选单元的整数值（例如： 10 G ， 20 GB ， 3 TiB ）。如果未指定单位，则默认值为 G大小单位可以表示为 2 的幂（ B ， KiB ， MIB ， GiB ， TiB ）或 10 的幂（ B ， KB ， MB ， GB ， TB ）。速率单位使用 2 的电流（ G = GiB ， T = TiB ，…）。</block>
  <block id="9bc129eac7adf7ea5d8ed1c021fab2dc" category="section-title">删除卷</block>
  <block id="281a0f40363a276c6ec125244c784112" category="list-text">像删除任何其他 Docker 卷一样删除此卷：</block>
  <block id="7959e3701f7a7fba7713c7530d496324" category="admonition">使用 `solidfire-san` 驱动程序时，上述示例将删除并清除卷。</block>
  <block id="5a1345d94751fc14bedf8f6f5e77a0ff" category="paragraph">执行以下步骤以升级适用于 Docker 的 Astra Trident 。</block>
  <block id="d50044469c0bf9ab38eff9cf7243fb25" category="section-title">克隆卷</block>
  <block id="d9bab73e26d2aaa2f602f32954ab9cd7" category="paragraph">使用 `ontap-nas` ， `ontap-san` ， `solidfire-san` ， `AWS-CVS` 和 `GCP-CVS 存储驱动程序` 时， Astra Trident 可以克隆卷。使用 `ontap-nas-flexgroup` 或 `ontap-nas-economy-经济` 驱动程序时，不支持克隆。从现有卷创建新卷将创建新快照。</block>
  <block id="9374b766b9dd78063440afd69afabf38" category="list-text">检查卷以枚举快照：</block>
  <block id="2747096689037792fa87de7a0e8440e2" category="list-text">从现有卷创建新卷。这将导致创建新快照：</block>
  <block id="31d9b5ed201aa44dbeae6d17d38c0c6f" category="list-text">从卷上的现有快照创建新卷。此操作不会创建新快照：</block>
  <block id="516b30a46da41c6969cb7249d6567905" category="section-title">访问外部创建的卷</block>
  <block id="d8c20bb137be94fec8295c3fc5175b54" category="paragraph">如果容器没有分区，并且 Astra Trident 支持其文件系统（例如： A `ext4` 格式的 ` /dev/sdc1` 将无法通过 Astra Trident 访问），则可以使用 Trident * only * 通过容器访问外部创建的块设备（或其克隆）。</block>
  <block id="4cfa22b281cbd36e1a275d61ec23a9b4" category="summary">您可以收集日志以帮助进行故障排除。收集日志的方法因运行 Docker 插件的方式而异。</block>
  <block id="fe1786b49549e8e06a89b9c57d7fc514" category="doc">收集日志</block>
  <block id="83f4d02d2dd31f09291e098bf4ae502b" category="list-text">如果您使用建议的受管插件方法（例如，使用 `docker plugin` 命令）运行 Astra Trident ，请按如下所示查看它们：</block>
  <block id="17c40798131b12188d43b1a90dabfc69" category="paragraph">标准日志记录级别应允许您诊断大多数问题。如果您发现这还不够，则可以启用调试日志记录。</block>
  <block id="c28722abec5c1daefa02916119bbff91" category="list-text">要启用调试日志记录，请安装启用了调试日志记录的插件：</block>
  <block id="b142025dd533fb27bf7df1a93c55e311" category="paragraph">或者，在已安装插件的情况下启用调试日志记录：</block>
  <block id="98e6888e14bd8bcd734870a8331ca6ea" category="list-text">如果在主机上运行二进制文件本身，则日志可从主机的 ` /var/log/netappdvp` 目录中获取。要启用调试日志记录，请在运行插件时指定 ` -debug` 。</block>
  <block id="2aa0797ce5da04d1c6f027c9b3276483" category="section-title">一般故障排除提示</block>
  <block id="94d799ff06bdb0aedb7b64151dac73d7" category="list-text">新用户遇到的最常见问题是配置不当，导致插件无法初始化。如果发生这种情况，在尝试安装或启用插件时，您可能会看到如下消息：</block>
  <block id="fe6b4529e706ebc0f7e3668d3230d029" category="paragraph">`守护进程的错误响应：拨打 unix /run/docker/plugins/&lt;id&gt;/netapp.sock ： connect ： no such file or directory`</block>
  <block id="3d924bd43304301ed127cbbd303a4fa6" category="paragraph">这意味着插件无法启动。幸运的是，该插件已构建了全面的日志记录功能，可以帮助您诊断可能遇到的大多数问题。</block>
  <block id="79c820c2d64495c47651e58e73f97294" category="list-text">如果在将 PV 挂载到容器时出现问题，请确保 `rpcbind` 已安装并正在运行。对主机操作系统使用所需的软件包管理器，并检查 `rpcbind` 是否正在运行。您可以通过运行 `systemctl status rpcbind` 或其等效项来检查 rpcbind 服务的状态。</block>
  <block id="2358ca3eef46b0e25466e80dbea7ea4b" category="summary">请参见适用于您的 Astra Trident 配置的配置选项。</block>
  <block id="34e1f7eb303c0a150cd440611b3b5e24" category="doc">存储配置选项</block>
  <block id="51f834b47bcd78a0f4f40fd8ca40446f" category="section-title">全局配置选项</block>
  <block id="b22d82aea9557ba6aa7b915d40309d9b" category="paragraph">这些配置选项适用于所有 Astra Trident 配置，而不考虑所使用的存储平台。</block>
  <block id="63b276a6c28274ed5e553d4ce3fe7eb1" category="paragraph">配置文件版本号</block>
  <block id="c4ca4238a0b923820dcc509a6f75849b" category="paragraph">1.</block>
  <block id="ac5eb8fcbd1ed9c85a98d91e10e26a38" category="paragraph">存储驱动程序的名称</block>
  <block id="86561da64fcea64abfe5587158ea1c15" category="paragraph">`ontap-nas` ， `ontap-san` ， `ontap-nas-economics` ， `ontap-nas-flexgroup` ， `solidfire-san` ， `azure-netapp-files` ， `AWS-CVS` 或 `GCP-CVS`</block>
  <block id="3f2b20ce3aa5e39b0dbfe20326747a7b" category="paragraph">卷名称的可选前缀。默认值： "netappdvp_ " 。</block>
  <block id="46fa46eed970046d03e2dedc95cdc83b" category="paragraph">暂存 _</block>
  <block id="fcf783284187f1e80e772eacd9266ee1" category="paragraph">卷大小的可选限制。默认值： " " （未强制实施）</block>
  <block id="75da9d6de91e782eca4fa00341367135" category="paragraph">10 G</block>
  <block id="3eed2a7dac1f2329f3a9574a68e5e1c4" category="admonition">请勿对元素后端使用 `storagePrefix` （包括默认值）。默认情况下， `solidfire-san` 驱动程序将忽略此设置，而不使用前缀。我们建议使用特定的租户 ID 进行 Docker 卷映射，或者在可能已使用任何名称的情况下使用 Docker 中填充的 Docker 版本，驱动程序信息和原始名称的属性数据。</block>
  <block id="0863f9e97e159e3ea1ce46bdb49b1254" category="paragraph">您可以使用默认选项来避免在创建的每个卷上指定这些选项。`s` 选项适用于所有控制器类型。有关如何设置默认卷大小的示例，请参见 ONTAP 配置一节。</block>
  <block id="41ad23e0468b5a035cae097ac8b28bb9" category="paragraph">新卷的可选默认大小。默认值： "1G"</block>
  <block id="08aa1584c9a5791fb64b0f7f1453f9eb" category="paragraph">10 G</block>
  <block id="0353522b39b87d54d40d3f09ec668851" category="section-title">ONTAP 配置</block>
  <block id="cd536bce1bed61366e8d17a85fe6678a" category="paragraph">除了上述全局配置值之外，在使用 ONTAP 时，还可以使用以下顶级选项。</block>
  <block id="464779f3491153dd1e79ddbd8a81e3f0" category="paragraph">ONTAP 管理 LIF 的 IP 地址。您可以指定完全限定域名（ FQDN ）。</block>
  <block id="190dafab69706a67221c1226360de7dc" category="paragraph">10.0.0.1</block>
  <block id="bfdeb0e1ca992a3dcb6853265e453e21" category="paragraph">协议 LIF 的 IP 地址；如果未指定，则派生此地址。对于 `ontap-NAS` 驱动程序 * 仅 * ，您可以指定 FQDN ，在这种情况下， FQDN 将用于 NFS 挂载操作。对于 `ontap-san` 驱动程序，默认使用 SVM 中的所有数据 LIF IP 并使用 iSCSI 多路径。为 `ontap-san` 驱动程序指定 `dataLIF` 的 IP 地址会强制驱动程序禁用多路径并仅使用指定的地址。</block>
  <block id="98a2cd7efa1ba950d42e42af495c4248" category="paragraph">10.0.0.2</block>
  <block id="11053eb2b6ac6e8802c67c054cf55ad9" category="paragraph">要使用的 Storage Virtual Machine （如果管理 LIF 为集群 LIF ，则为必填项）</block>
  <block id="b26399fddd6473c150b4e7528fb04fdc" category="paragraph">SVM_NFS</block>
  <block id="723a179bbb9fc3c4f12cf296a8841b27" category="paragraph">用于连接到存储设备的用户名</block>
  <block id="6173aa5206484b5224450952747c7148" category="paragraph">vsadmin</block>
  <block id="8cf10281cf3b9290d5988c57a7d19693" category="paragraph">用于连接到存储设备的密码</block>
  <block id="5ebe2294ecd0e0f08eab7690d2a6ee69" category="paragraph">机密</block>
  <block id="7e6d207f2b120c6cc9caa98510aa51c6" category="cell">`聚合`</block>
  <block id="ac53191a99c328660eafa4696375dbfb" category="paragraph">要配置的聚合（可选；如果设置了聚合，则必须将其分配给 SVM ）。对于 `ontap-nas-flexgroup` 驱动程序，此选项将被忽略。分配给 SVM 的所有聚合都用于配置 FlexGroup 卷。</block>
  <block id="70d2c7701d2837552c0a38c02a326592" category="paragraph">aggr1.</block>
  <block id="925060a0c0a15f99ef1bee43f1660ea4" category="paragraph">可选，如果使用量超过此百分比，则配置失败</block>
  <block id="f819de81247be4a5428dc0e169de28b8" category="paragraph">75%</block>
  <block id="876885770cf58d20ef5672cc5594e85d" category="inline-link">请参见此处的 NFS 主机配置信息</block>
  <block id="0a19ca3d1db7e5bc24b58f73b91c3f49" category="paragraph">对 NFS 挂载选项进行精细控制；默认为 -o nfsver=3 。* 仅适用于 `ontap-nas` 和 `ontap-nas- 经济` 驱动程序 * 。<block ref="71f7a3f48cfd3876cffba401813b7db0" category="inline-link-rx"></block>。</block>
  <block id="301c869c551e12d862ab0291837102a0" category="paragraph">-o nfsver=4</block>
  <block id="00d72747af4eb1f0bab120935efe88fe" category="paragraph">插件使用的 igroup ；默认为 "netappdvp " 。* 仅适用于 `ontap-san`driver* 。</block>
  <block id="79e762988462f6f8da9becfbfd789755" category="paragraph">myigroup</block>
  <block id="7f36667ac41e34035d815320145dcadb" category="cell">`limitVolumeSizee`</block>
  <block id="5c5adadf8175fd69d4af9bfdb608c42c" category="paragraph">可请求的最大卷大小和 qtree 父卷大小。* 对于 `ontap-nas-economy` 驱动程序，此选项还会限制其创建的 FlexVol 的大小 * 。</block>
  <block id="f07e606cfe25ac6fb07d9c4af941d9a2" category="paragraph">300 克</block>
  <block id="981ba910eb0ffc42f42059de056624b4" category="paragraph">每个 FlexVol 的最大 qtree 数必须在 50 ， 300 范围内，默认值为 200 。* 对于 `ontap-nas-economy` 驱动程序，此选项允许自定义每个 qtree* 的最大 FlexVol 数。</block>
  <block id="94f6d7e04a4d452035300f18b984988c" category="paragraph">300</block>
  <block id="3890063556e337d458019437f027030b" category="paragraph">您可以使用默认选项来避免在创建的每个卷上指定这些选项：</block>
  <block id="887ba6a0090fff5ace8889efb3b766af" category="paragraph">空间预留模式； " 无 " （精简配置）或 " 卷 " （厚）</block>
  <block id="334c4a4c42fdb79d7ebc3e73b517e6f8" category="paragraph">无</block>
  <block id="b614ecafc9c9bbcd0206b519e5481f8d" category="paragraph">要使用的 Snapshot 策略，默认值为 " 无 "</block>
  <block id="e35ead0e9e7038a6c58695bfa4741686" category="paragraph">Snapshot 预留百分比，默认值为 " " 以接受 ONTAP 的默认值</block>
  <block id="d3d9446802a44259755d38e6d163e820" category="paragraph">10</block>
  <block id="eb28cb6308c229ba4561cf02d78b9a07" category="paragraph">创建克隆时将其从父级拆分，默认为 "false"</block>
  <block id="988726bbf32c455be56acbfb0da3aad0" category="paragraph">启用 NetApp 卷加密，默认为 "false"</block>
  <block id="b326b5062b2f0e69046810717534cb09" category="paragraph">true</block>
  <block id="a3b703e23c8d0caf2b2fb4f46057013b" category="paragraph">已配置 NFS 卷的 NAS 选项，默认为 "777"</block>
  <block id="f1c1592588411002af340cbaedd6fc33" category="paragraph">777.</block>
  <block id="525eba0ced0a1c122a9112c4d10fbdc2" category="paragraph">用于访问 ` .snapshot` 目录的 NAS 选项，默认为 "false"</block>
  <block id="b60dd25e9d373b87424c30a74da2703f" category="paragraph">要使用的 NFS 导出策略的 NAS 选项，默认为 " 默认 "</block>
  <block id="c21f969b5f03d33d43e04f8f136e7682" category="paragraph">default</block>
  <block id="af6bd5b29a0589f7c6a47f47fae230c7" category="paragraph">用于访问已配置 NFS 卷的 NAS 选项，默认为 "UNIX"</block>
  <block id="1d770934d44de09b0d24f04fd01708ba" category="paragraph">混合</block>
  <block id="79c6531f572824f3178c8b1fb0f35d26" category="paragraph">SAN 选项要选择文件系统类型，默认为 "ext4"</block>
  <block id="310201b6353c5f38bc039e0e51b079d3" category="paragraph">XFS</block>
  <block id="3cec6d01b4f10a61939982ecfb47fc7f" category="paragraph">要使用的分层策略，对于 ONTAP 9.5 SVM-DR 之前的配置，默认为 " 无 " ； " 仅快照 "</block>
  <block id="90adf331b7868c7af46ad6e035e93844" category="section-title">扩展选项</block>
  <block id="493a6606c4789fad3c7317b99cb563d0" category="paragraph">`ontap-nas` 和 `ontap-san` 驱动程序会为每个 Docker 卷创建一个 ONTAP FlexVol 。对于每个集群节点， ONTAP 最多支持 1000 个 FlexVol ，而集群最多支持 12 ， 000 个 FlexVol 。如果您的 Docker 卷要求符合此限制，则由于 Flexvol 提供的其他功能（例如 Docker 卷粒度快照和克隆）， `ontap-NAS` 驱动程序是首选的 NAS 解决方案。</block>
  <block id="b8f30e4086b754ccaf7bd5d01d8df137" category="paragraph">如果所需的 Docker 卷数超出 FlexVol 限制所能容纳的范围，请选择 `ontap-nas-economy"` 或 `ontap-san-economy"` 驱动程序。</block>
  <block id="50710f3a4715e3f874848944b6b54e28" category="paragraph">`ontap-nas-economy` 驱动程序可在自动管理的 ONTAP 卷池中创建 Docker 卷作为 qtree 。qtree 的扩展能力远高于此，每个集群节点最多可扩展 100 ， 000 个，每个集群最多可扩展 2 ， 400 ， 000 个，但某些功能会受到影响。`ontap-nas-economy` 驱动程序不支持 Docker 卷粒度快照或克隆。</block>
  <block id="0c8b91c6c2ba9c892f3eea2cd9c86cd1" category="admonition">Docker Swarm 目前不支持 `ontap-nas-economy-经济` 驱动程序，因为 Swarm 不会在多个节点之间协调卷创建。</block>
  <block id="5849dbe631db5b1e1b365f9f2f84ff60" category="paragraph">`ontap-san-economy-driver` 可在一个由自动管理的 FlexVol 构成的共享池中将 Docker 卷创建为 ONTAP LUN 。这样，每个 FlexVol 就不会仅限于一个 LUN ，并且可以为 SAN 工作负载提供更好的可扩展性。根据存储阵列的不同， ONTAP 每个集群最多支持 16384 个 LUN 。由于卷是下面的 LUN ，因此此驱动程序支持 Docker 卷粒度快照和克隆。</block>
  <block id="65e92c8f7fa9750b795cc1046328cf06" category="paragraph">选择 `ontap-nas-flexgroup` 驱动程序可将并行性提高到单个卷，该卷可以扩展到包含数十亿个文件的 PB 范围。FlexGroup 的一些理想用例包括 AI/ML/DL ，大数据和分析，软件构建，流式传输，文件存储库等。配置 FlexGroup 卷时， Trident 会使用分配给 SVM 的所有聚合。Trident 中的 FlexGroup 支持还需要注意以下事项：</block>
  <block id="9d83b6d2e2b099e63bf8e2fc8c870893" category="list-text">需要 ONTAP 9.2 或更高版本。</block>
  <block id="e7c74973b26ad51b9db42a9c347a8cd4" category="list-text">截至本文撰写时， FlexGroup 仅支持 NFS v3 。</block>
  <block id="02a100b04add3b90fddef64499e825a2" category="list-text">建议为 SVM 启用 64 位 NFSv3 标识符。</block>
  <block id="496f8625569b787269edab0f3de973da" category="list-text">建议的最小 FlexGroup 大小为 100 GB 。</block>
  <block id="db78b2a7acf43fa03cd95fb3a77c82f9" category="list-text">FlexGroup 卷不支持克隆。</block>
  <block id="f5ac1e3c252855373c7f660dbd89699d" category="inline-link">《 NetApp FlexGroup 卷最佳实践和实施指南》</block>
  <block id="df1a7e79743809601db1d20d6a33ae52" category="paragraph">有关适用于 FlexGroup 的 FlexGroup 和工作负载的信息，请参见<block ref="b8a99695d7979127a1cab07b42e22743" category="inline-link-rx"></block>。</block>
  <block id="b30b6b60171d85877ea91897bdd6faed" category="paragraph">要在同一环境中获得高级功能并实现大规模扩展，您可以运行多个 Docker 卷插件实例，其中一个使用 `ontap-NAS` ，另一` 个使用 `ontap-nas-economy.</block>
  <block id="0c0f6724044ed44fb85d2ce3193cb7c3" category="section-title">ONTAP 配置文件示例</block>
  <block id="9420b5e8ed08a163eeafb1d5026f74be" category="paragraph">`ontap-nas` driver* 的 * NFS 示例</block>
  <block id="c26e7b2e60e156979940cd72ed83d0b9" category="paragraph">`ontap-nas-flexgroup` driver* 的 * NFS 示例</block>
  <block id="3a57e82fd5f9855754a03019c433aff7" category="paragraph">`ontap-nas-economy` driver* 的 * NFS 示例</block>
  <block id="2bfad97b56e71c619e45f6d4c2e4c2e2" category="paragraph">`ontap-san` driver* 的 * iSCSI 示例</block>
  <block id="98f803effb81ad687bcd941b70439aaa" category="paragraph">`ontap-san-economy-driver` 的 * NFS 示例</block>
  <block id="ffe54c343031d16e77db73e2d950e277" category="section-title">Element 软件配置</block>
  <block id="3afcd136a7bffa20fc39ba6581412cd2" category="paragraph">除了全局配置值之外，在使用 Element 软件（ NetApp HCI/SolidFire ）时，还可以使用这些选项。</block>
  <block id="6f8cfcd7221d73b0e27985966dfd6e1f" category="paragraph"><block ref="608956a9224818c204ba64e5dd4b5f0c" category="inline-link-rx"></block></block>
  <block id="501aa777bd36217575e7547e7fed62cb" category="paragraph"><block ref="501aa777bd36217575e7547e7fed62cb" category="inline-link-rx"></block></block>
  <block id="c61f15977fe4efa0866eea87fb740cda" category="paragraph">iSCSI IP 地址和端口</block>
  <block id="6a6b63874c664c103982f6d422c6384e" category="paragraph">10.0.0.7 ： 3260</block>
  <block id="72deb2676231ab8e068ef60dd89edd4c" category="paragraph">要使用的 SolidFireF 租户（如果未找到，则创建）</block>
  <block id="5eda5112bf8affeb1d2cd8eea6302076" category="paragraph">Docker</block>
  <block id="d2672389886b173aef703433f7e4b89b" category="paragraph">将 iSCSI 流量限制为非默认接口时，请指定接口</block>
  <block id="5935dcd024929bc7086bb230802bf576" category="paragraph">请参见以下示例</block>
  <block id="5e9bf55f849ccc5a31a50d1fa784d28c" category="cell">`LegendPrefix`</block>
  <block id="db7adc3775b0b56c59ce4263fbd79fbf" category="paragraph">升级后的 Trident 安装的前缀。如果您使用的是 1.3.2 之前的 Trident 版本并对现有卷执行升级，则需要设置此值才能访问通过 volume-name 方法映射的旧卷。</block>
  <block id="8d3aa50a0f9c3c059677927a3fbbfcda" category="paragraph">"netappdvp- "</block>
  <block id="36f9c7b615268efec7f4c56c387a55bb" category="paragraph">`solidfire-san` 驱动程序不支持 Docker Swarm 。</block>
  <block id="1059bb8540c48e6b455e802384bad65d" category="section-title">Element 软件配置文件示例</block>
  <block id="8898f8d83fe6ae40ee889ae1b53dd2a1" category="section-title">AWS 上的 Cloud Volumes Service （ CVS ）配置</block>
  <block id="51a61fe7c333c9b247fa4a36f100af60" category="paragraph">在 AWS 上使用 CVS 时，除了全局配置值之外，还可以使用这些选项。所有必需值均可在 CVS Web 用户界面中使用。</block>
  <block id="87cb49c3ba3ad2b7881daec6cbe2c058" category="paragraph">CVS 帐户区域（必需）。可以在 CVS Web 门户中的 "Account settings" &gt;"API access" 中找到。</block>
  <block id="ab62ad1f18caedc5173216159619af30" category="paragraph">"us-east-1"</block>
  <block id="72bb1da9c467950d42f276dd60372f9d" category="paragraph">CVS 帐户 API URL （必需）。可以在 CVS Web 门户中的 "Account settings" &gt;"API access" 中找到。</block>
  <block id="90ecc3761b44b9c5f99193048d67b991" category="paragraph">https://cds-aws-bundles.netapp.com:8080/v1”</block>
  <block id="14d4df12da21ca887a11026db7d26c5a" category="paragraph">CVS 帐户 API 密钥（必需）。可以在 CVS Web 门户中的 "Account settings" &gt;"API access" 中找到。</block>
  <block id="49df949d63ad2fe5a679bea21beb739f" category="paragraph">CVS 帐户密钥（必需）。可以在 CVS Web 门户中的 "Account settings" &gt;"API access" 中找到。</block>
  <block id="eccfbdf9565fdb1f0b53121d07c0ca4d" category="paragraph">代理服务器需要连接到 CVS 帐户时的代理 URL 。代理服务器可以是 HTTP 代理，也可以是 HTTPS 代理。对于 HTTPS 代理，系统会跳过证书验证，以允许在代理服务器中使用自签名证书。* 不支持已启用身份验证的代理服务器 * 。</block>
  <block id="58b40a255bdd79778c81b51b0189d3bc" category="paragraph">http://proxy-server-hostname/”</block>
  <block id="1fc4f89077ac8f740a8209cb13dad780" category="paragraph">NFS 挂载选项；默认为 -o nfsver=3</block>
  <block id="c0c057b1fbdbb4b3fbff5af024800013" category="paragraph">"nfsver=3 ， proto=tcp ， timeo=600"</block>
  <block id="989640232ebd1cee1600241dcaf3092b" category="paragraph">性能级别（标准，高级，极高），默认为 " 标准 "</block>
  <block id="6dc6830d3f5eeef9925e20cb2872face" category="paragraph">高级版</block>
  <block id="4c4783b692750885787114cffe439cc4" category="admonition">NetApp Cloud Volumes Service for AWS 不支持小于 100 GB 的卷。为了便于部署应用程序，如果请求的卷较小， Trident 会自动创建 100 GB 的卷。</block>
  <block id="2141207c4b192cfda3ca9862d3051c75" category="paragraph">在 AWS 上使用 CVS 时，可以使用这些默认卷选项设置。</block>
  <block id="0b4473f186b60c3a658cb10df719e6e7" category="paragraph">NFS 访问列表（地址和 / 或 CIDR 子网），默认为 "0.0.0.0/0 "</block>
  <block id="4fd06576654815d69b61384ef4f9e084" category="paragraph">"10.0.1.0/24 10.0.0.2.100"</block>
  <block id="6cac9fafaf62c70b75f827e614328121" category="paragraph">Snapshot 预留百分比，默认值为 " " 以接受 CVS 默认值 0</block>
  <block id="c669350437225628cf4fcc3d0ec9d8f6" category="paragraph">10</block>
  <block id="24e52229704d0addd6cb9915c2e78093" category="paragraph">卷大小，默认为 100 GB</block>
  <block id="36a1049642c95770e66c6905f890a00a" category="paragraph">"500 克 "</block>
  <block id="f0fe7c79add8387e161dd776e6af2313" category="section-title">AWS 上的 CVS 配置文件示例</block>
  <block id="4c4a4e3967b80166b1c89a42bb702c5c" category="section-title">GCP 配置上的 Cloud Volumes Service （ CVS ）</block>
  <block id="c731f72e1d22a7c5e01a7cb789a8885e" category="inline-link">GCP</block>
  <block id="16aba044aae8d4a1f104875fadfa8b7a" category="paragraph">Trident 现在支持使用默认 CVS 服务类型的较小卷<block ref="ba449b67e05ccd893d094c64611dfdac" category="inline-link-rx"></block>。对于使用 `storageClass=software` 创建的后端，卷的最小配置大小将为 300 GiB 。* NetApp 建议客户将低于 1 TiB 的卷用于非生产工作负载 * 。CVS 目前在 " 受控可用性 " 下提供此功能，不提供技术支持。</block>
  <block id="6d43083e1ac79c6ae1d612b064c50415" category="admonition">注册以访问低于 1TiB 的卷<block ref="daab940ca038632df7b3bcdb2ce67b4b" category="inline-link-rx"></block>。</block>
  <block id="13c75fbfea8d654533aa97741ee726eb" category="admonition">使用默认 CVS 服务类型 `storageClass=software` 部署后端时，您应获得 GCP 上有关项目编号和项目 ID 的子 1TiB 卷功能的访问权限。这对于 Trident 配置低于 1TiB 的卷是必需的。否则，对于小于 600 GiB 的 PVC ，卷创建 * 将失败 * 。使用访问低于 1TiB 的卷<block ref="d5347d47b24e3303f1c7b0ae61e08dc7" category="inline-link-rx"></block>。</block>
  <block id="8a5a1d824b8678ed57f0b091512af961" category="paragraph">Trident 为默认 CVS 服务级别创建的卷将按以下方式进行配置：</block>
  <block id="17e388f76e4ab809d67d7da3f508f16e" category="list-text">小于 300 GiB 的 PVC 将导致 Trident 创建 300 GiB 的 CVS 卷。</block>
  <block id="c12c279867b9062aac25467988994298" category="list-text">如果 PVC 介于 300 GiB 到 600 GiB 之间，则 Trident 将创建一个请求大小的 CVS 卷。</block>
  <block id="4ff78214fe676a45289036b058361170" category="list-text">介于 600 GiB 和 1 TiB 之间的 PVC 将导致 Trident 创建 1 TiB CVS 卷。</block>
  <block id="de59c7ff95f1d72edb04ee0b3b70de27" category="list-text">如果 PVC 大于 1 TiB ，则 Trident 将创建一个请求大小的 CVS 卷。</block>
  <block id="49821db5dac692677dc0f49801db61dd" category="paragraph">除了全局配置值之外，在 GCP 上使用 CVS 时，还可以使用这些选项。</block>
  <block id="2ecba853d55bf844defef38593bfeddd" category="paragraph">CVS 帐户区域（必需）。是此后端将配置卷的 GCP 区域。</block>
  <block id="91730af327707bec713a5f18f6d8df6a" category="paragraph">"us-west2"</block>
  <block id="44242a2deef719f96982e82f0be8fc65" category="paragraph">GCP 项目编号（必需）。可以在 GCP Web 门户的主屏幕中找到。</block>
  <block id="d4445a55440abc4ee9235c02b46555b3" category="paragraph">"123456789012"</block>
  <block id="1a269fb3ec0496720ca75e984d8de40e" category="cell">`hostProjectNumber`</block>
  <block id="e34e53c32d906addf366532becb0dcd1" category="paragraph">GCP 共享 VPC 主机项目编号（如果使用共享 VPC ，则为必填项）</block>
  <block id="efd711f7b98e2f0003cbf70aa18a14c0" category="paragraph">"098765432109"</block>
  <block id="2c3fb314d5e72bbcae6b7a25d5b8edaa" category="paragraph">具有 CVS 管理员角色的 GCP 服务帐户的 API 密钥（必需）。是 GCP 服务帐户专用密钥文件的 JSON 格式内容（逐字复制到后端配置文件）。服务帐户必须具有 netappcloudvolumes.admin 角色。</block>
  <block id="6a17ea7b1fdab79ffd3eddf255aaf46d" category="paragraph">（私钥文件的内容）</block>
  <block id="1631dca111b8c1a922c7f29d48eb7121" category="cell">`网络`</block>
  <block id="bbf068b3542ca7b12963602ea10acbfa" category="paragraph">用于 CVS 卷的 GCP 网络，默认为 " 默认 "</block>
  <block id="69cd8c867e8af214f6e9c04138d56ff5" category="admonition">如果使用共享 VPC 网络，则应同时指定 `projectNumber` 和 `hostProjectNumber` 。在这种情况下， `projectNumber` 是服务项目， `hostProjectNumber` 是主机项目。</block>
  <block id="ac4650c60f6238dc7461aa20cf40d081" category="admonition">NetApp Cloud Volumes Service for GCP 不支持小于 100 GiB 的 CVS-Performance 卷或小于 300 GiB 的 CVS 卷。为了便于部署应用程序，如果请求的卷太小， Trident 会自动创建最小大小的卷。</block>
  <block id="0075471554ab0900a2a82a3481e9d1a2" category="paragraph">在 GCP 上使用 CVS 时，可以使用这些默认卷选项设置。</block>
  <block id="7946d615645dcc579e9f7d0ea1ab5dce" category="paragraph">卷大小，默认为 "100GiB"</block>
  <block id="6dd08dbe0437571ae84c751c0d9e7db2" category="paragraph">"10T"</block>
  <block id="14d7cea065a37d05840128a2193e5d0b" category="section-title">GCP 配置文件上的 CVS 示例</block>
  <block id="e303017ec184887efb9bebcc178d78c5" category="section-title">Azure NetApp Files 配置</block>
  <block id="83e44b4ce45c0f8e6a65a21d4dd12587" category="paragraph">配置和使用<block ref="24a785881ff1cdf191a2239811dc9597" category="inline-link-rx"></block> 后端，您需要满足以下要求：</block>
  <block id="3f72ed4087b557a1841662fa1eec0927" category="list-text">`ssubscriptionID` 来自启用了 Azure NetApp Files 的 Azure 订阅</block>
  <block id="8f2cfe6996e4a915299313c85a777630" category="list-text">`租户 ID` ， `clientID` 和 `clientSecret` 来自<block ref="8cf7d0e47908a64c9538530ae13f3b17" category="inline-link-rx"></block> 在 Azure Active Directory 中，具有足够的 Azure NetApp Files 服务权限</block>
  <block id="761f4d4786b8e1a6c65bf01f90ff17cd" category="list-text">至少包含一个的 Azure 位置<block ref="c5f14b2142014dc234282a513132bad4" category="inline-link-rx"></block></block>
  <block id="dc2194d6594556ab2ec2b961b22b55a9" category="admonition">如果您是首次使用 Azure NetApp Files 或在新位置使用，则需要对进行一些初始配置<block ref="03c0e2c26eabaafc3ff886c9295f214c" category="inline-link-rx"></block> 将引导您完成操作。</block>
  <block id="9fc00ac6b0164174fe95b39347777acf" category="paragraph">"azure-netapp-files"</block>
  <block id="150fed11d160cf3a20a84935a6da6b2f" category="paragraph">存储后端的自定义名称</block>
  <block id="8c6cd78048829f0726a268945284d717" category="paragraph">驱动程序名称 + "_" + 随机字符</block>
  <block id="2c07e9234f0df0d4c8887a04f7e641fe" category="paragraph">应用程序注册中的客户端 ID</block>
  <block id="f68b03078b004c148f3382adb3803512" category="paragraph">" 标准 " ， " 高级 " 或 " 超 " 之一</block>
  <block id="48483edc045345a516ed748c1964e3bf" category="paragraph">" （随机）</block>
  <block id="544e534f1aa0d97c48ccedd92fe2ba3d" category="paragraph">将在中创建新卷的 Azure 位置名称</block>
  <block id="64984096fbf22f0a2b49f000ac843834" category="paragraph">精细控制 NFS 挂载选项</block>
  <block id="c9266840071171609b858a86983e5cbc" category="paragraph">-o nfsver=3</block>
  <block id="bb7d88b29e22a86389e711d24d78d8b0" category="admonition">Azure NetApp Files 服务不支持小于 100 GB 的卷。为了便于部署应用程序，如果请求的卷较小， Trident 会自动创建 100 GB 的卷。</block>
  <block id="c73b8a061778625d86923a1ee3b2b65a" category="paragraph">您可以在配置的特殊部分中使用这些选项来控制默认配置每个卷的方式。</block>
  <block id="9aef9232b6d23ad9af140b946025a2e9" category="paragraph">新卷的导出规则。必须是以 CIDR 表示法表示的任意 IPv4 地址或 IPv4 子网组合的逗号分隔列表。</block>
  <block id="5b080068f6b7a62124d4bbe75e0ccebe" category="paragraph">"0.0.0.0/0 "</block>
  <block id="cf4ad5c346075cb763a78a1eeb590f67" category="paragraph">"100G"</block>
  <block id="c26659d1a1cc7dd886f591fd462c9b91" category="section-title">Azure NetApp Files 配置示例</block>
  <block id="b735d2db48e665b21117295550615ff3" category="paragraph">* 示例 1 ： azure-netapp-files* 的最小后端配置</block>
  <block id="c9ed1200ddf4fe7e1e4120cb35885310" category="paragraph">这是绝对的最低后端配置。使用此配置， Trident 将发现全球每个位置委派给 ANF 的所有 NetApp 帐户，容量池和子网，并随机将新卷放置在其中一个上。</block>
  <block id="c31e8cd6c5230f025186373673347b9c" category="paragraph">当您刚开始使用 ANF 并尝试执行以下操作时，此配置非常有用： 但实际上，您将需要为您配置的卷提供额外的范围界定，以确保这些卷具有所需的特征，并最终位于一个靠近使用该卷的计算的网络上。有关详细信息，请参见后续示例。</block>
  <block id="189a6649956b03bce537a5eb6247fc83" category="paragraph">* 示例 2 ： azure-netapp-files* 的单一位置和特定服务级别</block>
  <block id="0f10d4c5e31fffa777f19dd757816f93" category="paragraph">此后端配置会将卷放置在 Azure 的 " 东向 " 位置的 " 高级 " 容量池中。Trident 会自动发现该位置委派给 ANF 的所有子网，并随机在其中一个子网上放置一个新卷。</block>
  <block id="418698e54dde6b45a123af5be774679e" category="paragraph">* 示例 3 ： azure-netapp-files* 的高级配置</block>
  <block id="75f9eb2b518c3ec9d39a7c1f8b4b94a9" category="paragraph">* 示例 4 ：使用 azure-netapp-files* 的虚拟存储池</block>
  <block id="e0b432486549d4404054c64e947ef84e" category="inline-link-macro">存储池</block>
  <block id="b0e0c2dae5878f7a113284ddd0f3c6c2" category="paragraph">此后端配置定义了多个 <block ref="a2da53ffe8493aa084053197c8de9b91" category="inline-link-macro-rx"></block> 在单个文件中。如果您有多个容量池支持不同的服务级别，并且您希望在 Kubernetes 中创建表示这些服务级别的存储类，则此功能非常有用。</block>
  <block id="8b4e612e7ec021b91bdf46a69c393a75" category="paragraph">这只是擦除虚拟存储池及其标签的强大功能表面。</block>
  <block id="27dce2b92c5c5b89e353888e6cb24dea" category="summary">您可以安全地升级适用于 Docker 的 Astra Trident ，而不会对正在使用的卷产生任何影响。在升级过程中，指向插件的 `docker volume` 命令将在很短的时间内失败，并且应用程序将无法挂载卷，直到插件重新运行为止。在大多数情况下，这只需要几秒钟。</block>
  <block id="0350c5473efd300324aaaadeecc676d2" category="doc">升级或卸载 Astra Trident</block>
  <block id="f683581d3e75f05f9d9215f9b4696cef" category="section-title">升级</block>
  <block id="ed279061e829314cb0dc7a1708ca5e5b" category="list-text">列出现有卷：</block>
  <block id="7c256ad076320e18e087b238e9063f3f" category="list-text">禁用插件：</block>
  <block id="f4ea3e4191f5bda0b91e08059bf9842a" category="list-text">升级插件：</block>
  <block id="b2449107a206e37587b47513f76a7b27" category="admonition">Astra Trident 18.01 版取代了 nDVP 。您应直接从 `NetApp/ndvp-plugin` 映像升级到 `NetApp/trident 插件` 映像。</block>
  <block id="824ba648551a27da6c43705bcd663830" category="list-text">启用插件：</block>
  <block id="e4c48899ce42f4eb019f54a1a8e66560" category="list-text">验证是否已启用此插件：</block>
  <block id="c4d884c606b57bb6cb43864e3499d5a2" category="list-text">验证卷是否可见：</block>
  <block id="103e515a078c6f2419abc4c84554d67c" category="admonition">如果要从旧版本的 Astra Trident （ 20.10 之前的版本）升级到 Astra Trident 20.10 或更高版本，则可能会遇到错误。有关详细信息，请参见 <block ref="6d21ff1c2708107ac3f4ed1a6e27b449" category="inline-link-macro-rx"></block>。如果遇到此错误，应先禁用此插件，然后删除此插件，然后通过传递一个额外的配置参数来安装所需的 Astra Trident 版本： `docker plugin install netapp/trident plugin ： 20.10 —— alias netapp — -grant-all-permissions config.json`</block>
  <block id="a27dfe771799a09fd55fea73286eb6ab" category="section-title">卸载</block>
  <block id="7578be09dc225364649898a30619a336" category="paragraph">执行以下步骤卸载适用于 Docker 的 Astra Trident 。</block>
  <block id="867d93c3d1de0e8e75fa408cfadcbba5" category="list-text">删除插件创建的所有卷。</block>
  <block id="4a28a108f39c07ac09218644ca6e9bb0" category="list-text">删除插件：</block>
  <block id="c412f3b9b270250331aa1ef4102ef8c1" category="summary">如果您希望同时提供多个存储配置，则需要多个 Astra Trident 实例。多个实例的关键在于，在主机上实例化 Trident 时，使用 -alias 选项和容器化插件或 -volume-driver 选项为其提供不同的名称。</block>
  <block id="4f07a71d2e33da91dec1396b7a204a40" category="doc">管理多个 Astra Trident 实例</block>
  <block id="8f327f2ceda84404290184a7454160ed" category="paragraph">如果希望同时提供多个存储配置，则需要多个 Trident 实例。多个实例的关键在于，在主机上实例化 Trident 时，使用容器化插件的 ` -alias` 选项或 ` -volume-driver` 选项为其提供不同的名称。</block>
  <block id="52ef1c6ffefaba3249f208369424635d" category="section-title">Docker 托管插件（ 1.13/17.03 或更高版本）的步骤</block>
  <block id="547c4a5f7c863aad85f5265c03ed72ea" category="list-text">启动指定别名和配置文件的第一个实例。</block>
  <block id="991ac134f22efa2bb955362d95827ae5" category="list-text">启动第二个实例，指定其他别名和配置文件。</block>
  <block id="aa0dc0ac69e69c434317798e1aa9842b" category="list-text">创建将别名指定为驱动程序名称的卷。</block>
  <block id="5ae25a45ab76de161f87fc41a84f746d" category="paragraph">例如，对于黄金卷：</block>
  <block id="6dab7c53f6e3de2eae52e928dfe5b861" category="paragraph">例如，对于银牌卷：</block>
  <block id="67754cb209925946943e297b3a8be344" category="section-title">传统（ 1.12 或更早版本）的步骤</block>
  <block id="cbd128765e82966ed5e454a99b22e688" category="list-text">使用自定义驱动程序 ID 启动具有 NFS 配置的插件：</block>
  <block id="51c923daa4caf6aea6d24201b73871b6" category="list-text">使用自定义驱动程序 ID 启动具有 iSCSI 配置的插件：</block>
  <block id="dd72ade865d731ba8f6a6fc4c8ccd86f" category="list-text">为每个驱动程序实例配置 Docker 卷：</block>
  <block id="8e2044cc9d4e8f515ad4809a68d75465" category="paragraph">例如，对于 NFS ：</block>
  <block id="d39eb6e4299503c5d451d19b9645be42" category="paragraph">例如，对于 iSCSI ：</block>
  <block id="c2bccf4258de19dd1e03e25f66d80f98" category="summary">查找有关将 Astra Trident 与 Docker 结合使用时的已知问题的信息。</block>
  <block id="3a3b7ac2e39541ea05707ccd6eb054d4" category="doc">已知问题和限制</block>
  <block id="ba6bb78ba304725781af9e773f1957e2" category="paragraph">查找有关将 Astra Trident 与 Docker 结合使用时的已知问题和限制的信息。</block>
  <block id="8bb35988eac5a841d2af092365f1aa42" category="section-title">将 Trident Docker 卷插件从旧版本升级到 20.10 及更高版本会导致升级失败，并且不会显示此类文件或目录错误。</block>
  <block id="7aebfa1e2291377e040de92d7f7f335f" category="list-title">临时解决策</block>
  <block id="f49f11bc5398ac13e500d16eac424e77" category="list-text">禁用插件。</block>
  <block id="cc3dae6dd6670606c41c62b10273605e" category="list-text">删除此插件。</block>
  <block id="6010901b5c4bb6ad671e6f07fcc038d8" category="list-text">通过提供额外的 `config` 参数来重新安装插件。</block>
  <block id="e527ab8c1c51767e38a3603d51d2d6e5" category="section-title">卷名称的长度必须至少为 2 个字符。</block>
  <block id="45c9df594d13c8a5e5472503d5f14b01" category="inline-link">请参见错误 25773</block>
  <block id="c167efd138e06a8ee59885983c5ddf69" category="admonition">这是 Docker 客户端的限制。客户端会将单个字符名称解释为 Windows 路径。<block ref="f082f49b923960d888c1d98a1e9f4fcb" category="inline-link-rx"></block>。</block>
  <block id="3c4f022a33d4aace82350c9966fa238b" category="section-title">Docker Swarm 的某些行为会阻止 Astra Trident 在每个存储和驱动程序组合中为其提供支持。</block>
  <block id="a7c3ff464b1ef4364de4df03d66bee5e" category="list-text">Docker Swarm 目前使用卷名称而非卷 ID 作为其唯一卷标识符。</block>
  <block id="61ab6f5cff8de89cba95d9e3bbc4ff71" category="list-text">卷请求会同时发送到 Swarm 集群中的每个节点。</block>
  <block id="521e51548c3f7c96e72d432edf4af42d" category="list-text">卷插件（包括 Astra Trident ）必须在 Swarm 集群中的每个节点上独立运行。由于 ONTAP 的工作方式以及 `ontap-NAS` 和 `ontap-san` 驱动程序的工作方式，它们恰好是唯一能够在这些限制范围内运行的驱动程序。</block>
  <block id="69418caf7b92279073f695612c68de99" category="paragraph">其余驱动程序可能会受到诸如争用情况等问题的影响，这些问题可能会导致为单个请求创建大量卷，而无需明确的 " 赢家 " ；例如， Element 具有一项功能，允许卷具有相同的名称，但 ID 不同。</block>
  <block id="48cbf13b390ff021b130d5f372147af5" category="paragraph">NetApp 已向 Docker 团队提供反馈，但没有任何迹象表明将来可以采用。</block>
  <block id="29cff148f43bc689eb14447b333f6f83" category="section-title">如果要配置 FlexGroup ，则在第二个 FlexGroup 具有一个或多个与要配置的 FlexGroup 相同的聚合时， ONTAP 不会配置第二个 FlexGroup 。</block>
  <block id="d327e8f24b63b83e091dccdc48dd7b1b" category="sidebar">Astra Trident 文档</block>
  <block id="7d0ee6fed10d3d4e5c9ee496729ab519" category="sidebar">发行说明</block>
  <block id="93168a8084b3e838d2932c4734bd234e" category="sidebar">早期版本</block>
  <block id="0629fb104936d0fb60cc736b6cb01caa" category="sidebar">Astra Trident 要求</block>
  <block id="33871b6190a8d5adbe8b15282054766c" category="sidebar">新增功能</block>
  <block id="1fe917b01f9a3f87fa2d7d3b7643fac1" category="sidebar">常见问题解答</block>
  <block id="312b0dc38b01ff32c1b2f5f81ee1ab2d" category="sidebar">使用 Trident 操作员进行部署</block>
  <block id="e0e3d7f1aacdf4a8196132549709430c" category="sidebar">使用 tridentctl 进行部署</block>
  <block id="6a693eb5cd23e4e5743663c7edc37aed" category="sidebar">部署适用于 Docker 的 Astra Trident</block>
  <block id="386307d41b3f4169a1e6e046a727cdd2" category="sidebar">使用 Trident 操作员进行升级</block>
  <block id="2a21586f7990f8cb0f8951cd2ef7bc3b" category="sidebar">使用 tridentctl 进行升级</block>
  <block id="eb1f347fa6176ae2c9175df3bc414954" category="sidebar">使用 Astra Trident</block>
  <block id="a8e174c63ac21920b8405ffddc39214a" category="sidebar">使用 kubectl 创建后端</block>
  <block id="81a123ccab93cd947289b672b0e50348" category="sidebar">演示教程</block>
  <block id="28348a71bed382b86fa6de4d3a307715" category="sidebar">Astra Trident 视频</block>
  <block id="813011e2103649bb71f124adedcc10ea" category="sidebar">博客社区</block>
  <block id="6394eceb2639574114b02e6e817eb19a" category="sidebar">Astra 博客</block>
  <block id="874d8a5301794a9ca2aba132ac2460f3" category="sidebar">Kubernetes Hub</block>
  <block id="d59c00abbeaf33a9a094b3a69c563405" category="sidebar">netapp.io</block>
  <block id="63d5049791d9d79d86e9a108b0a999ca" category="sidebar">参考</block>
  <block id="324fb1352ffffb105d10013810c42896" category="sidebar">Kubernetes 和 Astra Trident 对象</block>
  <block id="a20f982d79c3dd66d244ffe0f7d940ee" category="sidebar">最佳实践和建议</block>
  <block id="c91cf7abea9584bc1edbc8ff4948ada0" category="sidebar">Astra Trident 集成</block>
  <block id="c949166d6970748c0094c800daa3324a" category="sidebar">管理 Astra Trident</block>
  <block id="0460583622f03a52d7693094d6fa2452" category="sidebar">概念</block>
  <block id="bbe2bfefd5797bb567e3da92f68ce8d1" category="sidebar">自定义 tridentctl 部署</block>
  <block id="58eaebf972358f1cf03d386a4ade1a0f" category="sidebar">下一步是什么？</block>
  <block id="cc4a0df2c635530d752308ab5a1c4b89" category="sidebar">配置 ANF 后端</block>
  <block id="bffb766af67c15f14cae35f03dd6f4a9" category="sidebar">使用 kubectl 执行后端管理</block>
  <block id="748a22b5f1312291ad55429ba4b809a0" category="sidebar">使用 tridentctl 执行后端管理</block>
  <block id="f14894e4c400a400c02367258a93029a" category="sidebar">适用于 Docker 的 Astra Trident</block>
  <block id="e08bfc79c5202517b3814efd6e82fb2c" category="sidebar">升级或卸载 Trident</block>
  <block id="f14a1d8e56a0cbd2826edd38778371f7" category="admonition">如果状态显示 `Updating` ，请确保先解决此问题，然后再继续。有关可能的状态值列表，请参见<block ref="6aefd1c9ce8e43313a8c7c92e2fac4f3" category="inline-link-rx"></block>。</block>
  <block id="91cba8fa9749855921b347b0cf808b76" category="doc">Astra Trident 21.10 文档</block>
  <block id="05d68d1b7214c73141ed12aaed0c2ab5" category="list-text">如果 Trident 日志中的信息不足，您可以根据安装选项将 ` -d` 标志传递到 install 参数，尝试为 Trident 启用调试模式。</block>
  <block id="bc6de9cad530a57dba08ff711f4a6b5f" category="paragraph">然后，使用 ` ./tridentctl logs -n trident` 并在日志中搜索 `level=debug msg` 来确认是否设置了调试。</block>
  <block id="8e95ae46f32b05cf983c93e608530e36" category="list-text">随操作员一起安装</block>
  <block id="6a304a6cf7cd8c90bac892ab0fb9c134" category="paragraph">对于 Astra Trident 20.07 和 20.10 ，请使用 `tprov` 代替 `Torc` 。</block>
  <block id="79b91d0489c081de6794796638793787" category="list-text">随 Helm 一起安装</block>
  <block id="d356d628089d439d75e3f85564372658" category="list-text">使用 tridentctl 安装</block>
  <block id="1b6ea3b57d23007f55ba778700bc369c" category="inline-link">文档版本更新版</block>
  <block id="af78f8cf3a2a8307db27d14c5642d95f" category="paragraph">对于先前版本，请参见<block ref="a3e07c08f1bbcd23d8422302f837e06b" category="inline-link-rx"></block>。</block>
  <block id="91bffb05ce7b35189932ad387d14e41b" category="paragraph">"apiRegion"` 表示 Astra Trident 在其中创建 CVS 卷的 GCP 区域。 `在 `跨区域 Kubernetes 集群时，在 "apiRegion"` 中创建的 CVS 卷可用于在多个 GCP 区域的节点上计划的工作负载。请注意，跨区域流量会产生额外成本。</block>
  <block id="31842a4ad923dd3481336d7d93dc2068" category="list-text">要启用跨区域访问， `allowedTopologies` 的 StorageClass 定义必须包括所有地区。例如：</block>
  <block id="433f174b6e54b889696b2efd4ef40dc6" category="admonition">可以将 Trident REST 接口配置为仅以 127.0.0.1 （对于 IPv4 ）或（：： 1 ）（对于 IPv6 ）侦听和提供服务。</block>
  <block id="1968a7e86875b6b6ca9d5222172f8d16" category="list-text">`` -http-request-timeout` ：覆盖 Trident 控制器的 REST API 的 HTTP 请求超时（默认值为 1m30s ）。</block>
  <block id="705db3afa1c1d4451f7b0f7f8552f1b5" category="list-text">您对运行 Kubernetes 1.17 及更高版本的受支持 Kubernetes 集群拥有完全权限。</block>
  <block id="3b4c548466953befff1962ac2426cb8e" category="paragraph">要查看您的 Kubernetes 版本是否高于 1.17 ，请运行以下命令：</block>
  <block id="834bb262db01800c5b2fc71ef097a803" category="admonition">如果使用的版本低于 4.6-8 ， Red Hat OpenShift 容器平台用户可能会发现其 initiatorname.iscsi 文件为空。这是 RedHat 已确定的一个错误，需要通过 OpenShift 4.6-8 进行修复。请参见此内容<block ref="ac064f2337a2fc6c16c562bc9e386352" category="inline-link-rx"></block>。NetApp 建议您在 OpenShift 4.7 及更高版本上使用 Astra Trident 。</block>
  <block id="85bfe817bf2347bf6d5dcea4b86ade72" category="cell">应用程序注册中的客户端 ID</block>
  <block id="a5e65d71b5d7719b3a51518133fd2538" category="cell">"" （随机）</block>
  <block id="23ef4149f946c881b1c40a6ac1510554" category="admonition">修改现有后端的 `capacityPools` 字段以减少用于配置的容量池的数量会导致孤立卷，这些卷会在不再属于 `capacityPools` 列表的容量池 / 池上配置。对这些孤立卷执行克隆操作将失败。</block>
  <block id="ae9b95a558c60bdc3b5682a1ca2625ea" category="admonition">如果要使用 NFS 4.1 挂载卷，可以在逗号分隔的挂载选项列表中包含 ``nfsver=4`` 以选择 NFS v4.1 。存储类中设置的任何挂载选项都会覆盖后端配置文件中设置的挂载选项。</block>
  <block id="fb10fd1921fe8ac41f7ce51b41dd3320" category="paragraph">这是绝对的最低后端配置。借助此配置， Astra Trident 可以发现全球每个位置委派给 ANF 的所有 NetApp 帐户，容量池和子网，并随机将新卷放置在其中一个上。</block>
  <block id="04e5e56f251267658dc57f90ae659538" category="section-title">示例 2 ：单个位置和特定服务级别配置</block>
  <block id="93d594d992801662d9e5e5d1ccf8bb86" category="paragraph">此后端配置会将卷放置在 Azure 的 `东向` 位置的 `高级` 容量池中。Astra Trident 会自动发现该位置委派给 ANF 的所有子网，并随机在其中一个子网上放置一个新卷。</block>
  <block id="cf282b9c05ab0f84b1690e644cd3f68e" category="list-text">对于 `ontap-nas-flexgroup` 驱动程序，每个永久性卷（ PV ）都会映射到一个 FlexGroup 。因此，卷快照会创建为 NetApp FlexGroup 快照。与竞争对手的 Snapshot 技术相比， NetApp 的 Snapshot 技术可提供更高的稳定性，可扩展性，可恢复性和性能。无论是在创建 Snapshot 副本所需的时间还是在存储空间中，这些 Snapshot 副本都极为高效。</block>
  <block id="ba9e76e1be4705136fd15fd947717d07" category="paragraph">从目前开始，我们为 `ontap-nas` ， `ontap-nas-flexgroup` ， `ontap-san` ， `ontap-san-economics` ， `solidfire-san` ， `AWS-CVS` ， `GCP-CVS` 和 `azure-netapp-files` 后端驱动程序。</block>
  <block id="1600a61b1da8ff824ac37a5e83b2aef0" category="paragraph">从 Astra Trident 的 20.01 版开始，您可以在 Kubernetes 层创建 PV 快照。您可以使用这些快照维护由 Astra Trident 创建的卷的时间点副本，并计划创建其他卷（克隆）。卷快照受 `ontap-nas` ， `ontap-nas-flexgroup` ， `ontap-san` ， `ontap-san-economics` ， `solidfire-san` 支持。 `AWS-CVS` ， `GCP-CVS` 和 `azure-netapp-files` 驱动程序。</block>
  <block id="cac3274b477ab652946784fa7e4d61e7" category="paragraph">Astra Trident 是一个由 NetApp 维护的完全受支持的开源项目。它经过全新设计，可帮助您使用容器存储接口（ CSI ）等行业标准接口满足容器化应用程序的持久性需求。</block>
  <block id="3777daa0663e4d3f177a85bc67443c32" category="paragraph">Astra Trident 作为 Pod 部署在 Kubernetes 集群中，并为您的 Kubernetes 工作负载提供动态存储编排服务。它可以让您的容器化应用程序快速轻松地使用 NetApp 广泛产品组合中的永久性存储，这些产品组合包括 ONTAP （ AFF/FAS/Select/Cloud/Amazon FSx for NetApp ONTAP ）， Element 软件（ NetApp HCI/SolidFire ）以及 Azure NetApp Files 服务， Google Cloud 上的 Cloud Volumes Service 和 AWS 上的 Cloud Volumes Service 。</block>
  <block id="34354c1f7e5f61fa8fe457b846c277e1" category="paragraph">请查看 Astra 文档，立即开始使用。您可以立即在 Astra 页面上注册免费试用。</block>
  <block id="b90cfe7eec2fd25d8051aa0d2904effd" category="inline-link">Astra 控制服务简介</block>
  <block id="e863c6f356f601b620d332145ba64279" category="list-text"><block ref="e863c6f356f601b620d332145ba64279" category="inline-link-rx"></block></block>
  <block id="84a414bad3d440f298f070c3d3fa60bb" category="inline-link">开始使用 Astra API</block>
  <block id="22e85cb2bef8534170e0b3aa21efdd42" category="list-text"><block ref="22e85cb2bef8534170e0b3aa21efdd42" category="inline-link-rx"></block></block>
  <block id="41babe56ec27c9b39ecab6c854265300" category="inline-link">了解 Astra 控制中心</block>
  <block id="05e8ff43093720b9084af213039e0bc5" category="list-text"><block ref="05e8ff43093720b9084af213039e0bc5" category="inline-link-rx"></block></block>
  <block id="162868582f509647f4b899829f6e41f6" category="paragraph">在此步骤中， 21.07.1 Trident 操作员将确定现有的 Astra Trident 安装并将其升级到与操作员相同的版本。</block>
  <block id="a1509084d79ec341b5fa6440d1be8634" category="paragraph">如果您未运行最新版本，则可以参考先前版本的 Astra Trident 文档。</block>
  <block id="aeeec433666472b603c30d4253b0ebf5" category="admonition">有关 Astra Trident 21.07 及相关修补程序版本的文档为<block ref="05716ac1466b0f4f02ba68e41e25a5d9" category="inline-link-rx"></block>。</block>
  <block id="b2b6d326276756e4c6b75a232980415b" category="admonition">早期版本的 Astra Trident 的文档位于我们的原有文档站点中。</block>
  <block id="b89df534de66f446ec6482f9d7898bb2" category="cell">`控制器插件节点选择器`</block>
  <block id="15cfc4bea44cee69551eb577fb0dcd8a" category="cell">运行 Trident 控制器 CSI 插件的 Pod 的其他节点选择器。格式与 pod.spec.nodeSelector 相同。</block>
  <block id="8d414af35aeb82413205fa45551a5545" category="cell">无默认值；可选</block>
  <block id="df1f367efe879ec0030f43610e29c5af" category="cell">`控制器插件公差`</block>
  <block id="2fba8e7843d1d343f2fe29feeca4b34d" category="cell">覆盖运行 Trident 控制器 CSI 插件的 Pod 的容错。格式与 po.spec.Tolerations 相同。</block>
  <block id="47a441037628a3c0f0edb0daccb33f99" category="cell">`nodePluginNodeSelector`</block>
  <block id="109ef057002ce8b5901039ee5b81df88" category="cell">运行 Trident Node CSI 插件的 Pod 的其他节点选择器。格式与 pod.spec.nodeSelector 相同。</block>
  <block id="f297db5a937924105908a365d9d4c4ff" category="cell">`nodePluginTholeations`</block>
  <block id="01fae47efea3407f5bc27a09eea8709c" category="cell">覆盖运行 Trident Node CSI 插件的 Pod 的容错。格式与 po.spec.Tolerations 相同。</block>
  <block id="4352a1b4e004cf57ac04661a18de43aa" category="inline-link-macro">将 Pod 分配给节点</block>
  <block id="b3b67fd79d24b4873c8164c750c21798" category="admonition">有关格式化 POD 参数的详细信息，请参见 <block ref="7b3a69fdac08c769183925679da4c365" category="inline-link-macro-rx"></block>。</block>
  <block id="6835e07bc055fcef1cc48dc5a6f625a8" category="list-text">OpenShift 4.4 ， 4.5 ， 4.6 （ 4.6.8+ ）， 4.7 ， 4.8 （最新的 4.8 ）</block>
  <block id="9d731f8383dd11a9e23415f4e5621ee6" category="section-title">支持的主机操作系统</block>
  <block id="462b8344a4e3b491690838228ddbedb5" category="paragraph">默认情况下， Astra Trident 本身在容器中运行，因此它将在任何 Linux 工作程序上运行。但是，根据您使用的后端，这些员工需要能够使用标准 NFS 客户端或 iSCSI 启动程序挂载 Astra Trident 提供的卷。</block>
  <block id="1def7d1add436c6afb595676d8c32a2f" category="paragraph">这些是已知有效的 Linux 分发版：</block>
  <block id="4bd66d391160d942582baacb04fa201f" category="paragraph">Astra Trident 可能需要先对存储系统进行一些更改，然后后端配置才能使用它。请参见 <block ref="49641f5ab61d7a6ce07b1b6ba31204f8" category="inline-link-macro-rx"></block> 了解详细信息。</block>
  <block id="47d07011bca79befe16bb700e92dcbc1" category="list-text">NetApp/trident ： 21.07.0</block>
  <block id="d9f8e2d8dd775582f52f3faab2fd1e65" category="list-text">netapp/trident 操作符： 21.07.0</block>
  <block id="2e6c4d3ef0db2b4c90724d4a5476e36d" category="list-text">netapp/trident autosupport ： 21.01</block>
  <block id="b30d0a097738f86abbfecf3f9ea80403" category="list-text">K8s.gcr.io/SIG-storage/CsI-provisioner ： v2.1.1</block>
  <block id="0add2d5b06a46b805acf99b6548b2398" category="list-text">K8s.gcr.io/SIG-storage/CsI-attacher ： v3.1.0</block>
  <block id="2ca7c243ca3adf9f395ed61cad94c4b9" category="list-text">K8s.gcr.io/SIG-storage/CsI-resizer ： v1.1.0</block>
  <block id="74ba55b5b18f4a1327f8e0691e73ec2e" category="list-text">k8s.gcr.io/sig-storage/CsI-node-driver-registry:v2.1.0</block>
  <block id="f5de0771348311ab6f3933f60bd8008d" category="list-text">K8s.gcr.io/SIG-storage/CsI-snapshotter ： v4.1.1</block>
  <block id="6f2ac1cf1da8ec34232c651d4bba0149" category="paragraph"><block ref="6f2ac1cf1da8ec34232c651d4bba0149" category="inline-link-macro-rx"></block></block>
  <block id="4dafc112897e668d8c968f7418829817" category="paragraph">`sUdo tee /etc/multipath.conf &lt;&lt;-'EOF' defaults ｛ user_friendly_names yes find_multipaths yes ｝ eOF sudo systemctl enable -now multipath-tools.service sudo service multipath-tools restart`</block>
  <block id="415e3eb51625ca73d5e09053eea6a42b" category="section-title">21.10 中的新增功能</block>
  <block id="c1f57827e94910e34725b8cf11415683" category="paragraph">NetApp 不断改进和完善其产品和服务。以下是 Astra Trident 的一些最新特性和功能。</block>
  <block id="57138e91e6168cecf9d0dad2afd12735" category="paragraph">同时 <block ref="6ad29d013fc003c1446dfe4715881765" category="inline-link-macro-rx"></block> 是与 Astra Trident 的 REST API 进行交互的最简单方式，您可以根据需要直接使用 REST 端点。</block>
  <block id="82afa66ce2496cc16fa1a7a5a6b3a000" category="paragraph">可用的命令和全局选项如下：</block>
</blocks>